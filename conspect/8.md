# 8 Базы данных

> [[_оглавление_]](../README.md/#8-базы-данных)

Одна из основных целей языка программирования - хранение и обработка информации.  
Архитектурно хранение данных делится на слои:

- _Data Tier_ (Слой данных) - это уровень хранения самих данных (например, _SQL_-база данных);
- _Persistence Layer_ - это некоторый уровень абстракции (средств) для работы с данными из хранилища с уровня _Data
  Tier_ (например, шаблон _DAO_, различные _ORM_).

[**База данных**](/conspect/definitions.md/#б) - это совокупность данных, организованных в соответствии с концептуальной
структурой, описывающей характеристики этих данных и взаимоотношения между ними; совокупность множества таблиц, которые
связаны между собой.

Данные в базах данных хранятся в виде таблиц.  
Каждая таблица - это коллекция определённых сущностей.  
У каждой записи сущности в таблице есть уникальный идентификатор.

Наиболее популярной базой данных является [_PostgreSQL_](/conspect/7.md/#73-postgresql).

## 8.1 Data Tier

> [[_оглавление_]](../README.md/#81-data-tier)

Свойства баз данных:

- быстродействие;
- простота получения и обновления данных;
- безопасность (в большинстве БД можно настраивать разные уровни доступа к таблицам);
- многопользовательский доступ;
- объём хранимых данных.

Базы данных по способу хранения данных подразделяются на:

- _централизованные_ - вся информация хранится на одном компьютере;
- _распределённые_ - информация распределена по разным компьютерам.

Типы баз данных:

- _реляционные_ - состоят из множества таблиц, распределённых по смыслу, а между таблицами есть связи;
- _нереляционные_ - базы данных, в которых информация содержится в виде документов _JSON_ и структурированы с
  использованием _JavaScript_;
- _документоориентированные_ - единицей информации является документ, причём без ограничения по формату, а это значит,
  что можно добавлять новые данные как угодно и в каком угодно формате, не требуя, чтобы у всех остальных записей БД
  была одинаковая структура (примеры: _MongoDB_, _Couchbase_, _Firebase_);
- _графовые_ - информация хранится в графах;

> [**Граф**](/conspect/definitions.md/#г) - это математический термин, означающий совокупность двух множеств: множества
> объектов (вершин) и множества парных связей этих объектов (рёбер).  
> Пример графа - это дерево каталогов в компьютере, где диски, папки и файлы - вершины, а вложенность файлов и папок в
> папки и диски - рёбра.

- _колоночные_ (_столбцовые_) - данные записываются не в строки, а в столбцы;
- _key-value_ - информация представляется в виде пары «ключ-значение»;
- _сетевые_ - данные организованы по принципу сети или связанной структуры, то есть у одной записи может быть несколько
  родительских и дочерних записей;
- _иерархические_ - строится по принципу «родитель-ребёнок», где каждый дочерний элемент имеет только один родительский
  элемент (эта модель организует данные в древовидной структуре).

Чтобы получать, добавлять, сохранять нужные данные в базе данных, в большинстве случаев используют язык запросов _SQL_.

[**Система управления базой данных (СУБД)**](/conspect/definitions.md/#с) - это инструменты, с помощью которых
запрашивают данные в базе, изменяют или создают базы.

Среди СУБД выделяют реляционные, объектно-реляционные, нереляционные документированные СУБД и _Redis_.  
[**Redis (Remote Dictionary Server)**](/conspect/definitions.md/#r) - это открытая _NoSQL_-система управления базами
данных.  
То есть она не использует язык запросов _SQL_, а запрашивает данные с помощью других языков программирования и
конструкций. _Redis_ полезна, чтобы хранить игровые сессии, рейтинговые таблицы, состояние игроков, статистику игр и
других временных или постоянных данных, которые нужно обрабатывать быстро.

## 8.2 Persistence Layer

> [[_оглавление_]](../README.md/#82-persistence-layer)

### 8.2.1 JDBC

> [[_оглавление_]](../README.md/#82-persistence-layer)

[**JDBC (Java DataBase Connectivity)**](/conspect/definitions.md/#j) - это соединение с базами данных на Java; стандарт
взаимодействия Java-приложений с различными [СУБД](/conspect/definitions.md/#с), реализованный в виде пакетов `java.sql`
и `javax.sql`, входящих в состав _Java SE_.

Данный стандарт описан спецификацией _JSR 221 JDBC 4.1 API_, основными постулатами которой являются:

- _JDBC API_ предоставляет программный доступ к реляционным базам данных из программ, написанных на Java;
- _JDBC API_ является частью платформы Java и входит поэтому в _Java SE_ и _Java EE_;
- _JDBC API_ представлен двумя пакетами: `java.sql` and `javax.sql`.

![38.png](/pictures/38.png)

База данных является внешним компонентом, которого нет изначально в _Java SE_. Это объясняется просто - существует
огромное количество баз данных и работать можно захотеть с любой. Например, есть _PostgreSQL_, _Oracle_, _MySQL_, _H2_.
Каждая из этих баз данных поставляется отдельной компанией, которые называются поставщиками баз данных. Каждая база
данных написана на каком-то своём языке программирования (не обязательно Java). Чтобы с базой данных можно было работать
из Java приложения поставщик базы данных пишет особый драйвер (_JDBC Driver_), который является своего образа адаптером.
Каждый такой _JDBC_-драйвер — это некоторый артефакт, библиотека, _jar_-файл. Он то и добавляется в качестве зависимости
для проекта.

_JDBC_-драйвер не является базой данных, а является проводником к ней.

[**In memory databases**](/conspect/definitions.md/#i) - это такие базы данных, которые существуют в оперативной памяти
на время жизни приложения.

_In memory databases_, как правило, применяются для тестирования приложений.

### 8.2.2 JPA

> [[_оглавление_]](../README.md/#82-persistence-layer)

[**ORM (Object-Relational Mapping)**](/conspect/definitions.md/#o) - это объектно-реляционное отображение; технология
программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования (связь
Java-объектов и записей в БД).

_ORM_ появился как дальнейшее развитие _JDBC_ с целью избавления разработчиков от необходимости писать однотипный и
ненужный "обслуживающий" код (так называемый _Boilerplate code_) для тривиальных операций по сохранению Java-объектов в
БД и наоборот, созданию Java-объектов по данным из БД.

![39.png](/pictures/39.png)

_ORM_ - это по сути концепция о том, что Java-объект можно представить как данные в БД (и наоборот). Она нашла
воплощение в виде спецификации _JPA_.

[**JPA (Java Persistence API)**](/conspect/definitions.md/#j) - это спецификация _API Jakarta EE_, которая предоставляет
возможность сохранять в удобном виде Java-объекты в базе данных.

Одной из самых популярных реализаций _JPA_ является _Hibernate_.

### 8.2.3 Hibernate

> [[_оглавление_]](../README.md/#82-persistence-layer)

[**Hibernate**](/conspect/definitions.md/#h) - это фреймворк для языка Java, предназначенный для работы с базами данных.

Он реализует объектно-реляционную модель (_ORM_) - технологию, которая соединяет программные сущности и соответствующие
записи в БД. Иногда его называют библиотекой - оба названия в принципе справедливы.

_Hibernate_ построен на спецификации _JPA 2.1_ — наборе правил, который описывает взаимодействие программных объектов с
записями в базах данных. _JPA_ поясняет, как управлять сохранением данных из кода на Java в базу. Но сама по себе
спецификация — только теоретические правила, а в чистой Java ее реализации нет. _Hibernate_ — одна из самых популярных
реализаций _JPA_.

_Hibernate_:

- ускоряет и облегчает написание кода;
- позволяет создать удобную модель для отображения базы данных в коде;
- дает возможность быстро и в читаемом виде записывать информацию из кода в базу.

Основная идея фреймворка - создать виртуальную базу данных из программных объектов и работать с ней как с реальной
базой. Поэтому им часто пользуются для упрощения работы. Он берет на себя взаимодействие с реляционной БД, а
разработчику остаётся работать с кодом.

В _Hibernate_ есть возможность, которую называют «ленивой загрузкой». Объекты во фреймворке не подгружают всю информацию
из базы изначально. Вместо этого они просто «знают», как ее получить, и при первом обращении к информации загружают ее в
фоне. Это нужно для оптимизации производительности.

Внутри _Hibernate_ имеется собственный язык запросов _Hibernate Query Language_ (_HQL_). Это _SQL_-подобный язык, но
полностью объектно-ориентированный и более краткий — не приходится так много работать с шаблонным кодом, как в чистом
_SQL_.

Преимущества использования _Hibernate_:

- популярность;
- устранение лишнего кода;
- возможность сосредоточиться на логике;
- независимость от базы данных (_Hibernate_ может работать с любой БД);
- объектно-ориентированный подход.

Недостатки использования _Hibernate_:

- сложность в освоении;
- проблемы с производительностью;
- непредсказуемость кода;
- сложности с кэшированием.

## 8.3 SQL

> [[_оглавление_]](../README.md/#83-sql)

[**SQL (Structured Query Language)**](/conspect/definitions.md/#s) - это язык структурированных запросов; язык
программирования, предназначенный для управления данными в базе данных.

В _SQL_ есть две составные части: _DDL_ и _DML_.

[**DDL (Data Definition Language)**](/conspect/definitions.md/#d) - это подмножество языка _SQL_, используемое для
определения структуры базы данных и ее объектов, таких как таблицы, представления, индексы и процедуры.

[**DML (Data Manipulation Language)**](/conspect/definitions.md/#d) - это подмножество языка _SQL_, используемое для
манипулирования данными в базе данных.

В скриптах сначала выполняются операторы _DDL_, а потом выполняются операторы _DML_.

### 8.3.1 DDL

> [[_оглавление_]](../README.md/#83-sql)

_DDL_-операторы используются для создания, изменения и удаления объектов базы данных, включая таблицы, представления,
индексы и хранимые процедуры.

_DDL_ - это набор команд _SQL_ для определения схемы базы данных.

Наиболее распространённые _DDL_-операторы:

* **CREATE** - оператор создаёт новый объект базы данных, такой как таблица, представление или индекс;

Пример (создание таблицы "customers"):

```sql
CREATE TABLE customers
(
    id      INT PRIMARY KEY,
    name    VARCHAR(255),
    address VARCHAR(255)
);
```

* **ALTER** - оператор используется для изменения существующего объекта базы данных;

Пример (добавление нового столбца "email" в таблицу "customers"):

```sql
ALTER TABLE customers
    ADD email VARCHAR(255);
```

* **DROP** - оператор используется для удаления существующего объекта базы данных;

Пример (удаление таблицы "customers"):

```sql
DROP TABLE customers;
```

* **TRUNCATE** - оператор используется для удаления всех строк в таблице, но в отличие от оператора _DROP_ он сохраняет
  структуру таблицы и индексы;

Пример (очистка таблицы "customers"):

```sql
TRUNCATE TABLE customers;
```

* **RENAME** - оператор используется для переименования существующего объекта базы данных.

Пример (переименование таблицы "customers" в "clients"):

```sql
ALTER TABLE customers
    RENAME TO clients;
```

_DDL_-операторы выполняются немедленно и являются постоянными, то есть после создания, изменения или удаления объекта
изменения невозможно отменить.

#### 8.3.1.1 Связи между таблицами базы данных

> [[_оглавление_]](../README.md/#83-sql)

Связи между таблицами базы данных создаются с помощью внешних ключей (_foreign key_).
[**Внешний ключ**](/conspect/definitions.md/#в) - это атрибут или набор атрибутов, которые ссылаются на первичный ключ
(_primary key_) или уникальное поле (_unique_) другой таблицы.  
Другими словами, это что-то вроде указателя на строку другой таблицы.

Виды связей таблиц:

- многие ко многим;
- один ко многим:
    * с обязательной связью;
    * с необязательной связью;
- один к одному:
    * с обязательной связью;
    * с необязательной связью.

Понятия обязательной и необязательной связей означает обязательность наличия (существования) привязанных строк в
связанной таблице как условия для наличия (существования) строк в текущей таблице.

##### 8.3.1.1.1 Многие ко многим

> [[_оглавление_]](../README.md/#83-sql)

При этом типе связей одна строка из таблицы `А` может быть связана со множеством строк из таблицы `В`. В свою очередь
одна строка из таблицы `В` может быть связана со множеством строк из таблицы `А`.

Типичные примеры:

- студенты и курсы: один студент может посещать несколько курсов, и соответственно на один курс могут записаться
  несколько студентов;
- статьи и теги: для одной статьи можно определить несколько тегов, а один тег может быть определен для нескольких
  статей.

На уровне базы данных, как правило, установить прямую связь многие ко многим между двумя таблицами невозможно. Это
делается посредством вспомогательной промежуточной таблицы. Иногда данные из этой промежуточной таблицы представляют
отдельную сущность.

То есть технически связь _многие-ко-многим_ осуществляется за счёт использования двух и более связей _один-ко-многим_.

![40.png](/pictures/40.png)

##### 8.3.1.1.2 Один ко многим

> [[_оглавление_]](../README.md/#83-sql)

В этом типе связей несколько строк из дочерней таблицы зависят от одной строки в родительской таблице.

Типичные примеры:

- один блог - много статей;
- в футбольной команде может играть несколько футболистов, а футболист может играть только в одной команде.

![41.png](/pictures/41.png)

##### 8.3.1.1.3 Один к одному

> [[_оглавление_]](../README.md/#83-sql)

В этом типе связей объекту одной сущности можно сопоставить только один объект другой сущности.

Типичные примеры:

- одному гражданину соответствует только один паспорт;
- в одной стране может быть только одна конституция.

![42.png](/pictures/42.png)

#### 8.3.1.2 Оператор ALTER TABLE

> [[_оглавление_]](../README.md/#83-sql)

Общая структура запроса _ALTER TABLE_ выглядит следующим образом:

* **ALTER TABLE** `[наименования таблицы]`;
* **ADD COLUMN** `[наименование столбца]` `[тип данных]` `[ограничение]` **DEFAULT** `[значение по умолчанию]` (либо);
* **ALTER COLUMN** `[наименование столбца]`:
    * **ADD** `[определение ограничения]` (`[наименование столбца]`) (либо);
    * **DROP** `[название ограничения]` (либо);
    * **SET** `[новое значение типа/ограничения]` (либо);
* **ADD CONSTRAINT** `[наименование ограничения]` **CHECK** `[ограничение]` (либо);
* **DROP CONSTRAINT** `[название ограничения]` (либо);
* **RENAME COLUMN** `[наименование столбца]` **TO** `[новое наименование столбца]` (либо);
* **DROP COLUMN** `[наименование столбца]` (либо);

###### ALTER TABLE

_ALTER TABLE_ - это обязательный элемент запроса, который определяет, в какой таблице необходимо произвести изменения.

###### ADD COLUMN

_ADD COLUMN_ - это необязательный элемент запроса, определяющий наименование нового столбца таблицы, тип данных, которые
он содержит, ограничения, которые накладываются на вносимые в него значения, и другие атрибуты столбца.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-6)

###### ALTER COLUMN

_ALTER COLUMN_ - это необязательный элемент запроса, определяющий новое наименование для старого столбца таблицы, его
тип данных, новые ограничения, которые накладываются на вносимые в него значения, и другие атрибуты столбца.

После ключевого слова _ALTER COLUMN_ могут использоваться следующие операторы:

- **ADD** - оператор "ДОБАВИТЬ" - позволяет задать дополнительное ограничение для значений данного столбца (ограничение
  для каждого столбца таблицы может быть только одно: чтобы добавить новое ограничение, сначала надо удалить старое);
- **DROP** - оператор "СБРОСИТЬ" - позволяет удалить ограничение с указанным названием;
- **SET** - оператор "ПЕРЕКЛЮЧИТЬ" - позволяет изменить тип значений столбца или ограничение значений, если они
  установлены:
    - **DEFAULT** - оператор "ПО УМОЛЧАНИЮ" - позволяет задать значение по умолчанию для значений данного столбца, если
      они отсутствуют при вводе;
    - **DATA TYPE** - оператор "ТИП ДАННЫХ" - позволяет задать новый тип данных для данного столбца.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-6)

###### ADD CONSTRAINT

_ADD CONSTRAINT_ - это необязательный элемент запроса, определяющий наименование и содержание нового ограничения для
существующего столбца таблицы.

После ключевого слова _ADD CONSTRAINT_ могут использоваться следующие операторы:

- **CHECK** - оператор "ПРОВЕРЯТЬ" - позволяет задать дополнительную проверку для значений данного столбца.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-6)

###### DROP CONSTRAINT

_DROP CONSTRAINT_ - это необязательный элемент запроса, определяющий наименование удаляемого ограничения таблицы.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-6)

###### DROP CONSTRAINT

_RENAME COLUMN_ - это необязательный элемент запроса, определяющий новое наименование для указанного столбца таблицы.

После ключевого слова _RENAME COLUMN_ должны использоваться следующие операторы:

- **TO** - оператор "В" - позволяет задать новое название столбца.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-6)

###### DROP COLUMN

_DROP COLUMN_ - это необязательный элемент запроса, определяющий удаляемый столбец таблицы.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-6)

### 8.3.2 DML

> [[_оглавление_]](../README.md/#83-sql)

_DML_-операторы используются для вставки, обновления и удаления данных в базе данных.

_DML_ - это набор команд _SQL_, используемых для манипулирования данными в пределах схемы, созданной _DDL_.

Наиболее распространённые _DML_-операторы:

* **SELECT** - оператор используется для получения данных из одной или нескольких таблиц базы данных;

Пример (получение всех записей из таблицы "customers"):

```sql
SELECT *
FROM customers;
```

* **INSERT** - оператор используется для вставки новых данных в таблицу;

Пример (вставка новой строки в таблицу "customers"):

```sql
INSERT INTO customers (id, name, address)
VALUES (1, 'John Smith', '123 Main St');
```

* **UPDATE** - оператор используется для изменения существующих данных в таблице;

Пример (обновление адреса клиента с идентификатором 1 в таблице "customers"):

```sql
UPDATE customers
SET address = '456 Park Ave'
WHERE id = 1;
```

* **DELETE** - оператор используется для удаления данных из таблицы.

Пример (удаление клиента с идентификатором 1 из таблицы "customers"):

```sql
DELETE
FROM customers
WHERE id = 1;
```

#### 8.3.2.1 SELECT-запросы

> [[_оглавление_]](../README.md/#83-sql)

Общая структура _SELECT_-запроса выглядит следующим образом:

* **SELECT** `[наименования столбцов или для выбора всех столбцов]`;
* **FROM** `[наименование таблицы]`;
* **WHERE** `[условие/фильтрация по данным в ячейках]` (необязательно);
* **GROUP BY** `[столбец, по которому хотим сгруппировать данные]` (необязательно);
* **HAVING** `[условие/фильтрация по полученным сгруппированным данным]` (необязательно);
* **ORDER BY** `[столбец, по которому хотим отсортировать вывод по возрастанию/убыванию]` (необязательно).

Пример:

```sql
SELECT author, year, COUNT(author)
FROM book
WHERE reader_id IS NOT NULL
GROUP BY author, year
HAVING COUNT(author) < 2
ORDER BY year DESC;
```

###### SELECT, FROM

_SELECT_, _FROM_ - это обязательные элементы запроса, которые определяют выбранные столбцы, их порядок и источник
данных.

После ключевого слова _SELECT_ могут использоваться следующие операторы:

- **AS** - оператор "ИМЕНОВАТЬ КАК" - позволяет задать краткий псевдоним для результата выполнения агрегатной функции.

После ключевого слова _FROM_ могут использоваться следующие операторы:

- **AS** - оператор "ИМЕНОВАТЬ КАК" - позволяет задать краткий псевдоним для таблицы;
- **LIMIT** - оператор "ЛИМИТ" - позволяет ограничивать количество выводимых строк таблицы;
- **OFFSET** - оператор "СДВИГ" - позволяет смещать количество выводимых строк таблицы на указанную величину.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-1)

###### WHERE

_WHERE_ - это необязательный элемент запроса, который используется, когда необходимо отфильтровать данные по нужному
условию.

После ключевого слова _WHERE_ могут использоваться следующие операторы:

- **<** - оператор "МЕНЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **=** - оператор "РАВНО" - позволяет сравнивать числовые значения с указанным значением;
- **>** - оператор "БОБЛЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **AND** - оператор "И" - позволяет объединять несколько условий;
- **IN ()** - оператор "В ДИАПАЗОНЕ" - позволяет сравнивать значения с указанными в круглых скобках (`( )`);
- **IS** - оператор "ЕСТЬ" - позволяет сравнивать значения с указанным значением;
- **LIKE** - оператор "ПОХОЖ НА" - позволяет сравнивать содержание строчных значений с указанным значением:
    * `%` - символ "СОДЕРЖАНИЕ ДО/ПОСЛЕ" - позволяет не учитывать предшествующие или последующие символы;
- **NULL** - оператор "НУЛЬ" - позволяет сравнивать значения с нулём, применяется после операторов _IS_, _NOT_;
- **NOT** - оператор "НЕ" - позволяет задать отрицание условия;
- **OR** - оператор "ИЛИ" - позволяет объединять несколько условий.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-2)

###### GROUP BY

_GROUP BY_ является необязательным элементом запроса, с помощью которого можно задать группировку вывода результатов
выполнения агрегатной функции и запроса в целом по вариантам значений одного или нескольких нужных столбцов.

Для использования _GROUP BY_ необходимо учесть следующие правила:

* перечень столбцов, по которым делается разрез, должен быть одинаковым внутри блока _SELECT_ и внутри блока _GROUP BY_;
* агрегатные функции (_SUM_, _AVG_, _COUNT_, _MAX_, _MIN_) должны быть также указаны внутри _SELECT_ с указанием
  столбца, к которому такая функция применяется.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-3)

###### HAVING

_HAVING_ - это необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных.

Ключевое слово _HAVING_ применяется для фильтрации выводимых данных, сгруппированных посредством _GROUP BY_.

То есть _WHERE_ накладывает условие на значения в ячейках таблицы, а _HAVING_ накладывает условие на результаты,
полученные посредством применения _GROUP BY_.

После ключевого слова _HAVING_ могут использоваться следующие операторы:

- **<** - оператор "МЕНЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **=** - оператор "РАВНО" - позволяет сравнивать числовые значения с указанным значением;
- **>** - оператор "БОБЛЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **AND** - оператор "И" - позволяет объединять несколько условий;
- **IN ()** - оператор "В ДИАПАЗОНЕ" - позволяет сравнивать значения с указанными в круглых скобках (`( )`);
- **IS** - оператор "ЕСТЬ" - позволяет сравнивать значения с указанным значением;
- **LIKE** - оператор "ПОХОЖ НА" - позволяет сравнивать содержание строчных значений с указанным значением:
    * `%` - символ "СОДЕРЖАНИЕ ДО/ПОСЛЕ" - позволяет не учитывать предшествующие или последующие символы;
- **NULL** - оператор "НУЛЬ" - позволяет сравнивать значения с нулём, применяется после операторов _IS_, _NOT_;
- **NOT** - оператор "НЕ" - позволяет задать отрицание условия;
- **OR** - оператор "ИЛИ" - позволяет объединять несколько условий.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-4)

###### ORDER BY

_ORDER BY_ - это необязательный элемент запроса, который отвечает за сортировку таблицы в порядке возрастания или
убывания значений по одному или нескольким столбцам.

После ключевого слова _ORDER BY_ могут использоваться следующие операторы:

- **DESC** - оператор "НАОБОРОТ" - позволяет задать обратный порядок сортировки;
- **ASC** - оператор "ПРЯМО" - позволяет задать прямой порядок сортировки по возрастанию значений.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-5)

> _GROUP BY_ в _SQL_ применяется для объединения строк с одинаковыми значениями в определённых колонках в единую строку,
> в то время как _ORDER BY_ служит для установки порядка представления результатов запроса, базируясь на сортировке в
> заданных столбцах.

#### 8.3.2.2 Агрегатные функции

> [[_оглавление_]](../README.md/#83-sql)

[**Агрегатная функция**](/conspect/definitions.md/#а) - это функция, которая выполняет вычисление на наборе значений
_SQL_-таблиц баз данных и возвращает одиночное значение.

Описание агрегатных функций:

|         **Функция**         |           **Описание**           |
|:---------------------------:|:--------------------------------:|
|  **AVG**(`[поле таблицы]`)  |   возвращает среднее значение    |
| **COUNT**(`[поле таблицы]`) |  возвращает количество записей   |
|  **MIN**(`[поле таблицы]`)  | возвращает минимальное значение  |
|  **MAX**(`[поле таблицы]`)  | возвращает максимальное значение |
|  **SUM**(`[поле таблицы]`)  |    возвращает сумму значений     |

Агрегатная функция выполняет вычисление над набором значений и возвращает одно значение. В табличной модели данных это
значит, что функция берет ноль, одну или несколько строк для какой-то колонки и возвращает единственное значение.

Свойства агрегатных функций:

- игнорируют значения `null`, за исключением функции `COUNT(*)`;
- все агрегатные функции детерминированы - для одинакового набора данных функции возвращают одинаковое значение.

Агрегатные функции часто используются с операторами _GROUP BY_ и _HAVING_. Оператор _GROUP BY_ группирует строки с
одинаковыми значениями в одну строку. Оператор _HAVING_ используется в качестве фильтра для запросов, в которых есть
оператор _GROUP BY_.

С агрегатными функциями используются операторы:

- **DISTINCT** - оператор "БЕЗ ДУБЛИКАТОВ" - позволяет исключить дубликаты при выполнении агрегатных функций;
- **ALL** - оператор "ВСЕ" - применяется по умолчанию; позволяет учитывать абсолютно все имеющиеся записи при выполнении
  агрегатных функций.

> [[_Примеры использования_]](/conspect/example_6.md/#пример-1)

_COUNT()_ считает количество строк в таблице. Она может принимать в качестве параметров как числовые, так и нечисловые
типы данных.  
`COUNT(*)` - это специальная форма функции _COUNT()_, которая возвращает количество всех строк в указанной таблице (при
этом она учитывает дубликаты и _NULL_).

_SUM()_ вычисляет суммы всех выбранных столбцов. Она работает только с числовыми полями.

_MAX()_ и _MIN()_ нужны для нахождения максимального и минимального значения для определенного столбца.

_AVG()_ используется для вычисления среднего значения заданного столбца.  
`AVG()` игнорирует значения `null` в таблице и проводит расчёт на основании ненулевых значений.

### 8.3.3 Типы данных в SQL

> [[_оглавление_]](../README.md/#83-sql)

Основными типами данных в _SQL_ являются:

* числовые типы;
* символьные типы;
* логический тип;
* типы даты и времени.

Другие типы данных используются реже.

> [[Ссылка]](https://postgrespro.ru/docs/postgrespro/16/datatype) на описание типов данных для СУБД PostgreSQL.
> [[Ссылка]](https://phpclub.ru/mysql/doc/column-types.html) на описание типов данных для СУБД MySQL.

У каждой СУБД есть свои собственные типы данных в добавок к основным.

#### 8.3.3.1 Числовые типы

> [[_оглавление_]](../README.md/#83-sql)

Числовые типы данных в _SQL_ подразделяются на три группы:

* целые типы;
* типы с фиксированной точностью;
* типы с плавающей точкой (вещественные);
* последовательные типы (значение образуется путём автоматического инкремента значения предыдущей строки).

###### Целые типы

|   ***Название типа***    | ***Количество байт*** | ***Аналог из Java*** |        ***Минимум***        |      ***Максимум***       |
|:------------------------:|:---------------------:|:--------------------:|:---------------------------:|:-------------------------:|
|   **SMALLINT / INT2**    |           2           |        short         |          - 32 768           |          32 767           |
| **INTEGER / INT / INT4** |           4           |         int          |       - 2 147 483 648       |       2 147 483 647       |
|    **BIGINT / INT8**     |           8           |         long         | - 9 223 372 036 854 775 808 | 9 223 372 036 854 775 807 |

###### Типы с фиксированной точностью

| ***Название типа*** | ***Количество байт*** | ***Аналог из Java*** |      ***Диапазон значений до и после запятой***       |                         ***Примечание***                         |
|:-------------------:|:---------------------:|:--------------------:|:-----------------------------------------------------:|:----------------------------------------------------------------:|
|  **DECIMAL**(x, y)  |      переменное       |        double        | до 131072 цифр до десятичной точки и до 16383 - после | x - общее количество цифр,<br/>y - количество цифр после запятой |
|  **NUMERIC**(x, y)  |      переменное       |        double        | до 131072 цифр до десятичной точки и до 16383 - после | x - общее количество цифр,<br/>y - количество цифр после запятой |

###### Типы с плавающей точкой

|      ***Название типа***      | ***Количество байт*** | ***Аналог из Java*** |        ***Точность***         | 
|:-----------------------------:|:---------------------:|:--------------------:|:-----------------------------:|
|       **REAL / FLOAT4**       |           4           |        double        | в пределах 6 десятичных цифр  |
| **DOUBLE PRECISION / FLOAT8** |           8           |        double        | в пределах 15 десятичных цифр |

###### Последовательные типы

| ***Название типа*** | ***Количество байт*** | ***Аналог из Java*** | ***Минимум*** |      ***Максимум***       |
|:-------------------:|:---------------------:|:--------------------:|:-------------:|:-------------------------:|
|   **SMALLSERIAL**   |           2           |        short         |       1       |          32 767           |
|     **SERIAL**      |           4           |         int          |       1       |       2 147 483 647       |
|    **BIGSERIAL**    |           8           |         long         |       1       | 9 223 372 036 854 775 807 |

#### 8.3.3.2 Символьные типы

> [[_оглавление_]](../README.md/#83-sql)

|             ***Название типа***              | ***Количество байт*** | ***Аналог из Java*** |                       ***Описание***                        |           ***Примечание***           |
|:--------------------------------------------:|:---------------------:|:--------------------:|:-----------------------------------------------------------:|:------------------------------------:|
|   **CHARACTER VARYING**(n), **VARCHAR**(n)   |      переменное       |        String        |            строка ограниченной переменной длины             | n - максимальное количество символов |
| **CHARACTER**(n), **CHAR**(n), **BPCHAR**(n) |      переменное       |        String        |      строка фиксированной длины, дополненная пробелами      | n - максимальное количество символов |
|                  **BPCHAR**                  |      переменное       |        String        | строка неограниченной переменной длины с удалением пробелов |                                      |
|                   **TEXT**                   |      переменное       |        String        |           строка неограниченной переменной длины            |                                      |

#### 8.3.3.3 Логический тип

> [[_оглавление_]](../README.md/#83-sql)

| ***Название типа*** | ***Количество байт*** | ***Аналог из Java*** | ***Диапазон значений*** |
|:-------------------:|:---------------------:|:--------------------:|:-----------------------:|
|     **BOOLEAN**     |           1           |       boolean        | `true`, `false`, `null` |

Функция ввода данных типа **BOOLEAN** воспринимает следующие строковые представления состояния `true`:

* `true`;
* `yes`;
* `on`;
* `1`.

Функция ввода данных типа **BOOLEAN** воспринимает следующие строковые представления состояния `false`:

* `false`;
* `no`;
* `off`;
* `0`.

#### 8.3.3.4 Типы даты и времени

> [[_оглавление_]](../README.md/#83-sql)

|     ***Название типа***      | ***Количество байт*** |         ***Аналог из Java***          |             ***Описание***             | ***Точность*** |
|:----------------------------:|:---------------------:|:-------------------------------------:|:--------------------------------------:|:--------------:|
|        **TIMESTAMP**         |           8           | java.sql.Timestamp,<br/>LocalDateTime |   дата и время (без часового пояса)    | 1 микросекунда |
| **TIMESTAMP WITH TIME ZONE** |           8           | java.sql.Timestamp,<br/>LocalDateTime |    дата и время (с часовым поясом)     | 1 микросекунда |
|           **DATE**           |           4           |             java.sql.Date             |        дата (без времени суток)        |     1 день     |
|           **TIME**           |           8           |             java.sql.Time             |         время суток (без даты)         | 1 микросекунда |
|   **TIME WITH TIME ZONE**    |          12           |   LocalDateTime,<br/>ZonedDateTime    | время дня (без даты), с часовым поясом | 1 микросекунда |
|         **INTERVAL**         |          16           |                Integer                |           временной интервал           | 1 микросекунда |

### 8.3.4 Ограничения значений колонок таблицы

> [[_оглавление_]](../README.md/#83-sql)

Для введения дополнительных проверок значений столбцов таблицы _SQL_ предоставляет механизм ограничений значений в
колонках таблиц, который позволяет задавать произвольные ограничения.  
При попытке вставки данных в таблицу, нарушающих условия этих ограничений, возникнет ошибка, и данные не сохранятся,
оставив таким образом правильность (или, как ещё говорят, консистентность) данных.

[**Консистентность**](/conspect/definitions.md/#к) - это соответствие имеющейся в базе данных информации её внутренней
логике, структуре и всем явно заданным правилам.

Ограничения определяются (указываются) после типа данных столбца таблицы.

Основными видами ограничений являются:

- ограничения проверки - реализуются за счёт оператора **CHECK**;

```sql
CREATE TABLE users
(
    age INTEGER CHECK (age > 0)
);

ALTER TABLE users
    ADD CONSTRAINT age_constraint CHECK (age > 0);
```

- ограничения на _NULL_-значения - реализуются за счёт операторов **NOT NULL** и **NULL**;

```sql
CREATE TABLE users
(
    name TEXT NOT NULL
);

ALTER TABLE users
    ALTER COLUMN name SET NOT NULL;
```

- ограничения на уникальность значения - реализуются за счёт оператора **UNIQUE**;

```sql
CREATE TABLE users
(
    nickname TEXT UNIQUE
);

ALTER TABLE users
    ADD CONSTRAINT nickname_unique UNIQUE (nickname);

ALTER TABLE users
    ADD CONSTRAINT login_pass_unique UNIQUE (login, password);
```

- значения по умолчанию - реализуются за счёт оператора **DEFAULT**;

```sql
CREATE TABLE users
(
    profile_picture_url TEXT DEFAULT 'https://default_picture_url'
);

ALTER TABLE users
    ALTER COLUMN salary SET DEFAULT 0.00;
```

- первичные и внешние ключи - реализуются за счёт оператора **PRIMARY KEY** или сочетания операторов **UNIQUE NOT NULL**
  в родительской таблице и операторов **FOREIGN KEY** и **REFERENCES** (ссылка на первичный ключ другой таблицы) в
  другой таблице.

```sql
CREATE TABLE users
(
    login TEXT UNIQUE NOT NULL
);

CREATE TABLE users
(
    login TEXT PRIMARY KEY
);

CREATE TABLE users
(
    login TEXT,
    PRIMARY KEY (login)
);

ALTER TABLE users
    ADD PRIMARY KEY (login);

CREATE TABLE users
(
    id            REAL,
    name          TEXT PRIMARY KEY,
    department_id TEXT REFERENCES departments (id)
);

CREATE TABLE Students
(
    ID INT NOT NULL Name VARCHAR(255)
   LibraryID INT
   PRIMARY KEY (ID)
   FOREIGN KEY (Library_ID) REFERENCES Library(LibraryID)
);

CREATE TABLE Students
(
    ID INT NOT NULL PRIMARY KEY Name VARCHAR(255)
  LibraryID INT FOREIGN KEY (Library_ID) REFERENCES Library(LibraryID)
);

ALTER TABLE Students
    ADD FOREIGN KEY (LibraryID)
        REFERENCES Library (LibraryID);
```

[**Первичный ключ**](/conspect/definitions.md/#п) - это поле, которое используется для обеспечения уникальности данных в
таблице.

[**Внешний ключ**](/conspect/definitions.md/#в) - это поле, которое используется для обеспечения консистентности данных
в БД и значения в котором соответствуют значениям первичных ключей из другой таблицы.

Внешние ключи задаются при помощи оператора **FOREIGN KEY**, а соответствующие первичные ключи других таблиц - при
помощи оператора **REFERENCES**.

В реляционных базах данных практически всегда разные таблицы логически связаны друг с другом. Первичные ключи как раз
используются для однозначной организации такой связи.

### 8.3.5 Нормализация таблиц баз данных

> [[_оглавление_]](../README.md/#83-sql)

[**Атрибут таблицы БД**](/conspect/definitions.md/#а) - это свойство некоторой сущности (часто называется полем
таблицы).

[**Домен атрибута таблицы БД**](/conspect/definitions.md/#д) - это множество допустимых значений, которые может
принимать атрибут.

[**Кортеж таблицы БД**](/conspect/definitions.md/#к) - это конечное множество взаимосвязанных допустимых
значений [атрибутов таблицы БД](/conspect/definitions.md/#а), которые вместе описывают некоторую сущность (строка
таблицы).

[**Отношение таблицы БД**](/conspect/definitions.md/#о) - это конечное
множество [кортежей таблицы БД](/conspect/definitions.md/#к) (таблица).

[**Схема отношения таблицы БД**](/conspect/definitions.md/#с) - это конечное множество атрибутов, определяющих некоторую
сущность (структура таблицы, состоящей из конкретного набора полей).

[**Проекция таблицы БД**](/conspect/definitions.md/#п) - это отношение, полученное из заданного путём удаления и (или)
перестановки некоторых [атрибутов таблицы БД](/conspect/definitions.md/#а).

Функциональная зависимость между атрибутами (множествами атрибутов) _X_ и _Y_ означает, что для любого допустимого
набора кортежей в данном отношении: если два кортежа совпадают по значению _X_, то они совпадают по значению _Y_.
Например, если значение атрибута «Название компании» — _Canonical Ltd_, то значением атрибута «Штаб-квартира» в таком
кортеже всегда будет _Millbank Tower, London, United Kingdom_. Обозначение: `{X} -> {Y}`.

[**Метод нормальных форм**](/conspect/definitions.md/#м) состоит в сборе информации об объектах решения задачи в рамках
одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур
нормализации отношений.

Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, возникших при
добавлении, редактировании и удалении кортежей(строк таблицы).

[**Аномалия таблицы БД**](/conspect/definitions.md/#а) - это ситуация в таблице БД, которая приводит к противоречию в БД
либо существенно усложняет обработку БД.  
Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от не
ключевых атрибутов.

Аномалии-модификации проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы и соответствующее
изменение некоторых записей таблицы.

Аномалии-удаления — при удалении какого либо кортежа из таблицы может пропасть информация, которая не связана на прямую
с удаляемой записью.

Аномалии-добавления возникают, когда информацию в таблицу нельзя поместить, пока она не полная, либо вставка записи
требует дополнительного просмотра таблицы.

[**Нормальная форма**](/conspect/definitions.md/#н) - это требование, предъявляемое к структуре таблиц в теории
реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

Процесс проектирования БД с использованием метода нормальных форм является итерационным и заключается в последовательном
переводе отношения из первой нормальной формы в нормальные формы более высокого порядка по определённым правилам. Каждая
следующая нормальная форма ограничивается определённым типом функциональных зависимостей и устранением соответствующих
аномалий при выполнении операций над отношениями БД, а также сохранении свойств, предшествующих нормальных форм.  
То есть, каждая последующая нормальная форма содержит в себе требования предыдущей.

Нормальные формы:

- первая нормальная форма - **1НФ** - соблюдение реляционных принципов:
    * все столбцы таблицы являются простыми;
    * все значения в ячейках таблицы являются скалярными значениями (в одной ячейке только одно значение);
    * не должно быть повторений строк в таблице;
- вторая нормальная форма - **2НФ** - выделение первичных ключей:
    * таблица находится в 1НФ;
    * значения в каждом из столбцов таблицы зависят только от первичного ключа (все не ключевые поля, содержимое которых
      может относиться к нескольким записям таблицы, выносятся в отдельные таблицы);
- третья нормальная форма - **3НФ** - выделение зависимостей между значениями неключевых столбцов:
    * таблица находится во 2НФ;
    * в таблице отсутствует транзитивная зависимость;

> [**Транзитивная зависимость таблицы БД**](/conspect/definitions.md/#т) - это состояние таблицы БД, при котором
> неключевые столбцы зависят от значений других неключевых столбцов.

- нормальная форма Бойса-Кодда - **НФБК** - выделение зависимостей составных первичных ключей:
    * таблица находится в 3НФ;
    * часть составного первичного ключа не должна зависеть от неключевого столбца;
- четвёртая нормальная форма - **4НФ** - выделение и уточнение зависимостей между первичными ключами и неключевыми
  столбцами:
    * таблица находится в НФБК;
    * в таблице отсутствует многозначная зависимость;

> [**Многозначная зависимость таблицы БД**](/conspect/definitions.md/#м) - это состояние таблицы БД, при котором для
> каждого значения одного столбца таблицы существует хорошо определённое множество соответствующих значений другого
> одного
> столбца таблицы.

- пятая нормальная форма - **5НФ** - декомпозиция без потерь (разбиение таблицы не на 2, а на 3 новые таблицы во
  избежание потерь данных):
    * таблица находится в 4НФ;
    * в таблице каждая нетривиальная зависимость соединения определяется потенциальным ключом этой таблицы;

> [**Декомпозиция без потерь**](/conspect/definitions.md/#д) - это процесс разбиения одной таблицы на несколько, при
> условии, что в случае соединения таблиц, которые были получены в результате декомпозиции, будет формироваться ровно та
> же самая информация, что и в исходной таблице до декомпозиции.

- доменно-ключевая нормальная форма - **ДКНФ** - ограничение доменов и первичных ключей:
    * таблица находится в 5НФ;
    * выполнено ограничение домена (ограничение, предписывающее использование для определенного атрибута (столбца)
      значений только из некоторого заданного домена (набора значений));
    * выполнено ограничение ключей (ограничение, утверждающее, что некоторый атрибут (столбец) или комбинация
      атрибутов (столбцов) представляет собой потенциальный ключ);
- шестая нормальная форма - **6НФ** - нормальная форма хронологических БД:
    * таблица находится в 5НФ;
    * таблица должна удовлетворять всем нетривиальным зависимостям соединения.

> [**Хронологическая база данных**](/conspect/definitions.md/#х) – это база, которая может хранить не только текущие
> данные, но и исторические данные, то есть данные, относящиеся к прошлым периодам времени.

### 8.3.6 Оператор JOIN

> [[_оглавление_]](../README.md/#83-sql)

Оператор **JOIN** - оператор для объединения данных из нескольких таблиц с общим ключом.

Оператор **JOIN** используют, чтобы объединять строки из двух или более таблиц на основе связующего столбца между ними
(ключа).

Общая структура _JOIN_-запроса выглядит следующим образом:

- **SELECT** `[таблица 1].[столбец 1]`, `[таблица 1].[столбец 2]` ..., `[таблица 2].[столбец 3]`;
- **FROM** `[таблица 1]`;
- **INNER JOIN** `[таблица 2]` (необязательно):
    * **ON** `[таблица 1].[внешний ключ]` = `[таблица 2].[первичный ключ]`;
- **LEFT JOIN** `[таблица 2]` (необязательно):
    * **ON** `[таблица 1].[внешний ключ]` = `[таблица 2].[первичный ключ]`;
- **RIGHT JOIN** `[таблица 2]` (необязательно):
    * **ON** `[таблица 1].[внешний ключ]` = `[таблица 2].[первичный ключ]`;
- **FULL JOIN** `[таблица 2]` (необязательно):
    * **ON** `[таблица 1].[внешний ключ]` = `[таблица 2].[первичный ключ]`.

###### INNER JOIN

_INNER JOIN_ - это необязательный элемент запроса, определяющий таблицу, из которой нужно вывести данные.

_INNER JOIN_ необходим для получения только тех строк, для которых существует соответствие записей главной таблицы и
присоединяемой.

После ключевого слова _INNER JOIN_ должны использоваться следующие операторы:

- **ON** - оператор "НА УСЛОВИИ" - позволяет задать условие объединения данных таблиц.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-7)

###### LEFT JOIN

_LEFT JOIN_ - это необязательный элемент запроса, определяющий таблицу, из которой нужно вывести данные.

_LEFT JOIN_ необходим для получения всех строк из главной таблицы, даже если в присоединяемой таблице нет совпадений, то
есть условие не учитывает присоединяемую (правую) таблицу.

После ключевого слова _LEFT JOIN_ должны использоваться следующие операторы:

- **ON** - оператор "НА УСЛОВИИ" - позволяет задать условие объединения данных таблиц.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-7)

###### RIGHT JOIN

_RIGHT JOIN_ - это необязательный элемент запроса, определяющий таблицу, из которой нужно вывести данные.

_RIGHT JOIN_ необходим для получения всех строк из присоединяемой таблицы, даже если в главной таблице нет совпадений,
то есть условие не учитывает главную (левую) таблицу.

После ключевого слова _RIGHT JOIN_ должны использоваться следующие операторы:

- **ON** - оператор "НА УСЛОВИИ" - позволяет задать условие объединения данных таблиц.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-7)

###### FULL JOIN

_FULL JOIN_ - это необязательный элемент запроса, определяющий таблицу, из которой нужно вывести данные.

_FULL JOIN_ необходим для получения всех строк как из главной, так и из присоединяемой таблиц, даже если в них нет
совпадений.

После ключевого слова _FULL JOIN_ должны использоваться следующие операторы:

- **ON** - оператор "НА УСЛОВИИ" - позволяет задать условие объединения данных таблиц.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-7)

### 8.3.7 Индексы

> [[_оглавление_]](../README.md/#83-sql)

Индекс в базах данных - это набор дополнительных данных, записанных в удобном виде, который позволяет заметно быстрее
осуществлять поиск, хоть и требует дополнительных усилий для поддерживания его актуальности.

[**Индекс в БД**](/conspect/definitions.md/#и) - это специальный объект базы данных, который создаётся, чтобы повысить
производительность поиска данных.

Свойства индексов:

- значения в индексе всегда отсортированы по возрастанию;
- при увеличении индекса производительность поиска улучшается, но производительность модификации снижается, а при
  уменьшении индекса производительность модификации улучшается, а производительность поиска снижается;
- добавлять и удалять индексы можно в любое время, но это происходит не мгновенно: БД требуется время для того, чтобы
  построить индекс, в случае большой таблицы это может занять изрядное его количество;
- индексы можно создавать не только по одному, но и по нескольким колонкам таблицы.

Преимущества индексов:

- созданный уникальный индекс гарантирует уникальность каждой строки данных в таблице базы данных;
- значительно увеличивает скорость извлечения данных: избегает сканирование данных всей таблицы и значительно уменьшает
  количество просматриваемых совпадающих строк;
- использование предложений группировки и сортировки для извлечения данных также может значительно сократить время на
  группировку и сортировку в запросах.

Недостатки индексов:

- создание и поддержание индексов требует времени, и это время увеличивается по мере увеличения объёма данных;
- индекс должен занимать физическое пространство;
- при добавлении, удалении и изменении данных в таблице индекс также динамически поддерживается, что снижает скорость
  обслуживания данных.

Индексы стоит использовать для столбцов:

- по значениям которых можно ускорить поиск;
- для внешних ключей;
- поиск по значениям в которых производится на основе диапазона;
- значения в которых часто необходимо сортировать.

Индексы не стоит использовать для столбцов:

- которые редко используются (приводит к увеличению времени обслуживания и объёма занимаемой индексом памяти);
- с небольшим количеством хранимых данных (приводит только к увеличению занимаемой памяти);
- типы данных которых **TEXT**, **IMAGE** и **BIT** (хранят в себе либо слишком большой, либо слишком маленький объём
  данных);
- когда производительность модификации намного превышает производительность поиска.

Синтаксис _SQL_-запроса на создание индекса выглядит следующим образом:

```sql
CREATE INDEX index_name
    ON table_name (column_name);

CREATE INDEX index_name
    ON table_name (column_name_1, column_name_2);

CREATE INDEX index_name
    ON table_name
        USING GIST (column_name);
```

Синтаксис _SQL_-запроса на удаление индекса выглядит следующим образом:

```sql
DROP INDEX index_name;
```

В зависимости от типа индексируемых данных могут быть применены разные типы индексов. В _SQL_-запросе для задания типа
индекса используется оператор **USING**.

Типы индексов:

- _B-дерево_ - принцип поиска основан на использовании бинарного поиска - создаётся по умолчанию; применяется для
  ускорения запросов, условия которых - выражения, состоящие из полей, входящих в индекс, логических операторов и
  операций равенства или сравнения, а также сортировку результатов, задаваемую при помощи оператора **ORDER BY**;
- _GiST_ - позволяет распределить данные любого типа по сбалансированному дереву и использовать это дерево для поиска по
  самым разным условиям (можно реализовать любой принцип разбиения любого множества объектов); применяется для ускорения
  поиска по столбцам, упорядочивание значений по которым не имеет смысла (например, геоданные или геометрические
  объекты);
- _SP-GiST_ - аналогичен _GiST_; позволяет создавать несбалансированные деревья (могут быть полезны при разбиении
  множества на непересекающиеся объекты);
- _HASH_ - являются одностолбцовыми индексами, хранящими 4-байтовые результаты применения алгоритма хэширования к ключу
  индекса; применяются для оптимизации поиска единственной записи;
- _GIN_ - применяется для составных типов данных, доступ к которым осуществляется через ключи (массивов, JSON-объектов,
  векторов);
- _BRIN_ - применяется для индексирования больших таблиц, где столбцы могут коррелировать с их физическим положением в
  таблице.

> При использовании оператора **LIKE** индекс может использоваться для осуществления поиска по началу строки, но не
> может использоваться по её завершению.

### 8.3.8 Liquibase

> [[_оглавление_]](../README.md/#83-sql)

[**Liquibase**](/conspect/definitions.md/#l) - это независимая от базы данных библиотека с открытым исходным кодом для
отслеживания, управления и применения изменений схемы базы данных.

Подключение _Liquibase_ к проекту производится в следующем порядке:

- добавление зависимости в файл:

    * _pom.xml_:

      ```xml
      <dependency>
              <groupId>org.liquibase</groupId>
              <artifactId>liquibase-core</artifactId>
      </dependency>
       ```

    * _build.gradle_:

      ```groovy
      implementation 'org.liquibase:liquibase-core'
      ```
- добавление пути файла _Liquibase_, управляющего изменениями в БД, в _properties_-файл:

  ```properties
  spring.datasource.url=jdbc:postgresql://localhost:[номер_порта]/[название_БД]
  spring.datasource.username=[имя_роли_владельца]
  spring.datasource.password=[пароль]
  
  # Hibernate ddl auto (create, create-drop, validate, update)
  spring.jpa.hibernate.ddl-auto=[настройка_hibernate]
  # Liquibase change-log settings
  spring.liquibase.change-log=classpath:[путь_к_файлу]
  ```

- (рекомендуемый пункт) создание в директории _resources_ директории _liquibase_ (_src/main/resources/liquibase_);
- (рекомендуемый пункт) создание в директории _liquibase_ файла _changelog-master.yml_
  (_src/main/resources/liquibase/changelog-master.yml_);
- указание _Liquibase_ в созданном файле _changelog-master.yml_ _sql_-файла или файлов, в которых хранится содержимое
  изменений в БД:
  ```yaml
  databaseChangeLog:
    - include:
        file: liquibase/[путь_к_файлу]
  ```

- создание директории (при необходимости) и _sql_-файла или файлов для хранения изменений в БД:
  ```sql
  -- liquibase formatted sql -- ключевой комментарий для Liquibase - формат текущего файла
  
  -- changeset jrembo:1      -- ключевой комментарий для Liquibase - изменение в БД
  CREATE TABLE users (       -- запрос SQL
      id SERIAL,
      email TEXT
  );
  ```

_Liquibase_ отслеживает, управляет и применяет миграции.

[**Миграция**](/conspect/definitions.md/#м) - это изменение схемы базы данных и данных, которое возникает во время
разработки.

> [[_Примеры использования_]](/conspect/example_10.md/#пример-1)
