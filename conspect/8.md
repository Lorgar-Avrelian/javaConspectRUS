# 8 Базы данных

> [[_оглавление_]](../README.md/#8-базы-данных)

Одна из основных целей языка программирования - хранение и обработка информации.  
Архитектурно хранение данных делится на слои:

- _Data Tier_ (Слой данных) - это уровень хранения самих данных (например, _SQL_-база данных);
- _Persistence Layer_ - это некоторый уровень абстракции (средств) для работы с данными из хранилища с уровня _Data
  Tier_ (например, шаблон _DAO_, различные _ORM_).

[**База данных**](/conspect/definitions.md/#б) - это совокупность данных, организованных в соответствии с концептуальной
структурой, описывающей характеристики этих данных и взаимоотношения между ними; совокупность множества таблиц, которые
связаны между собой.

Данные в базах данных хранятся в виде таблиц.  
Каждая таблица - это коллекция определённых сущностей.  
У каждой записи сущности в таблице есть уникальный идентификатор.

Наиболее популярной базой данных является [_PostgreSQL_](/conspect/7.md/#73-postgresql).

## 8.1 Data Tier

> [[_оглавление_]](../README.md/#81-data-tier)

Свойства баз данных:

- быстродействие;
- простота получения и обновления данных;
- безопасность (в большинстве БД можно настраивать разные уровни доступа к таблицам);
- многопользовательский доступ;
- объём хранимых данных.

Базы данных по способу хранения данных подразделяются на:

- _централизованные_ - вся информация хранится на одном компьютере;
- _распределённые_ - информация распределена по разным компьютерам.

Типы баз данных:

- _реляционные_ - состоят из множества таблиц, распределённых по смыслу, а между таблицами есть связи;
- _нереляционные_ - базы данных, в которых информация содержится в виде документов _JSON_ и структурированы с
  использованием _JavaScript_;
- _документоориентированные_ - единицей информации является документ, причём без ограничения по формату, а это значит,
  что можно добавлять новые данные как угодно и в каком угодно формате, не требуя, чтобы у всех остальных записей БД
  была одинаковая структура (примеры: _MongoDB_, _Couchbase_, _Firebase_);
- _графовые_ - информация хранится в графах;

> [**Граф**](/conspect/definitions.md/#г) - это математический термин, означающий совокупность двух множеств: множества
> объектов (вершин) и множества парных связей этих объектов (рёбер).  
> Пример графа - это дерево каталогов в компьютере, где диски, папки и файлы - вершины, а вложенность файлов и папок в
> папки и диски - рёбра.

- _колоночные_ (_столбцовые_) - данные записываются не в строки, а в столбцы;
- _key-value_ - информация представляется в виде пары «ключ-значение»;
- _сетевые_ - данные организованы по принципу сети или связанной структуры, то есть у одной записи может быть несколько
  родительских и дочерних записей;
- _иерархические_ - строится по принципу «родитель-ребёнок», где каждый дочерний элемент имеет только один родительский
  элемент (эта модель организует данные в древовидной структуре).

Чтобы получать, добавлять, сохранять нужные данные в базе данных, в большинстве случаев используют язык запросов _SQL_.

[**Система управления базой данных (СУБД)**](/conspect/definitions.md/#с) - это инструменты, с помощью которых
запрашивают данные в базе, изменяют или создают базы.

Среди СУБД выделяют реляционные, объектно-реляционные, нереляционные документированные СУБД и _Redis_.  
[**Redis (Remote Dictionary Server)**](/conspect/definitions.md/#r) - это открытая _NoSQL_-система управления базами
данных.  
То есть она не использует язык запросов _SQL_, а запрашивает данные с помощью других языков программирования и
конструкций. _Redis_ полезна, чтобы хранить игровые сессии, рейтинговые таблицы, состояние игроков, статистику игр и
других временных или постоянных данных, которые нужно обрабатывать быстро.

## 8.2 Persistence Layer

> [[_оглавление_]](../README.md/#82-persistence-layer)

### 8.2.1 JDBC

> [[_оглавление_]](../README.md/#82-persistence-layer)

[**JDBC (Java DataBase Connectivity)**](/conspect/definitions.md/#j) - это соединение с базами данных на Java; стандарт
взаимодействия Java-приложений с различными [СУБД](/conspect/definitions.md/#с), реализованный в виде пакетов `java.sql`
и `javax.sql`, входящих в состав _Java SE_.

Данный стандарт описан спецификацией _JSR 221 JDBC 4.1 API_, основными постулатами которой являются:

- _JDBC API_ предоставляет программный доступ к реляционным базам данных из программ, написанных на Java;
- _JDBC API_ является частью платформы Java и входит поэтому в _Java SE_ и _Java EE_;
- _JDBC API_ представлен двумя пакетами: `java.sql` and `javax.sql`.

![38.png](/pictures/38.png)

База данных является внешним компонентом, которого нет изначально в _Java SE_. Это объясняется просто - существует
огромное количество баз данных и работать можно захотеть с любой. Например, есть _PostgreSQL_, _Oracle_, _MySQL_, _H2_.
Каждая из этих баз данных поставляется отдельной компанией, которые называются поставщиками баз данных. Каждая база
данных написана на каком-то своём языке программирования (не обязательно Java). Чтобы с базой данных можно было работать
из Java приложения поставщик базы данных пишет особый драйвер (_JDBC Driver_), который является своего образа адаптером.
Каждый такой _JDBC_-драйвер — это некоторый артефакт, библиотека, _jar_-файл. Он то и добавляется в качестве зависимости
для проекта.

_JDBC_-драйвер не является базой данных, а является проводником к ней.

[**In memory databases**](/conspect/definitions.md/#i) - это такие базы данных, которые существуют в оперативной памяти
на время жизни приложения.

_In memory databases_, как правило, применяются для тестирования приложений.

### 8.2.2 JPA

> [[_оглавление_]](../README.md/#82-persistence-layer)

[**ORM (Object-Relational Mapping)**](/conspect/definitions.md/#o) - это объектно-реляционное отображение; технология
программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования (связь
Java-объектов и записей в БД).

_ORM_ появился как дальнейшее развитие _JDBC_ с целью избавления разработчиков от необходимости писать однотипный и
ненужный "обслуживающий" код (так называемый _Boilerplate code_) для тривиальных операций по сохранению Java-объектов в
БД и наоборот, созданию Java-объектов по данным из БД.

![39.png](/pictures/39.png)

_ORM_ - это по сути концепция о том, что Java-объект можно представить как данные в БД (и наоборот). Она нашла
воплощение в виде спецификации _JPA_.

[**JPA (Java Persistence API)**](/conspect/definitions.md/#j) - это спецификация _API Jakarta EE_, которая предоставляет
возможность сохранять в удобном виде Java-объекты в базе данных.

Одной из самых популярных реализаций _JPA_ является _Hibernate_.

### 8.2.3 Hibernate

> [[_оглавление_]](../README.md/#82-persistence-layer)

[**Hibernate**](/conspect/definitions.md/#h) - это фреймворк для языка Java, предназначенный для работы с базами данных.

Он реализует объектно-реляционную модель (_ORM_) - технологию, которая соединяет программные сущности и соответствующие
записи в БД. Иногда его называют библиотекой - оба названия в принципе справедливы.

_Hibernate_ построен на спецификации _JPA 2.1_ — наборе правил, который описывает взаимодействие программных объектов с
записями в базах данных. _JPA_ поясняет, как управлять сохранением данных из кода на Java в базу. Но сама по себе
спецификация — только теоретические правила, а в чистой Java ее реализации нет. _Hibernate_ — одна из самых популярных
реализаций _JPA_.

_Hibernate_:

- ускоряет и облегчает написание кода;
- позволяет создать удобную модель для отображения базы данных в коде;
- дает возможность быстро и в читаемом виде записывать информацию из кода в базу.

Основная идея фреймворка - создать виртуальную базу данных из программных объектов и работать с ней как с реальной
базой. Поэтому им часто пользуются для упрощения работы. Он берет на себя взаимодействие с реляционной БД, а
разработчику остаётся работать с кодом.

В _Hibernate_ есть возможность, которую называют «ленивой загрузкой». Объекты во фреймворке не подгружают всю информацию
из базы изначально. Вместо этого они просто «знают», как ее получить, и при первом обращении к информации загружают ее в
фоне. Это нужно для оптимизации производительности.

Внутри _Hibernate_ имеется собственный язык запросов _Hibernate Query Language_ (_HQL_). Это _SQL_-подобный язык, но
полностью объектно-ориентированный и более краткий — не приходится так много работать с шаблонным кодом, как в чистом
_SQL_.

Преимущества использования _Hibernate_:

- популярность;
- устранение лишнего кода;
- возможность сосредоточиться на логике;
- независимость от базы данных (_Hibernate_ может работать с любой БД);
- объектно-ориентированный подход.

Недостатки использования _Hibernate_:

- сложность в освоении;
- проблемы с производительностью;
- непредсказуемость кода;
- сложности с кэшированием.

## 8.3 SQL

> [[_оглавление_]](../README.md/#83-sql)

[**SQL (Structured Query Language)**](/conspect/definitions.md/#s) - это язык структурированных запросов; язык
программирования, предназначенный для управления данными в базе данных.

В _SQL_ есть две составные части: _DDL_ и _DML_.

[**DDL (Data Definition Language)**](/conspect/definitions.md/#d) - это подмножество языка _SQL_, используемое для
определения структуры базы данных и ее объектов, таких как таблицы, представления, индексы и процедуры.

[**DML (Data Manipulation Language)**](/conspect/definitions.md/#d) - это подмножество языка _SQL_, используемое для
манипулирования данными в базе данных.

В скриптах сначала выполняются операторы _DDL_, а потом выполняются операторы _DML_.

### 8.3.1 DDL

> [[_оглавление_]](../README.md/#83-sql)

_DDL_-операторы используются для создания, изменения и удаления объектов базы данных, включая таблицы, представления,
индексы и хранимые процедуры.

_DDL_ - это набор команд _SQL_ для определения схемы базы данных.

Наиболее распространённые _DDL_-операторы:

* **CREATE** - оператор создаёт новый объект базы данных, такой как таблица, представление или индекс;

Пример (создание таблицы "customers"):

```sql
CREATE TABLE customers
(
    id      INT PRIMARY KEY,
    name    VARCHAR(255),
    address VARCHAR(255)
);
```

* **ALTER** - оператор используется для изменения существующего объекта базы данных;

Пример (добавление нового столбца "email" в таблицу "customers"):

```sql
ALTER TABLE customers
    ADD email VARCHAR(255);
```

* **DROP** - оператор используется для удаления существующего объекта базы данных;

Пример (удаление таблицы "customers"):

```sql
DROP TABLE customers;
```

* **TRUNCATE** - оператор используется для удаления всех строк в таблице, но в отличие от оператора _DROP_ он сохраняет
  структуру таблицы и индексы;

Пример (очистка таблицы "customers"):

```sql
TRUNCATE TABLE customers;
```

* **RENAME** - оператор используется для переименования существующего объекта базы данных.

Пример (переименование таблицы "customers" в "clients"):

```sql
ALTER TABLE customers
    RENAME TO clients;
```

_DDL_-операторы выполняются немедленно и являются постоянными, то есть после создания, изменения или удаления объекта
изменения невозможно отменить.

### 8.3.2 DML

> [[_оглавление_]](../README.md/#83-sql)

_DML_-операторы используются для вставки, обновления и удаления данных в базе данных.

_DML_ - это набор команд _SQL_, используемых для манипулирования данными в пределах схемы, созданной _DDL_.

Наиболее распространённые _DML_-операторы:

* **SELECT** - оператор используется для получения данных из одной или нескольких таблиц базы данных;

Пример (получение всех записей из таблицы "customers"):

```sql
SELECT *
FROM customers;
```

* **INSERT** - оператор используется для вставки новых данных в таблицу;

Пример (вставка новой строки в таблицу "customers"):

```sql
INSERT INTO customers (id, name, address)
VALUES (1, 'John Smith', '123 Main St');
```

* **UPDATE** - оператор используется для изменения существующих данных в таблице;

Пример (обновление адреса клиента с идентификатором 1 в таблице "customers"):

```sql
UPDATE customers
SET address = '456 Park Ave'
WHERE id = 1;
```

* **DELETE** - оператор используется для удаления данных из таблицы.

Пример (удаление клиента с идентификатором 1 из таблицы "customers"):

```sql
DELETE
FROM customers
WHERE id = 1;
```

### 8.3.2.1 SELECT-запросы

> [[_оглавление_]](../README.md/#83-sql)

Общая структура запроса выглядит следующим образом:

* **SELECT** `[наименования столбцов или для выбора всех столбцов]`;
* **FROM** `[наименование таблицы]`;
* **WHERE** `[условие/фильтрация по данным в ячейках]` (необязательно);
* **GROUP BY** `[столбец, по которому хотим сгруппировать данные]` (необязательно);
* **HAVING** `[условие/фильтрация по полученным сгруппированным данным]` (необязательно);
* **ORDER BY** `[столбец, по которому хотим отсортировать вывод по возрастанию/убыванию]` (необязательно).

Пример:

```sql
SELECT author, year, COUNT(author)
FROM book
WHERE reader_id IS NOT NULL
GROUP BY author, year
HAVING COUNT(author) < 2
ORDER BY year DESC;
```

###### SELECT, FROM

_SELECT_, _FROM_ - это обязательные элементы запроса, которые определяют выбранные столбцы, их порядок и источник
данных.

После ключевого слова _SELECT_ могут использоваться следующие операторы:

- **AS** - оператор "ИМЕНОВАТЬ КАК" - позволяет задать краткий псевдоним для результата выполнения агрегатной функции.

После ключевого слова _FROM_ могут использоваться следующие операторы:

- **AS** - оператор "ИМЕНОВАТЬ КАК" - позволяет задать краткий псевдоним для таблицы.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-1)

###### WHERE

_WHERE_ - это необязательный элемент запроса, который используется, когда необходимо отфильтровать данные по нужному
условию.

После ключевого слова _WHERE_ могут использоваться следующие операторы:

- **<** - оператор "МЕНЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **=** - оператор "РАВНО" - позволяет сравнивать числовые значения с указанным значением;
- **>** - оператор "БОБЛЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **AND** - оператор "И" - позволяет объединять несколько условий;
- **IN ()** - оператор "В ДИАПАЗОНЕ" - позволяет сравнивать значения с указанными в круглых скобках (`( )`);
- **IS** - оператор "ЕСТЬ" - позволяет сравнивать значения с указанным значением;
- **LIKE** - оператор "ПОХОЖ НА" - позволяет сравнивать содержание строчных значений с указанным значением:
    * `%` - символ "СОДЕРЖАНИЕ ДО/ПОСЛЕ" - позволяет не учитывать предшествующие или последующие символы;
- **NULL** - оператор "НУЛЬ" - позволяет сравнивать значения с нулём, применяется после операторов _IS_, _NOT_;
- **NOT** - оператор "НЕ" - позволяет задать отрицание условия;
- **OR** - оператор "ИЛИ" - позволяет объединять несколько условий.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-2)

###### GROUP BY

_GROUP BY_ является необязательным элементом запроса, с помощью которого можно задать группировку вывода результатов
выполнения агрегатной функции и запроса в целом по вариантам значений одного или нескольких нужных столбцов.

Для использования _GROUP BY_ необходимо учесть следующие правила:

* перечень столбцов, по которым делается разрез, должен быть одинаковым внутри блока _SELECT_ и внутри блока _GROUP BY_;
* агрегатные функции (_SUM_, _AVG_, _COUNT_, _MAX_, _MIN_) должны быть также указаны внутри _SELECT_ с указанием
  столбца, к которому такая функция применяется.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-3)

###### HAVING

_HAVING_ - это необязательный элемент запроса, который отвечает за фильтрацию на уровне сгруппированных данных.

Ключевое слово _HAVING_ применяется для фильтрации выводимых данных, сгруппированных посредством _GROUP BY_.

То есть _WHERE_ накладывает условие на значения в ячейках таблицы, а _HAVING_ накладывает условие на результаты,
полученные посредством применения _GROUP BY_.

После ключевого слова _HAVING_ могут использоваться следующие операторы:

- **<** - оператор "МЕНЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **=** - оператор "РАВНО" - позволяет сравнивать числовые значения с указанным значением;
- **>** - оператор "БОБЛЬШЕ" - позволяет сравнивать числовые значения с указанным значением;
- **AND** - оператор "И" - позволяет объединять несколько условий;
- **IN ()** - оператор "В ДИАПАЗОНЕ" - позволяет сравнивать значения с указанными в круглых скобках (`( )`);
- **IS** - оператор "ЕСТЬ" - позволяет сравнивать значения с указанным значением;
- **LIKE** - оператор "ПОХОЖ НА" - позволяет сравнивать содержание строчных значений с указанным значением:
    * `%` - символ "СОДЕРЖАНИЕ ДО/ПОСЛЕ" - позволяет не учитывать предшествующие или последующие символы;
- **NULL** - оператор "НУЛЬ" - позволяет сравнивать значения с нулём, применяется после операторов _IS_, _NOT_;
- **NOT** - оператор "НЕ" - позволяет задать отрицание условия;
- **OR** - оператор "ИЛИ" - позволяет объединять несколько условий.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-4)

###### ORDER BY

_ORDER BY_ - это необязательный элемент запроса, который отвечает за сортировку таблицы в порядке возрастания или
убывания значений по одному или нескольким столбцам.

После ключевого слова _ORDER BY_ могут использоваться следующие операторы:

- **DESC** - оператор "НАОБОРОТ" - позволяет задать обратный порядок сортировки.

> [[_Примеры использования_]](/conspect/example_5.md/#пример-5)

