## 2.2 Объектно-ориентированное программирование (ООП)

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Объектно-ориентированный подход (ООП)**](/conspect/definitions.md/#о) - это построение приложений в виде множества
различных объектов (каждый из них является реализацией какого-либо класса), которые взаимодействуют друг с другом.
Причем любой объект может реализовывать не просто какой-то конкретный класс, а целую иерархию унаследованных друг от
друга классов, каждый из которых внёс частичку себя в общее целое.  
У объектов могут быть свойства.  
[**Свойства объектов**](/conspect/definitions.md/#с) - это переменные, привязанные к объекту.

Принципы ООП:

- инкапсуляция;
- наследование;
- полиморфизм;
- абстракция.

### 2.2.1 Инкапсуляция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

Инкапсуляция является одним из принципов ООП.  
[**Инкапсуляция**](/conspect/definitions.md/#и) - это принцип ООП, согласно которого мы не даем прямой доступ к
свойствам объекта, а получаем их значения через методы.

Для реализации принципа инкапсуляции существуют [модификаторы доступа](/conspect/01_08.md/#181-модификаторы-доступа).

![5.png](/pictures/5.png)

Пользователь не должен иметь доступ к методам, которые ему не положено вызывать, или к полям, которые ему запрещено
читать или даже изменять. Пользователь должен работать только с тем, что ему нужно.

### 2.2.2 Наследование

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Наследование**](/conspect/definitions.md/#н) - это принцип ООП, согласно которого можно создавать новый класс на
основе существующего. При этом класс-наследник заимствует все свойства и функциональность родительского класса.

![6.png](/pictures/6.png)

Для реализации принципа наследования в Java используется ключевое слово `extends`.

> [**extends**](/conspect/definitions.md/#e) – это ключевое слово, которое применяется для обозначения того, что данный
> класс является наследником другого класса и расширяет свойства и функциональность класса-родителя.

Следует знать, что `private`-члены класса (поля и методы) не наследуются. Это значит, что ими будет управлять родитель,
но доступа к ним из наследника не будет.  
Если влезть в реализацию этого механизма, то Java неявно подкладывает объект класса-родителя в ваш объект и присваивает
его переменной `super` (по аналогии с `this`, которая ссылается на ваш текущий объект).  
А по переменной `super`, соответственно, можно вызвать конструктор родителя.

> [**super**](/conspect/definitions.md/#s) - это переменная, которая всегда ссылается на конкретный объект родительского
> класса.

Ключевое слово `super` используется для того, чтобы явно показать, к какому конкретно конструктору родительского класса
мы обращаемся.  
При использовании ключевого слова `super` вызывается конструктор по умолчанию родительского класса.

Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст
сообщение об ошибке. Из чего следует, что в одном конструкторе для поля _с одним и тем же именем_ не может быть
одновременно и `this`, и `super`.

Пример использования:

```java
public class Person {
    private String name;
    private String surname;
    private int age;

    public Person(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name) && Objects.equals(surname, person.surname);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname, age);
    }

    @Override
    public String toString() {
        return "Person[" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", age=" + age +
                ']';
    }
}
```

```java
public class Worker extends Person {
    private static int counter = 1;
    private final int id;
    private String position;

    public Worker(String name, String surname, int age, String position) {
        super(name, surname, age);
        this.position = position;
        this.id = counter++;
    }

    public int getId() {
        return id;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Worker worker = (Worker) o;
        return id == worker.id && Objects.equals(position, worker.position);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), id, position);
    }

    @Override
    public String toString() {
        return "Worker[" +
                "id=" + id +
                ", person=" + super.toString() +
                ", position='" + position + '\'' +
                ']';
    }
}
```

```java
private static void inheritanceExample() {
    Person ivan = new Person("Ivan", "Ivanov", 21);
    Worker petr = new Worker("Petr", "Petrov", 22, "programmer");
    Worker fedor = new Worker("Fedor", "Fedorov", 23, "manager");
    Worker sidor = new Worker("Sidor", "Sidorov", 25, "manager");
    System.out.println(ivan);
    System.out.println(petr);
    System.out.println(fedor);
    System.out.println(sidor);
    sidor.setPosition("commercial director");
    System.out.println(sidor);
}
```

Если вдруг наследники должны иметь внутри себя логику по работе с содержимым полей родителя, то эти поля (или методы)
должны быть помечены модификаторами `default` (отсутствует модификатор, если родитель и наследник лежат в одном пакете)
или `protected`.

### 2.2.3 Полиморфизм

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Полиморфизм**](/conspect/definitions.md/#п) - это принцип ООП, согласно которого можно работать со многими классами,
как с одним, при условии, что все эти классы имеют одного базового предка; способность предоставлять один и тот же
интерфейс для различных базовых форм (типов данных).  
Это означает, что классы, имеющие различную функциональность, совместно используют один и тот же интерфейс и могут быть
динамически вызваны передачей параметров по ссылке.  
Процесс, применяемый объектно-ориентированными языками программирования для реализации динамического полиморфизма,
называется [**динамическим связыванием**](/conspect/definitions.md/#д).

![7.png](/pictures/7.png)

При использовании принципа полиморфизма необходимо учитывать следующее:

- любой прямой или косвенный наследник класса может быть использован в качестве экземпляра своего родителя;
- за набор полей и методов отвечает тип (класс) ссылки предка;
- за код, который выполняется при вызове этих методов (то, что после `=`), отвечает уже реализация (класс наследника);
- наследование должно быть только от одного класса.

> **_!!! Множественное наследование в Java запрещено !!!_**

#### 2.2.3.1 Дженерики (Параметрический полиморфизм)

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Дженерики (Обобщения)**](/conspect/definitions.md/#д) - это функциональность _Java_, позволяющая создавать
универсальный код, который может быть использован для разных типов данных, и уточнять этот тип тогда, когда нужно.  
Дженерики используются для создания обобщенных классов, интерфейсов и методов, которые могут работать с различными
типами данных.  
Параметризованные типы проясняют, с каким типом данных будет работать класс или метод.

Чтобы объявить дженерик, нужно создать параметризованный класс, для чего обобщённый тип необходимо поместить в
diamond-скобки (`< >`).

[**Параметризованный класс**](/conspect/definitions.md/#п) - это класс, который может быть создан с помощью параметра
типа. Вместо конкретного типа данных параметризованный класс использует обобщенный тип, который определяется во время
создания экземпляра класса.

> В качестве параметра в дженериках нельзя указывать примитивы. Это ограничение обусловлено тем, что разработчиками
> языка Java в дженериках не были реализованы автоупаковка и автораспаковка (боксинг и анбоксинг).

Параметризованные классы используются для упрощения кода в ситуациях, когда методы класса могут применяться для работы с
переменными различных типов.

Пример использования - создание класса-хранилища для значений разных типов:

- модель:

```java
package javaCore.models;

import java.util.Objects;

public class VariableContainer<T extends Object> {
    private T value;

    public VariableContainer(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        VariableContainer<?> that = (VariableContainer<?>) o;
        return Objects.equals(value, that.value);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(value);
    }

    @Override
    public String toString() {
        return "VariableContainer{" +
                "value=" + value +
                '}';
    }
}
```

- применение:

```java
private static void genericExample() {
    List<VariableContainer> values = new ArrayList<>();
    VariableContainer<Byte> var1 = new VariableContainer((byte) 1);
    VariableContainer<Short> var2 = new VariableContainer((short) 1_000);
    VariableContainer<Integer> var3 = new VariableContainer(1_000_000);
    VariableContainer<Long> var4 = new VariableContainer(1_000_000_000_000L);
    VariableContainer<Float> var5 = new VariableContainer(2_000_000.0f);
    VariableContainer<Double> var6 = new VariableContainer(2_000_000_000_000.0);
    VariableContainer<Character> var7 = new VariableContainer('A');
    VariableContainer<Boolean> var8 = new VariableContainer(true);
    VariableContainer<String> var9 = new VariableContainer("String");
    values.add(var1);
    values.add(var2);
    values.add(var3);
    values.add(var4);
    values.add(var5);
    values.add(var6);
    values.add(var7);
    values.add(var8);
    values.add(var9);
    for (int i = 0; i < values.size(); i++) {
        switch (values.get(i).getValue().getClass().getSimpleName()) {
            case ("Byte"):
                System.out.println("Byte value is " + values.get(i).getValue());
                break;
            case ("Short"):
                System.out.println("Short value is " + values.get(i).getValue());
                break;
            case ("Integer"):
                System.out.println("Integer value is " + values.get(i).getValue());
                break;
            case ("Long"):
                System.out.println("Long value is " + values.get(i).getValue());
                break;
            case ("Float"):
                System.out.println("Float value is " + values.get(i).getValue());
                break;
            case ("Double"):
                System.out.println("Double value is " + values.get(i).getValue());
                break;
            case ("Character"):
                System.out.println("Character value is " + values.get(i).getValue());
                break;
            case ("Boolean"):
                System.out.println("Boolean value is " + values.get(i).getValue());
                break;
            case ("String"):
                System.out.println("String value is " + values.get(i).getValue());
                break;
            default:
                System.out.println("Unknown value type " + values.get(i).getValue().getClass());
        }
    }
}
```

В Java можно создавать **ограниченные типы (bounded type)**, которые нужны, чтобы предотвратить ошибки времени
выполнения, связанные с использованием неправильных типов. Ограниченные типы позволяют указать, какие типы могут быть
использованы в качестве параметров для обобщенных классов или методов, а какие - нет.  
Параметр типа можно ограничить классом-предком. В этом случае нужно использовать ключевое слово `extends`.

Например:

```java
class NullBox<Т extends Number>
// В данном случае класс Printer сможет использовать только классы,
// наследующиеся от PrintedMaterial или сам класс PrintedMaterial.
```

Можно также комбинировать типы ограничений. В этом случае ограничители нужно перечислять через
разделитель-амперсанд (`&`).

> В ограничителях нужно указать тип класса, а после него - интерфейсы.

Например:

```java
class Printer<T extends Number & Serializable> {
// Можно использовать в качестве параметра типа класс PrintedMaterial
// или его наследников, а также объекты, реализующие интерфейс Printable.
}
```

### 2.2.4 Абстракция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстракция**](/conspect/definitions.md/#а) – это принцип ООП, согласно которому при проектировании классов и создании
объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные; процесс сокрытия деталей
реализации от пользователя, предоставляя ему только функционал (интерфейс).  
Иными словами, пользователь будет владеть информацией о том, что объект делает, а не как он это делает.  
В Java абстракция достигается с использованием абстрактных классов и интерфейсов.

#### 2.2.4.1 Абстрактные классы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстрактный класс**](/conspect/definitions.md/#а) - это класс, который не может быть использован для создания
объектов.  
Вместо создания объектов абстрактный класс служит как базовый элемент для других классов.

Для создания абстрактного класса в Java используется ключевое слово `abstract`.

> [**abstract**](/conspect/definitions.md/#a) - это ключевое слово, которое применяется для создания абстрактных классов
> и методов.

Абстрактный класс может содержать и абстрактные и конкретные методы. Классы, которые наследуют от абстрактного класса,
должны реализовывать все его абстрактные методы. Если хоть один метод в классе объявлен абстрактным, весь класс должен
так же быть объявлен абстрактным. Тем не менее, в обратную сторону правило не обязано соблюдаться. Если класс объявлен
абстрактным, он может и не содержать абстрактные методы.

[**Абстрактный метод**](/conspect/definitions.md/#а) - это метод, который всего лишь определяет свои сигнатуры и не
обеспечивает реализацию.

Абстрактные классы рекомендуется применять в следующих случаях:

- необходимо поделиться кодом между несколькими тесно связанными классами;
- классы, которые расширяют абстрактный класс, имеют много общих методов или полей, или требуют других модификаторов
  доступа, кроме `public` (например, `protected` и `private`);
- необходимо объявить нестатические или не-final поля, что позволяет определять методы, которые могут получить доступ и
  изменить состояние объекта, которому они принадлежат.

#### 2.2.4.2 Интерфейсы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Интерфейс**](/conspect/definitions.md/#и) - это конструкция языка Java, в рамках которой принято описывать
абстрактные публичные (`abstract public`) методы и статические константы (`final static`).  
Интерфейсы создаются по аналогии с классами, но с помощью ключевого слова `interface`, а не `class`.

> [**interface**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для создания интерфейсов.

Свойства интерфейса:

- содержит только абстрактные методы (слово `abstract` писать не нужно);
- у интерфейсов все методы `public`;
- может наследоваться только от интерфейсов;
- в Java есть множественное наследование интерфейсов (родителей у интерфейса может быть много);
- класс может реализовывать несколько интерфейсов (и наследоваться только от одного класса);

> [**implements**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для обозначения того, что
> данный класс реализует какой-либо интерфейс.

- в интерфейсах нельзя объявлять переменные, кроме статических.

Начиная с Java 8, в интерфейсах можно создавать методы по умолчанию с использованием ключевого слова `default`.

> [**default**](/conspect/definitions.md/#d) - это ключевое слово, которое применяется для создания методов по
> умолчанию.

К примеру:

```java
public interface Swimmable {

    public default void swim() {
        System.out.println("Плыви!");
    }

    public void eat();

    public void run();
}
```

Во всех классах, имплементирующих интерфейс _Swimmable_, необходимо будет переопределять методы _eat()_ и _run()_, а для
метода _swim()_ этого делать будет не обязательно (но может быть), так как его реализация во всех классах будет
одинаковой.

Интерфейсы рекомендуется применять в следующих случаях:

- интерфейс будут реализовывать несвязанные классы;
- необходимо определить поведение конкретного типа данных, при этом не важно, кто его реализует;
- необходимо использовать множественное наследование.

##### 2.2.4.2.1 Анонимные классы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Анонимный класс**](/conspect/definitions.md/#а) - это специальный класс, который реализует методы интерфейса или
абстрактного класса в том месте, где создаётся.

Анонимный класс создаётся не в отдельном файле, а посредством ключевого слова `new` внутри другого класса или его
метода. После этого указывается название интерфейса, а в следующих далее фигурных скобках (`{ }`) реализуются методы,
определённые в интерфейсе, который этот класс реализует.

Например:

```java
public class PrintableTest {
    public static void main(String[] args) {
        Printable printable = new Printable() {
            @Override
            public void print() {
                Book book = new Book("War and Peace", "Leo Tolstoy");
                Magazine magazine = new Magazine("National Geographic", 250);
                System.out.println("Printing a book:");
                book.print();
                System.out.println("Printing a magazine:");
                magazine.print();
            }
        };
        printable.print();
    }
}
```

Анонимные классы, как правило, реализуют в месте создания какой-либо функциональный интерфейс.

##### 2.2.4.2.2 Функциональные интерфейсы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Функциональный интерфейс**](/conspect/definitions.md/#ф) - это интерфейс, который содержит только один абстрактный
метод (при этом число статических и дефолтных методов не ограничено).

Самые часто используемые функциональные интерфейсы:

- _Runnable_ - используется в многопоточном программировании и в тех местах, где нужно просто запустить код без
  аргументов и возврата значения;

```java
public interface Runnable {
    void run();
}
```

- _Predicate<T>_ - проверяет соблюдение какого-то условия: если оно соблюдается, то возвращается значение `true`;

```java
public interface Predicate<T> {
    boolean test(T t);
}
```

- _Function<T, R>_ - представляет функцию перехода от объекта типа `T` к объекту типа `R` в реализации метода `apply()`;

```java
public interface Function<T, R> {
    R apply(T t);
}
```

- _UnaryOperator<T>_ - частный случай функции, поэтому в методе `apply()` этот интерфейс принимает в качестве параметра
  объект типа `T`, выполняет над ним операции и возвращает результат операций в виде объекта типа `T`;

```java
public interface UnaryOperator<T> {
    T apply(T t);
}
```

- _BinaryOperator<T>_ - частный случай функции, поэтому в методе `apply()` этот интерфейс принимает в качестве параметра
  два объекта типа `T`, выполняет над ними бинарную операцию и возвращает ее результат в виде объекта типа `T`;

```java
public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}
```

- _Consumer<T>_ - выполняет действие над объектом типа `T` и при этом ничего не возвращает;

```java
public interface Consumer<T> {
    void accept(T t);
}
```

- _Supplier<T>_ - не принимает никаких аргументов, но должен возвращать объект типа `T`.

```java
public interface Supplier<T> {
    T get();
}
```

##### 2.2.4.2.3 Iterator

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Iterator**](/conspect/definitions.md/#i) - это механизм доступа к элементам коллекции без необходимости раскрытия ее
внутренней структуры; универсальный способ перебора элементов независимо от типа коллекции и способа ее реализации.

Итераторы позволяют перебирать элементы коллекции без знания о ее внутренней структуре или реализации. Они обеспечивают
абстракцию над коллекцией и предоставляют удобный способ последовательного доступа к ее элементам и применяются для
операций изменения коллекции в момент прохода по ней.

Пример:

```java
private static void iteratorExample() {
    List<Integer> arrayList = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    Iterator<Integer> iterator = arrayList.iterator();
    while (iterator.hasNext()) {
        if (iterator.next() % 2 == 0) {
            iterator.remove();
        }
    }
    System.out.println(arrayList);
}
```

##### 2.2.4.2.4 Comparator

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Comparator**](/conspect/definitions.md/#c) - это специальный интерфейс в Java, который устанавливает отношение
порядка между объектами.

Многие методы и классы в коллекциях принимают _Comparator_ в качестве дополнительного аргумента, чтобы выстраивать
объекты в нужном порядке.  
_Comparator_ имеет ряд статических методов, наиболее часто используемые из которых: `naturalOrder()` (располагает
элементы в естественном порядке) и `reverseOrder()` (располагает элементы в обратном порядке).

В случае необходимости можно создать свой компаратор, упорядочивающий элементы в том порядке, который требуется.

Например:

- создадим свой компаратор для сортировки значений типа `String`:

```java
public class ReverseStringComparator implements Comparator<String> {

    // Метод compare работает так же, как compareTo в интерфейсе Comparable
    // Различие в том, что он сравнивает 2 объекта из аргументов,
    // а не this и other
    // Контракт у этого метода такой же, как у метода compareTo
    @Override
    public int compare(String s1, String s2) {
        // Чтобы обратить порядок, можно сравнить в обратном порядке
        // То есть, если s1 больше s2, то возвращаем не 1, а -1
        return s2.compareToIgnoreCase(s1);
    }
}
```

- применим созданный компаратор:

```java
private static void comparatorExample() {
    Set<String> tree = new TreeSet<>(new ReverseStringComparator());
    tree.add("b");
    tree.add("a");
    tree.add("c");
    tree.add("d");
    tree.add("B");
    tree.add("A");
    tree.add("C");
    tree.add("D");
    System.out.println(tree);
}
```

В результате в терминале будет выведено `[d, c, b, a]`. Это связано с тем, что _TreeSet_ сравнивает элементы без учета
регистра и не добавляет элементы в верхнем регистре (поскольку они добавляются позже).

> Интерфейс _Comparator_ и реализующие его классы применяются, когда нужно сравнить объекты по какому-то другому
> правилу, отличному от естественного порядка.

> И `Comparable`, и `Comparator` обычно используются в коллекциях Java для реализации функций сортировки. `Comparable`
> необходимо реализовать в классе, который требует сортировки, тогда как `Comparator` может быть реализован в другом
> классе или также может быть реализован с помощью лямбда-функции.

##### 2.2.4.2.5 Comparable

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

Интерфейс _Comparable_ (как и [_Comparator_](/conspect/02_02.md/#22424-comparator)) позволяет установить в объектах 
отношения порядка, то есть указать, какой из объектов нужно считать большим, а какой - меньшим, что позволяет 
сортировать объекты.

Метод `compareTo()` интерфейса _Comparable_ может возвращать три вида целых чисел:

- _отрицательное целое число_ - если объект `this` < `other`;
- _ноль_ - если объект `this` = `other`;
- _положительное целое число_ - если объект `this` > `other`.

Также должны выполняться следующие правила:

- если `x.compareTo(y) == 0`, то `x.equals(y) == true`;
- если `x.compareTo(y) > 0`, то `y.compareTo(x) < 0`.

Метод `compareTo()` может выбрасывать исключения:

- _NullPointerException_ - если объект `other == null`;
- _ClassCastException_ - если объект `other` нельзя привести к требуемому классу.

Пример:

- реализуем интерфейс _Comparable_ у класса _Person_, определив сортировку объектов по полю `name`:

```java
public class Person implements Comparable<Person> {
    private String name;
    private String surname;
    private int age;
    // конструктор, геттеры, сеттеры, equals(), hashCode(), toString()

    @Override
    public int compareTo(Person o) {
        return name.compareTo(o.name);
    }
}
```

- создадим `TreeMap` из объектов _Person_:

```java
private static void treeMapExample() {
    Person ivan = new Person("Ivan", "Ivanov", 25);
    Person petr = new Person("Petr", "Petrov", 25);
    Person sidor = new Person("Sidor", "Sidorov", 31);
    Map<Person, Integer> persons = new TreeMap<>();
    persons.put(sidor, sidor.getAge());
    persons.put(ivan, ivan.getAge());
    persons.put(petr, petr.getAge());
    System.out.println(persons);
}
```

- в терминале получим список персон, отсортированный по имени:

```text
{Person[name='Ivan', surname='Ivanov', age=25]=25, Person[name='Petr', surname='Petrov', age=25]=25, Person[name='Sidor', surname='Sidorov', age=31]=31}
```

> И `Comparable`, и `Comparator` обычно используются в коллекциях Java для реализации функций сортировки. `Comparable`
> необходимо реализовать в классе, который требует сортировки, тогда как `Comparator` может быть реализован в другом
> классе или также может быть реализован с помощью лямбда-функции.

#### 2.2.4.3 Различия между абстрактным классом и интерфейсом:

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

- интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме
  `public static final`), в то время как у абстрактного класса они могут быть;
- абстрактный класс наследуется (`extends`), а интерфейс - реализуется (`implements`): можно наследовать только один
  класс, а реализовать интерфейсов - сколько угодно (интерфейс может наследовать (`extends`) другой
  интерфейс/интерфейсы);
- абстрактные классы используются, когда есть отношение _"is-a"_, то есть класс-наследник расширяет базовый абстрактный
  класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом;
- методы и члены абстрактного класса могут быть обозначены любым модификатором доступа, в свою очередь все методы
  интерфейса обязаны быть открытыми (`public`);
- когда происходит наследование абстрактного класса, класс-наследник должен определить абстрактные методы, в то время
  как интерфейс может наследовать другой интерфейс и при этом не обязательно определять его методы;
- класс-наследник может расширять только один абстрактный класс, а интерфейс может расширять или класс может
  реализовывать множество других интерфейсов;
- класс-наследник может определять абстрактные методы с тем же или менее ограниченным модификатором доступа, при этом
  класс, реализующий интерфейс, должен определять методы с тем же уровнем видимости;
- интерфейс не содержит конструкторы, в том время, как они есть в абстрактном классе;
- переменные, объявленные в интерфейсе по умолчанию являются `final`, абстрактный класс может содержать переменные,
  которые не являются `final`;
- все участники интерфейса по умолчанию являются `public`, а участники абстрактного класса могут позволить себе
  быть `public`, `protected` и др.