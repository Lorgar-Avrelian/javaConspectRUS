# 2 Java Core

> [[_оглавление_]](../README.md/#2-java-core)

## 2.1 Память в Java

> [[_оглавление_]](../README.md/#21-память-в-java)

Все данные <u>_вне зависимости от используемого языка программирования_</u> хранятся в виде структур данных.  
[**Структура данных**](/conspect/definitions.md/#с) - это программная единица, позволяющая хранить и обрабатывать
множество однотипных и/или логически связанных данных в вычислительной технике.  
Структур данных существует огромное множество. Самыми популярными из них являются:

- связный список;
- ассоциативный массив;
- стек;
- очередь.

[**Связный список**](/conspect/definitions.md/#с) - это базовая динамическая структура данных в информатике, состоящая
из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или
предыдущий узел списка.  
В Java структура данных связный список реализован в классе `Linkedlist`.

[**Ассоциативный массив**](/conspect/definitions.md/#а) - это абстрактный тип данных (интерфейс к хранилищу данных),
позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления
пары по ключу.  
В Java структура данных ассоциативный массив реализован в классе `Map`.

[**Стек (Stack)**](/conspect/definitions.md/#с) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого *
*вершиной стека**.  
В стеке реализован принцип _LIFO_.  
[**LIFO (last-in, first-out)**](/conspect/definitions.md/#l) - это принцип, при котором первым удаляется элемент,
который был помещен туда последним («последним вошел — первым вышел»).

![1.jpeg](/pictures/1.jpeg)

В Java структура данных ассоциативный массив реализован в классе `java.util.Stack`.

[**Очередь (Queue)**](/conspect/definitions.md/#q) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов производится в конец, называемый **хвостом очереди**, а удаление
существующих производится с другого конца, называемого **головой очереди**.  
В очереди реализован принцип _FIFO_.  
[**FIFO (first-in, first-out)**](/conspect/definitions.md/#f) - это принцип, при котором первым удаляется элемент,
который был помещен туда первым («первым вошел — первым вышел»).

![2.png](/pictures/2.png)

В Java структура данных очередь представлена не классом, а интерфейсом - `Queue`.  
Но вместе с тем, очередь в Java - это интерфейс, у которого есть очень много реализаций. Самым распространённым из
используемых субинтерфейсов, реализующих интерфейс `Queue`, является интерфейс `Deque` (двусторонняя очередь).  
Двусторонняя очередь `Deque` расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и
конец очереди) и забирать элементы с обоих краев очереди.

![3.png](/pictures/3.png)

Структуры данных в Java, как и в других объектно-ориентированных языках, хранят примитивы и объекты.  
[Примитивы](/conspect/1.md/#112-типизация-переменных) содержат в себе одно значение и не более, за счёт этого они имеют
заранее известный фиксированный размер, интервал допустимых значений и работать с ними быстро и легко.  
[Объекты](/conspect/1.md/#191-объекты) могут хранить в себе как какие-то данные (в виде полей), так и методы по работе с
ними. Java не может заранее знать размер объекта, ведь объекты созданных типов могут создаваться и во время исполнения
программы. Потому была придумана система ссылок.

> Ссылка на объект всегда весит 64 бита (для 64-битных систем, которых сейчас абсолютное большинство).

Каждая ссылка ведёт на область в памяти, где лежит объект.

То есть, переменные примитивных типов хранят в себе само значение, а переменные ссылочных типов хранят в себе ссылку на
область памяти, в которой хранится значение объекта.

> Всё в Java передается по значению.  
> В том числе значения переменных в методы. При попадании в метод сущность копирует то, что хранится в ней, свое
> значение. А для объектов значение переменной - это ссылка на объект.

Все объекты имеют значение по умолчанию `null`, которое представляет собой пустоту.  
Примитивы не могут иметь значение `null`, только объекты.  
`null` не является реализацией объекта, потому любая попытка запросить у пустой переменной (`null`) какие-то данные или
вызвать ее методы приведет к выбросу ошибки (_NullPointerException_ или _NPE_).

### 2.1.1 Стек (Stack)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Стек (Stack)**](/conspect/definitions.md/#s) - это массив, который состоит из ячеек, имеет определенный размер (
количество ячеек) и предоставляет быстрый доступ к своим элементам, так как структурирован и обращение к актуальной
ячейке происходит за константное время.
Этот массив хранит сущности, которые называются _Frame_. Каждый раз, когда вызывается новый метод, в стеке создается
новый фрейм. Как только метод заканчивает выполнение, фрейм удаляется из стека.  
Следовательно, первым фреймом в стеке создается фрейм метода `main`, а затем, когда метод `main` вызывает какой-то
метод, в стеке создается фрейм этого метода и существует до тех пор, пока Java не закончит выполнять код внутри этого
метода.

Примитивы, так как они хранит в себе значение, помещаются во фрейм полностью.  
В случае с объектами во фрейм помещаются только ссылки на объекты, а сами объекты хранятся в куче (_Heap_).

В тот момент, когда память стека заканчивается (количество элементов вышло за границы допустимых для Java-приложения),
приложение будет завершено ошибкой _StackOverflowError_.

> Так как Java позволяет нам писать многопоточные приложения, которые могут вызывать методы параллельно друг другу,
> каждый поток имеет свой собственный стек.  
> Так main-поток имеет в качестве первого фрейма метод `main()`.  
> Другие потоки в качестве первого фрейма имеют тот метод, который был первый выполнен. Обычно это метод `run()`.

### 2.1.2 Куча (Heap)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Куча (Heap)**](/conspect/definitions.md/#h) - это место в памяти, где хранятся объекты.  
Когда создаётся объект через ключевое слово `new`, в куче выделяется место для хранения этого самого объекта.

Куча, в отличие от стека, сама очищать себя не может, потому этим занимается специальная сопрограмма, которая называется
«сборщик мусора» (_garbage collector_), а сам процесс, как ни странно, называется «сборка мусора» (_garbage
collection_).  
Этот процесс анализирует объекты на актуальность и, если приходит к выводу, что объект больше не нужен, удаляет его.  
При переполнении кучи приложение выбрасывает ошибку _OutOfMemoryError_ и завершает работу.

Куча делится на несколько частей. Они созданы для оптимизации сборки мусора:

- два поколения:
    - старое (_Old Generation_);
    - новое (_New Generation_);
- метапространство (_Metaspace_).

![4.png](/pictures/4.png)

Все объекты создаются в новом поколении, и в тот момент, когда эти объекты «переживают» несколько сборок мусора, они
переводятся в старое поколение.  
Метапространство (ранее до 8-й версии Java называлось _Permanent Generation_) хранит в себе метаинформацию о классах, на
основе которых создаются объекты в куче, и статические данные приложения.

### 2.1.3 Сборка мусора (Garbage Collection)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Сборщик мусора (Garbage Collection)**](/conspect/definitions.md/#g) - это инструмент, который находит все объекты в
коде, недоступные для программиста, и удаляет их.  
В программировании часто используются два подхода для реализации сборки мусора:

- подсчёт ссылок;
- трассировка.

Подсчет ссылок подразумевает, что на каждом объекте есть условный счетчик ссылок. Когда на объект создается новая
ссылка, счетчик увеличивается. Когда ссылка отрабатывает свою задачу и перестает быть актуальной, счетчик уменьшается.
При достижении нуля объект помечается мусором и удаляется.

Трассировка встречается чаще, и ее идея построена на том, что в определенный момент мы начинаем идти по коду и искать,
какие объекты еще являются достижимыми в коде дальше. То есть в какой-то момент времени в дальнейшем приложение
обратится к нашему объекту. Эти объекты остаются «жить».

Сборка мусора представляет собой процесс, когда Java анализирует кучу на предмет «мертвых» объектов и удаляет их.  
Именно трассировка и используется в Java. Хотя этот подход и является более сложным и ресурсоёмким, он обеспечивает
большую надежность.  
Процесс трассировки делится на два этапа:

- Mark (маркировка) - сборщик мусора отмечает недостижимые объекты в качестве мусора;
- Sweep (уборка) - объекты, отмеченные мусором на прошлой стадии, удаляются, освобождая место в куче.

В Java существует несколько реализаций сборщиков мусора.  
Какой из них запускать, выбирает разработчик с помощью специального флага при запуске приложения.

#### 2.1.3.1 Serial GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данный сборщик мусора является классической и самой простой реализацией. _Serial GC_ использует один поток и отлично
подходит для работы в приложениях на клиентской стороне (пользовательские ПК), где нет жестких требований к минимизации
остановок приложения и ресурсы ограничены.

#### 2.1.3.2 Parallel GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Отличается от _Serial GC_ использованием нескольких потоков, но также останавливает приложение в ходе сборки мусора.  
Является выбором по умолчанию во многих JVM.

#### 2.1.3.3 CMS (Concurrent Mark Sweep) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация делит ресурсы с приложением, замедляя его работу, но позволяет минимизировать остановки приложения во
время сборки мусора.  
В 9-й версии Java был помечен устаревшим и в 14-й полностью удален.

#### 2.1.3.4 G1 (Garbage First) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация пришла на смену _CMS_. Отличия в том, что данный сборщик мусора делит кучу на равные части и маркирует
их на предмет общей «жизнеспособности». На фазе сборки мусора в первую очередь очищаются наиболее заполненные области,
освобождая максимальный объем памяти.

### 2.1.4 Жизненный цикл приложения

> [[_оглавление_]](../README.md/#21-память-в-java)

Первым делом происходит сборка проекта.  
В этот момент **IDEA** подтягивает все указанные вами зависимости, затем производит процесс компиляции вашего кода.  
На этом моменте компилятор Java производит анализ кода, оптимизирует его и транслирует из того кода на английском языке,
что вы пишете в файлах Java, в байт-код, который уже достаточно тяжело читать человеку, и сохраняет его в файлы формата
_class_.  
Если компилятор находит ошибку в коде (например, вы где-то пропустили), компиляция останавливается, и вы видите много
красного текста в вашей консоли.
Обычно там указывается текст ошибки и строка файла, где эта ошибка была найдена.
**IDEA** подсвечивает эту строку синим, делая ее ссылкой, по нажатию на которую можно перейти в то место, где была
ошибка.
В тот момент, когда все необходимые файлы формата _class_ сформированы, а формируются они в таком соотношении: 1
Java-файл преобразуется в 1 class-файл — **JVM** получает возможность запустить ваш код.

[**JVM (Java Virtual Machine)**](/conspect/definitions.md/#j) в упрощенном представлении является программой, которая
читает этот самый байт-код и транслирует его в машинные инструкции, которые уже понимает процессор.  
Именно за счет **JVM** у приложений на Java появилась одна из киллер фич, а именно: мультиплатформенность. Компилятор
может быть один, его задача — сформировать на основе Java-кода байт-код и записать его в class-файлы.  
Ответственность за запуск приложения ложится на JVM, которые уникальны для каждого типа систем (_Windows_, _Linux_,
_Android_, _iOS_, умный дом), ведь их архитектура отличается.  
Если вы хотите, чтобы ваш код выполнялся на абсолютно новой системе, вам необходимо написать реализацию **JVM** под эту
новую систему (будь это умная лампочка, кофеварка или холодильник), и Java-приложения будут запускаться на этой системе.

Если суммировать, то **JVM** отвечает за запуск вашего приложения. Она управляет памятью, управляет (просит операционную
систему) созданием потоков для многопоточных приложений, осуществляет сборку мусора и так далее.

Так как передавать сотни и сотни class-файлов было бы накладным и неудобным, их принято объединять в архивы в формате
_jar_, где в конфигурации прописан класс с методом `main`, который запускает приложение.  
Этот архив тоже запускается с помощью **JVM**.

## 2.2 Объектно-ориентированное программирование (ООП)

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Объектно-ориентированный подход (ООП)**](/conspect/definitions.md/#о) - это построение приложений в виде множества
различных объектов (каждый из них является реализацией какого-либо класса), которые взаимодействуют друг с другом.
Причем любой объект может реализовывать не просто какой-то конкретный класс, а целую иерархию унаследованных друг от
друга классов, каждый из которых внес частичку себя в общее целое.  
У объектов могут быть свойства.  
[**Свойства объектов**](/conspect/definitions.md/#с) - это переменные, привязанные к объекту.

Принципы ООП:

- инкапсуляция;
- наследование;
- полиморфизм;
- абстракция.

### 2.2.1 Инкапсуляция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

Инкапсуляция является одним из принципов ООП.  
[**Инкапсуляция**](/conspect/definitions.md/#и) — это принцип ООП, согласно которого мы не даем прямой доступ к
свойствам объекта, а получаем их значения через методы.

Для реализации принципа инкапсуляции существуют [модификаторы доступа](/conspect/1.md/#181-модификаторы-доступа).

![5.png](/pictures/5.png)

Пользователь не должен иметь доступ к методам, которые ему не положено вызывать, или к полям, которые ему запрещено
читать или даже изменять. Пользователь должен работать только с тем, что ему нужно.

### 2.2.2 Наследование

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Наследование**](/conspect/definitions.md/#н) - это принцип ООП, согласно которого можно создавать новый класс на
основе существующего. При этом класс-наследник заимствует все свойства и функциональность родительского класса.

![6.png](/pictures/6.png)

Для реализации принципа наследования в Java используется ключевое слово `extends`.

> [**extends**](/conspect/definitions.md/#e) – это ключевое слово, которое применяется для обозначения того, что данный
> класс является наследником другого класса и расширяет свойства и функциональность класса-родителя.

Следует знать, что `private`-члены класса (поля и методы) не наследуются. Это значит, что ими будет управлять родитель,
но доступа к ним из наследника не будет.  
Если влезть в реализацию этого механизма, то Java неявно подкладывает объект класса-родителя в ваш объект и присваивает
его переменной `super` (по аналогии с `this`, которая ссылается на ваш текущий объект).  
А по переменной `super`, соответственно, можно вызвать конструктор родителя.

[**super**](/conspect/definitions.md/#s) - это переменная, которая всегда ссылается на конкретный объект родительского
класса.  
Ключевое слово `super` используется для того, чтобы явно показать, к какому конкретно конструктору родительского класса
мы обращаемся.  
При использовании ключевого слова `super` вызывается конструктор по умолчанию родительского класса.

Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст
сообщение об ошибке. Из чего следует, что в одном конструкторе для поля _с одним и тем же именем_ не может быть
одновременно и `this`, и `super`.

Пример использования:

```java
public class Person {
    private String name;
    private String surname;
    private int age;

    public Person(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name) && Objects.equals(surname, person.surname);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname, age);
    }

    @Override
    public String toString() {
        return "Person[" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", age=" + age +
                ']';
    }
}
```

```java
public class Worker extends Person {
    private static int counter = 1;
    private final int id;
    private String position;

    public Worker(String name, String surname, int age, String position) {
        super(name, surname, age);
        this.position = position;
        this.id = counter++;
    }

    public int getId() {
        return id;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Worker worker = (Worker) o;
        return id == worker.id && Objects.equals(position, worker.position);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), id, position);
    }

    @Override
    public String toString() {
        return "Worker[" +
                "id=" + id +
                ", person=" + super.toString() +
                ", position='" + position + '\'' +
                ']';
    }
}
```

```java
private static void inheritanceExample() {
    Person ivan = new Person("Ivan", "Ivanov", 21);
    Worker petr = new Worker("Petr", "Petrov", 22, "programmer");
    Worker fedor = new Worker("Fedor", "Fedorov", 23, "manager");
    Worker sidor = new Worker("Sidor", "Sidorov", 25, "manager");
    System.out.println(ivan);
    System.out.println(petr);
    System.out.println(fedor);
    System.out.println(sidor);
    sidor.setPosition("commercial director");
    System.out.println(sidor);
}
```

Если вдруг наследники должны иметь внутри себя логику по работе с содержимым полей родителя, то эти поля (или методы)
должны быть помечены модификаторами `default` (отсутствует модификатор, если родитель и наследник лежат в одном пакете)
или `protected`.

### 2.2.3 Полиморфизм

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Полиморфизм**](/conspect/definitions.md/#п) - это принцип ООП, согласно которого можно работать со многими классами,
как с одним, при условии, что все эти классы имеют одного базового предка; способность предоставлять один и тот же
интерфейс для различных базовых форм (типов данных).  
Это означает, что классы, имеющие различную функциональность, совместно используют один и тот же интерфейс и могут быть
динамически вызваны передачей параметров по ссылке.  
Процесс, применяемый объектно-ориентированными языками программирования для реализации динамического полиморфизма,
называется [**динамическим связыванием**](/conspect/definitions.md/#д).

![7.png](/pictures/7.png)

При использовании принципа полиморфизма необходимо учитывать следующее:

- любой прямой или косвенный наследник класса может быть использован в качестве экземпляра своего родителя;
- за набор полей и методов отвечает тип (класс) ссылки предка;
- за код, который выполняется при вызове этих методов (то, что после `=`), отвечает уже реализация (класс наследника);
- наследование должно быть только от одного класса.

> **_!!! Множественное наследование в Java запрещено !!!_**

### 2.2.4 Абстракция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстракция**](/conspect/definitions.md/#а) – это принцип ООП, согласно которому при проектировании классов и создании
объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные; процесс сокрытия деталей
реализации от пользователя, предоставляя ему только функционал (интерфейс).  
Иными словами, пользователь будет владеть информацией о том, что объект делает, а не как он это делает.  
В Java абстракция достигается с использованием абстрактных классов и интерфейсов.

#### 2.2.4.1 Абстрактные классы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстрактный класс**](/conspect/definitions.md/#а) - это класс, который не может быть использован для создания
объектов.  
Вместо создания объектов абстрактный класс служит как базовый элемент для других классов.

Для создания абстрактного класса в Java используется ключевое слово `abstract`.

> [**abstract**](/conspect/definitions.md/#a) - это ключевое слово, которое применяется для создания абстрактных классов
> и методов.

Абстрактный класс может содержать и абстрактные и конкретные методы. Классы, которые наследуют от абстрактного класса,
должны реализовывать все его абстрактные методы. Если хоть один метод в классе объявлен абстрактным, весь класс должен
так же быть объявлен абстрактным. Тем не менее, в обратную сторону правило не обязано соблюдаться. Если класс объявлен
абстрактным, он может и не содержать абстрактные методы.

[**Абстрактный метод**](/conspect/definitions.md/#а) - это метод, который всего лишь определяет свои сигнатуры и не
обеспечивает реализацию.

Абстрактные классы рекомендуется применять в следующих случаях:

- необходимо поделиться кодом между несколькими тесно связанными классами;
- классы, которые расширяют абстрактный класс, имеют много общих методов или полей, или требуют других модификаторов
  доступа, кроме `public` (например, `protected` и `private`);
- необходимо объявить нестатические или не-final поля, что позволяет определять методы, которые могут получить доступ и
  изменить состояние объекта, которому они принадлежат.

#### 2.2.4.2 Интерфейсы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Интерфейс**](/conspect/definitions.md/#и) - это конструкция языка Java, в рамках которой принято описывать
абстрактные публичные (`abstract public`) методы и статические константы (`final static`).  
Интерфейсы создаются по аналогии с классами, но с помощью ключевого слова `interface`, а не `class`.

> [**interface**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для создания интерфейсов.

Свойства интерфейса:

- содержит только абстрактные методы (слово `abstract` писать не нужно);
- у интерфейсов все методы `public`;
- может наследоваться только от интерфейсов;
- в Java есть множественное наследование интерфейсов (родителей у интерфейса может быть много);
- класс может реализовывать несколько интерфейсов (и наследоваться только от одного класса);

> [**implements**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для обозначения того, что
> данный класс реализует какой-либо интерфейс.

- в интерфейсах нельзя объявлять переменные, кроме статических.

Начиная с Java 8, в интерфейсах можно создавать методы по умолчанию с использованием ключевого слова `default`.

> [**default**](/conspect/definitions.md/#d) - это ключевое слово, которое применяется для создания методов по
> умолчанию.

К примеру:

```java
public interface Swimmable {

    public default void swim() {
        System.out.println("Плыви!");
    }

    public void eat();

    public void run();
}
```

Во всех классах, имплементирующих интерфейс _Swimmable_, необходимо будет переопределять методы _eat()_ и _run()_, а для
метода _swim()_ этого делать будет не обязательно (но может быть), так как его реализация во всех классах будет
одинаковой.

Интерфейсы рекомендуется применять в следующих случаях:

- интерфейс будут реализовывать несвязанные классы;
- необходимо определить поведение конкретного типа данных, при этом не важно, кто его реализует;
- необходимо использовать множественное наследование.

#### 2.2.4.3 Различия между абстрактным классом и интерфейсом:

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

- интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (
  кроме `public static final`), в то время как у абстрактного класса они могут быть;
- абстрактный класс наследуется (`extends`), а интерфейс — реализуется (`implements`): можно наследовать только один
  класс, а реализовать интерфейсов — сколько угодно (интерфейс может наследовать (`extends`) другой
  интерфейс/интерфейсы);
- абстрактные классы используются, когда есть отношение _"is-a"_, то есть класс-наследник расширяет базовый абстрактный
  класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом;
- методы и члены абстрактного класса могут быть обозначены любым модификатором доступа, в свою очередь все методы
  интерфейса обязаны быть открытыми (`public`);
- когда происходит наследование абстрактного класса, класс-наследник должен определить абстрактные методы, в то время
  как интерфейс может наследовать другой интерфейс и при этом не обязательно определять его методы;
- класс-наследник может расширять только один абстрактный класс, а интерфейс может расширять или класс может
  реализовывать множество других интерфейсов;
- класс-наследник может определять абстрактные методы с тем же или менее ограниченным модификатором доступа, при этом
  класс, реализующий интерфейс, должен определять методы с тем же уровнем видимости;
- интерфейс не содержит конструкторы, в том время, как они есть в абстрактном классе;
- переменные, объявленные в интерфейсе по умолчанию являются `final`, абстрактный класс может содержать переменные,
  которые не являются `final`;
- все участники интерфейса по умолчанию являются `public`, а участники абстрактного класса могут позволить себе
  быть `public`, `protected` и др.

## 2.3 MVC

> [[_оглавление_]](../README.md/#23-mvc)

[**MVC (Model-View-Controller)**](/conspect/definitions.md/#m) - это Модель-Представление-Контроллер; архитектурный
шаблон проектирования, который предполагает разделение данных приложения, пользовательского интерфейса и управляющей
логики на три отдельных компонента: Модель, Представление и Контроллер – таким образом, что модификация каждого
компонента может осуществляться независимо.

![10.png](/pictures/10.png)

Этот шаблон делит web-приложение на три логические части:

- Controller - сущность, которая получает запрос и обрабатывает его (контроллер обращается к определенным классам и
  запрашивает у них данные);
- Model - модель данных, которую эти самые классы контроллеру предоставляют (обычно хранится в базе данных);
- View — то, что видит пользователь (контроллер конвертирует данные из Model и возвращает их в виде web-страницы
  или `JSON`/`XML`).

## 2.4 Системы сборки

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Система сборки**](/conspect/definitions.md/#с) - это программное обеспечение, обеспечивающее автоматизацию сборки
проекта. Основное отличие от _IDE_ в том, что конфигурационный файл для системы сборки описывается в текстовом виде. Как
следствие, проект может быть начат быстрее, за счет того, что все типовые задачи заключаются в копировании уже готовых
сниппетов (фрагментов исходного текста или кода программы).

### 2.4.1 Maven

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Apache Maven**](/conspect/definitions.md/#m) - это фреймворк для автоматизации сборки проектов на основе описания их
структуры в файлах _POM_ (Project Object Model) в формате _XML_.

![11.jpg](/pictures/11.jpg)

Конфигурирование _Maven_ производится в файле _pom.xml_.

Структура типового конфигурационного файла _pom.xml_ выглядит следующим образом:

```xml
<!-- 1 -->
<!-- Служебный фрагмент кода, в котором описывается кодировка XML документа и заголовок проекта, -->
<!-- а так же указывается версия используемой объектной модели для файла -->
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!-- 2 -->
    <!-- Фрагмент кода, который отвечает за подключение родительского pom.xml, где указаны версии всех -->
    <!-- библиотек, которые соответствуют текущей версии Spring Boot -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.1</version>
        <relativePath/>
    </parent>
    <!-- 3 -->
    <!-- Фрагмент кода, который хранит в себе информацию о проекте: -->
    <!-- groupId - группа проекта (проекты одного автора имеют один и тот же groupId, например - com.companyname) -->
    <!-- artifactId - уникальное имя проекта внутри группы groupId -->
    <!-- version - текущая версия проекта -->
    <!-- name - человекочитаемое имя проекта (может отличаться от artifactId и может содержать пробелы) -->
    <!-- description - описание проекта для человека который будет читать данный pom.xml -->
    <groupId>pro.sky</groupId>
    <artifactId>counter-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Counter Service</name>
    <description>Counter service that counts amount of requests to page</description>
    <!-- 4 -->
    <!-- Фрагмент кода, который хранит в себе значения таких переменных, как версии библиотек, версии Java. -->
    <!-- Блок </properties> является необязательным -->
    <properties>
        <java.version>17</java.version>
    </properties>
    <!-- 5 -->
    <!-- Блок кода, содержащий необходимые зависимости -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope> <!-- Скоуп для данной библиотеки -->
        </dependency>
    </dependencies>

    <!-- 6 -->
    <!-- Блок кода, содержащий плагины -->
    <!-- В данном случае указан плагин, который собирает финальный JAR архив с приложением -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

Особенности _Maven_:

- наличие чёткой структуры каталогов (которую автоматически создаёт _IDE_ при создании проекта):
    - в _src/main/java_ содержатся java-классы;
    - в _src/main/resources_ - ресурсы, которые использует приложение (HTML-страницы, картинки, таблицы стилей и тд);
    - в _src/test_ содержатся тесты;

> Также у каждого проекта может быть только один файл JAR-файл

- автоматическое управление зависимостями (скачивание, распаковка, подключение и контроль версий);
- стандартизированное название билдов (каждый имеет атрибуты _groupId_, _artifactId_ и _version_);
- наличие фаз жизненного цикла проекта:
    - _clean_ - удаляются все скомпилированные файлы из каталога _target_ (место, в котором сохраняются готовые
      артефакты);
    - _validate_ - идёт проверка, вся ли информация доступна для сборки проекта;
    - _compile_ - компилируются файлы с исходным кодом;
    - _test_ - запускаются тесты;
    - _package_ - упаковываются скомпилированные файлы (в jar-, war- и т.д. архив);
    - _verify_ - выполняются проверки для подтверждения готовности упакованного файла;
    - _install_ - пакет помещается в локальный репозиторий. (после чего он может использоваться другими проектами как
      внешняя библиотека);
    - _site_ - создается документация проекта;
    - _deploy_ - собранный архив копируется в удаленный репозиторий.

> Все фазы выполняются последовательно: нельзя запустить последующую без запуска предыдущей.

Запуск фаз возможен посредством _IDE_ или через терминал:

```text
mvn clean
```

> Фазу _clean_ желательно вызывать перед каждой новой сборкой проекта.

У каждой фазы есть цели (goal). Стандартные цели заложены по умолчанию, дополнительные добавляются Maven-плагинами.  
[Список официальных плагинов](https://maven.apache.org/plugins/) можно посмотреть на официальном сайте _Maven_.  
Чтобы добавить Maven-плагин в проект, его описание, аналогично зависимостям, нужно поместить в _pom.xml_ в
теги `<build>` и `<plugins>`.

### 2.4.2 Gradle

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Gradle**](/conspect/definitions.md/#g) - это система для автоматизации сборки приложений и сбора статистики об
использовании программных библиотек, применяющая языки **Android**, **Java**, **Kotlin**, **Groovy**, **Scala**,
**Javascript** и **C/C++**, а также решения из фреймворков _Apache Ant_ и _Apache Maven_.  
_Gradle_ основан на графе задач (_task_), которые предоставляются различными плагинами и могут зависеть друг от друга.
Задачи выполняют какую-то работу. _Maven_ же использует модель определённых фаз (_phase_), к которым присоединяются
определённые "цели" (_goals_). В этих _goals_ и выполняется какая-то работа.

![12.png](/pictures/12.png)

Конфигурирование _Gradle_ производится в файле _build.gradle_.

Типы плагинов:

- _бинарные плагины_ - это скомпилированные плагины, обычно написанные на Java или Kotlin DSL и упакованные в файлы
  JAR (применяются к проекту с помощью блока `plugins {}`);
- _предварительно скомпилированные скриптовые плагины_ - это скрипты Groovy DSL или Kotlin DSL, скомпилированные и
  распространяемые как файлы классов Java, упакованные в библиотеку (применяются к проекту с помощью
  блока `plugins {}`);
- _скриптованные плагины_ - это скрипты Groovy DSL или Kotlin DSL, которые применяются непосредственно к скрипту сборки
  Gradle с использованием синтаксиса `apply from:` (применяются в строке внутри скрипта сборки для добавления
  функциональности или настройки процесса сборки).

Чтобы использовать логику сборки, инкапсулированную в плагин, _Gradle_ необходимо выполнить два шага: разрешить плагин,
а затем применить его к цели (обычно к _Project_).

![13.png](/pictures/13.png)

Первое отличие _Gradle_ от _Maven_ заключается в наличии _Gradle Wrapper_ (или просто _Wrapper_), специального скрипта
(а также несколько дополнительных файлов), который вызывает объявленную версию _Gradle_, при необходимости загружая ее
заранее. Конфигурирование _Wrapper_ производится в файле _gradle/wrapper/gradle-wrapper.properties_.  
Стартер _Gradle_ при условии наличия нескольких модулей в проекте можно отредактировать в файле _settings.gradle_.

Структура типового конфигурационного файла _build.gradle_ выглядит следующим образом:

```groovy
// Блок, содержащий используемые плагины
plugins {
    // Основные плагины, для которого достаточно указать только id
    id 'java'
    // Бинарные плагины, для которых обязательно необходимо указывать версию
    id 'org.springframework.boot' version '3.4.0-SNAPSHOT'
    id 'io.spring.dependency-management' version '1.1.6'
}

// Блок, содержащий текущие группу и версию
group = 'com.example'
version = '0.0.1-SNAPSHOT'

// Блок конфигурации плагина java
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

// Блок конфигураций данного проекта
configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

// Блок репозиториев, содержащих необходимые зависимости
repositories {
    // Репозиторий по умолчанию Maven
    mavenCentral()
    maven { url 'https://repo.spring.io/milestone' }
    maven { url 'https://repo.spring.io/snapshot' }
}

// Блок зависимостей
// implementation - зависимости, необходимые на этапе компиляции проекта и во время его выполнения
// compileOnly - зависимости, необходимые только на этапе компиляции проекта
// compileClasspath - содержит путь к зависимостям, необходимым для компиляции проекта
// annotationProcessor - зависимости, которые являются процессорами аннотаций (используются во время компиляции для обработки аннотаций)
// runtimeOnly - зависимости, которые необходимы только на этапе выполнения
// runtimeClasspath - содержит путь к зависимостям, необходимым для выполнения проекта
// testImplementation - зависимости, необходимые на этапе компиляции тестового кода и во время его выполнения
// testCompileOnly - зависимости, необходимые только на этапе компиляции тестового кода
// testRuntimeOnly - зависимости, которые необходимы только на этапе выполнения тестового кода
// testCompileClasspath - содержит путь к зависимостям, необходимым для компиляции тестового кода
// testRuntimeClasspath - содержит путь к зависимостям, необходимым для выполнения тестового кода
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.liquibase:liquibase-core'
    compileOnly 'org.projectlombok:lombok'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    developmentOnly 'org.springframework.boot:spring-boot-docker-compose'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

// Задача (task) по запуску всех тестов
tasks.named('test') {
    useJUnitPlatform()
}

```

Полный перечень возможных [настроек проекта](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html),
указываемых в _build.gradle_ можно найти на официальном сайте _Gradle_.

Настройка свойств _Gradle_ производится в файле _gradle.properties_ (зарезервированное
имя). [Перечень возможных настроек](https://docs.gradle.org/current/userguide/build_environment.html) можно найти на
официальном сайте _Gradle_.

_Gradle_ обладает теми же особенностями, коими обладает _Maven_, однако имеет ряд других особенностей:

- DSL (Domain Specific Language) конфига _Groovy_ (_Kotlin_), который менее громоздкий чем XML-конфиг _Maven_;
- менее громоздкая система плагинов;
- большая гибкость и расширяемость (возможность писать настройки для отдельных модулей приложения).

## 2.5 Исключения

> [[_оглавление_]](../README.md/#25-исключения)

[**Исключения (Exceptions)**](/conspect/definitions.md/#и) - это механизм, который позволяет программе обрабатывать
нетипичную ситуацию и при этом не прекращать работу.

### 2.5.1 Иерархия исключений

> [[_оглавление_]](../README.md/#25-исключения)

![14.png](/pictures/14.png)

Исключения имеют общего предка - класс _Throwable_. Его потомками являются подклассы _Exception_ и _Error_.  
_Исключения (Exceptions)_ являются результатом проблем в программе, которые в принципе решаемы и предсказуемы.  
_Ошибки (Errors)_ представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться
обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM.

Все исключения подразделяются на _проверяемые_ и _непроверяемые_.  
К непроверяемым исключениям относятся все ошибки (класс _Error_ и его потомки) и все исключения времени выполнения
(класс _RuntimeException_ и его потомки), к проверяемым - все остальные.

В коде можно создавать и выбрасывать свои исключения.

Синтаксис выброса исключений выглядит следующим образом:

```java
throw new RuntimeException();
```

> [**throw**](/conspect/definitions.md/#t) – это ключевое слово, которое применяется для выбрасывания исключений в коде.

При возникновении исключения в Java-коде модуль _Spring Web_ возвращает пользователю соответствующий HTTP-статус.

> [**Ссылка**](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) на список возможных HTTP-статусов.

Чтобы сообщить _Spring_, какой именно статус необходимо возвращать пользователю, используют аннотацию `@ResponseStatus`.

### 2.5.2 Обработка исключений

> [[_оглавление_]](../README.md/#25-исключения)

Когда проверяемое исключение не обрабатывается внутри того метода, где это исключение кидается, необходимо использовать
ключевое слово `throws` и указывать тип выбрасываемого проверяемого исключения.

Например:

```java
public static void check(File file) throws FileNotFoundException {
    if (!file.exists()) {
        throw new FileNotFoundException();
    }
    if (file.isDirectory()) {
        throw new IllegalArgumentException(file.getPath() + " is a directory");
    }
}
```

> [**throws**](/conspect/definitions.md/#t) – это ключевое слово, которое используется в объявлении метода для указания,
> что метод может выбрасывать проверяемые исключения.  
> При использовании ключевого слова `throws` проверка выбрасываемого исключения делегируется тому методу, который
> вызывает данный.

Обработка исключений в Java построена на конструкции _try-catch-finally_.

![15.png](/pictures/15.png)

> [**try**](/conspect/definitions.md/#t) – это ключевое слово, определяющее блок кода, в котором может произойти
> исключение.

> [**catch**](/conspect/definitions.md/#c) – это ключевое слово, определяющее блок кода, в котором происходит обработка
> исключения.

> [**finally**](/conspect/definitions.md/#f) – это ключевое слово, определяющее блок кода, который является
> необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока `try`.  
> Блок `finally` иерархически выше блока `try`. Это означает, что если оба блока будут содержать оператор `return`, то
> выполнится тот, который содержится в блоке `finally`.

Конструкция _try-catch-finally_ выглядит следующим образом:

```java
try([создание_какого-либо_ресурса])
        {
        // код, в котором может возникнуть исключение
        }
        catch([тип_ошибки][имя_переменной])
        {
        // действия по обработке исключения
        }
        finally
        {
        // код, выполняемый в любом случае
        }
```

Блоки `catch` могут объединяться в цепочки, а также отвечать за обработку нескольких типов исключений. В последнем
случае типы обрабатываемых исключений указываются через вертикальную черту (`|`).

Например:

```java
private static void tryCatchFinallyExample() {
    try {
        File file = new File("pictures/16.png");
        System.out.println(Files.size(file.toPath()));
    } catch (NoSuchElementException e) {
        System.out.println("File not found!");
    } catch (IOException | ClassCastException e) {
        System.out.println("Internal error!");
    } finally {
        System.out.println("The end");
    }
}
```
> [[_Примеры использования_]](/conspect/example_1.md/#пример-1)

Блоки `catch` анализируются по очереди. И если указать родительское исключение раньше, чем его наследника, то будет
вызван код из первого совпавшего блока, а не из более узкоспециализированного, но написанного после.

Блок `try` также применяется в многопоточных приложениях для того, чтобы гарантированно закрывать открываемые в процессе
выполнения потоки.

### 2.5.3 Написание своих исключений

> [[_оглавление_]](../README.md/#25-исключения)

Исключение представляет собой обычный класс, не имеющий собственных методов, наследующийся от _Exception_ или от
_RuntimeException_ и вызывающий соответствующий конструктор родителя.

Например:

```java
import java.io.IOException;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class FileIsDirectoryException extends IOException {
    public FileIsDirectoryException() {
        super();
    }

    public FileIsDirectoryException(String message) {
        super(message);
    }

    public FileIsDirectoryException(String message, Throwable t) {
        super(message, t);
    }

    public FileIsDirectoryException(Throwable t) {
        super(t);
    }
}
```

После создания свои исключения могут использоваться точно также как и библиотечные исключения Java с использованием
ключевого слова `throw`.

## 2.6 Коллекции

> [[_оглавление_]](../README.md/#26-коллекции)

[**Коллекция (Collection)**](/conspect/definitions.md/#к) - это контейнер, содержащий в себе ряд однородных элементов
одного типа и позволяющий обращаться к значениям этих элементов и производить над ними какие-либо операции.

![16.png](/pictures/16.png)

### 2.6.1 Класс Collection

> [[_оглавление_]](../README.md/#26-коллекции)

