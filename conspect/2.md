# 2 Java Core

> [[_оглавление_]](../README.md/#2-java-core)

## 2.1 Память в Java

> [[_оглавление_]](../README.md/#21-память-в-java)

Все данные <u>_вне зависимости от используемого языка программирования_</u> хранятся в виде структур данных.  
[**Структура данных**](/conspect/definitions.md/#с) - это программная единица, позволяющая хранить и обрабатывать
множество однотипных и/или логически связанных данных в вычислительной технике.  
Структур данных существует огромное множество. Самыми популярными из них являются:

- связный список;
- ассоциативный массив;
- стек;
- очередь.

[**Связный список**](/conspect/definitions.md/#с) - это базовая динамическая структура данных в информатике, состоящая
из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или
предыдущий узел списка.  
В Java структура данных связный список реализован в классе `Linkedlist`.

[**Ассоциативный массив**](/conspect/definitions.md/#а) - это абстрактный тип данных (интерфейс к хранилищу данных),
позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления
пары по ключу.  
В Java структура данных ассоциативный массив реализован в классе `Map`.

[**Стек (Stack)**](/conspect/definitions.md/#с) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого *
*вершиной стека**.  
В стеке реализован принцип _LIFO_.  
[**LIFO (last-in, first-out)**](/conspect/definitions.md/#l) - это принцип, при котором первым удаляется элемент,
который был помещен туда последним («последним вошел — первым вышел»).

![1.jpeg](/pictures/1.jpeg)

В Java структура данных ассоциативный массив реализован в классе `java.util.Stack`.

[**Очередь (Queue)**](/conspect/definitions.md/#q) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов производится в конец, называемый **хвостом очереди**, а удаление
существующих производится с другого конца, называемого **головой очереди**.  
В очереди реализован принцип _FIFO_.  
[**FIFO (first-in, first-out)**](/conspect/definitions.md/#f) - это принцип, при котором первым удаляется элемент,
который был помещен туда первым («первым вошел — первым вышел»).

![2.png](/pictures/2.png)

В Java структура данных очередь представлена не классом, а интерфейсом - `Queue`.  
Но вместе с тем, очередь в Java - это интерфейс, у которого есть очень много реализаций. Самым распространённым из
используемых субинтерфейсов, реализующих интерфейс `Queue`, является интерфейс `Deque` (двусторонняя очередь).  
Двусторонняя очередь `Deque` расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и
конец очереди) и забирать элементы с обоих краев очереди.

![3.png](/pictures/3.png)

Структуры данных в Java, как и в других объектно-ориентированных языках, хранят примитивы и объекты.  
[Примитивы](/conspect/1.md/#112-типизация-переменных) содержат в себе одно значение и не более, за счёт этого они имеют
заранее известный фиксированный размер, интервал допустимых значений и работать с ними быстро и легко.  
[Объекты](/conspect/1.md/#191-объекты) могут хранить в себе как какие-то данные (в виде полей), так и методы по работе с
ними. Java не может заранее знать размер объекта, ведь объекты созданных типов могут создаваться и во время исполнения
программы. Потому была придумана система ссылок.

> Ссылка на объект всегда весит 64 бита (для 64-битных систем, которых сейчас абсолютное большинство).

Каждая ссылка ведёт на область в памяти, где лежит объект.

То есть, переменные примитивных типов хранят в себе само значение, а переменные ссылочных типов хранят в себе ссылку на
область памяти, в которой хранится значение объекта.

> Всё в Java передается по значению.  
> В том числе значения переменных в методы. При попадании в метод сущность копирует то, что хранится в ней, свое
> значение. А для объектов значение переменной - это ссылка на объект.

Все объекты имеют значение по умолчанию `null`, которое представляет собой пустоту.  
Примитивы не могут иметь значение `null`, только объекты.  
`null` не является реализацией объекта, потому любая попытка запросить у пустой переменной (`null`) какие-то данные или
вызвать ее методы приведет к выбросу ошибки (_NullPointerException_ или _NPE_).

### 2.1.1 Стек (Stack)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Стек (Stack)**](/conspect/definitions.md/#s) - это массив, который состоит из ячеек, имеет определенный размер (
количество ячеек) и предоставляет быстрый доступ к своим элементам, так как структурирован и обращение к актуальной
ячейке происходит за константное время.
Этот массив хранит сущности, которые называются _Frame_. Каждый раз, когда вызывается новый метод, в стеке создается
новый фрейм. Как только метод заканчивает выполнение, фрейм удаляется из стека.  
Следовательно, первым фреймом в стеке создается фрейм метода `main`, а затем, когда метод `main` вызывает какой-то
метод, в стеке создается фрейм этого метода и существует до тех пор, пока Java не закончит выполнять код внутри этого
метода.

Примитивы, так как они хранит в себе значение, помещаются во фрейм полностью.  
В случае с объектами во фрейм помещаются только ссылки на объекты, а сами объекты хранятся в куче (_Heap_).

В тот момент, когда память стека заканчивается (количество элементов вышло за границы допустимых для Java-приложения),
приложение будет завершено ошибкой _StackOverflowError_.

> Так как Java позволяет нам писать многопоточные приложения, которые могут вызывать методы параллельно друг другу,
> каждый поток имеет свой собственный стек.  
> Так main-поток имеет в качестве первого фрейма метод `main()`.  
> Другие потоки в качестве первого фрейма имеют тот метод, который был первый выполнен. Обычно это метод `run()`.

### 2.1.2 Куча (Heap)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Куча (Heap)**](/conspect/definitions.md/#h) - это место в памяти, где хранятся объекты.  
Когда создаётся объект через ключевое слово `new`, в куче выделяется место для хранения этого самого объекта.

Куча, в отличие от стека, сама очищать себя не может, потому этим занимается специальная сопрограмма, которая называется
«сборщик мусора» (_garbage collector_), а сам процесс, как ни странно, называется «сборка мусора» (_garbage
collection_).  
Этот процесс анализирует объекты на актуальность и, если приходит к выводу, что объект больше не нужен, удаляет его.  
При переполнении кучи приложение выбрасывает ошибку _OutOfMemoryError_ и завершает работу.

Куча делится на несколько частей. Они созданы для оптимизации сборки мусора:

- два поколения:
    - старое (_Old Generation_);
    - новое (_New Generation_);
- метапространство (_Metaspace_).

![4.png](/pictures/4.png)

Все объекты создаются в новом поколении, и в тот момент, когда эти объекты «переживают» несколько сборок мусора, они
переводятся в старое поколение.  
Метапространство (ранее до 8-й версии Java называлось _Permanent Generation_) хранит в себе метаинформацию о классах, на
основе которых создаются объекты в куче, и статические данные приложения.

### 2.1.3 Сборка мусора (Garbage Collection)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Сборщик мусора (Garbage Collection)**](/conspect/definitions.md/#g) - это инструмент, который находит все объекты в
коде, недоступные для программиста, и удаляет их.  
В программировании часто используются два подхода для реализации сборки мусора:

- подсчёт ссылок;
- трассировка.

Подсчет ссылок подразумевает, что на каждом объекте есть условный счетчик ссылок. Когда на объект создается новая
ссылка, счетчик увеличивается. Когда ссылка отрабатывает свою задачу и перестает быть актуальной, счетчик уменьшается.
При достижении нуля объект помечается мусором и удаляется.

Трассировка встречается чаще, и ее идея построена на том, что в определенный момент мы начинаем идти по коду и искать,
какие объекты еще являются достижимыми в коде дальше. То есть в какой-то момент времени в дальнейшем приложение
обратится к нашему объекту. Эти объекты остаются «жить».

Сборка мусора представляет собой процесс, когда Java анализирует кучу на предмет «мертвых» объектов и удаляет их.  
Именно трассировка и используется в Java. Хотя этот подход и является более сложным и ресурсоёмким, он обеспечивает
большую надежность.  
Процесс трассировки делится на два этапа:

- Mark (маркировка) - сборщик мусора отмечает недостижимые объекты в качестве мусора;
- Sweep (уборка) - объекты, отмеченные мусором на прошлой стадии, удаляются, освобождая место в куче.

В Java существует несколько реализаций сборщиков мусора.  
Какой из них запускать, выбирает разработчик с помощью специального флага при запуске приложения.

#### 2.1.3.1 Serial GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данный сборщик мусора является классической и самой простой реализацией. _Serial GC_ использует один поток и отлично
подходит для работы в приложениях на клиентской стороне (пользовательские ПК), где нет жестких требований к минимизации
остановок приложения и ресурсы ограничены.

#### 2.1.3.2 Parallel GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Отличается от _Serial GC_ использованием нескольких потоков, но также останавливает приложение в ходе сборки мусора.  
Является выбором по умолчанию во многих JVM.

#### 2.1.3.3 CMS (Concurrent Mark Sweep) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация делит ресурсы с приложением, замедляя его работу, но позволяет минимизировать остановки приложения во
время сборки мусора.  
В 9-й версии Java был помечен устаревшим и в 14-й полностью удален.

#### 2.1.3.4 G1 (Garbage First) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация пришла на смену _CMS_. Отличия в том, что данный сборщик мусора делит кучу на равные части и маркирует
их на предмет общей «жизнеспособности». На фазе сборки мусора в первую очередь очищаются наиболее заполненные области,
освобождая максимальный объем памяти.

### 2.1.4 Жизненный цикл приложения

> [[_оглавление_]](../README.md/#21-память-в-java)

Первым делом происходит сборка проекта.  
В этот момент **IDEA** подтягивает все указанные вами зависимости, затем производит процесс компиляции вашего кода.  
На этом моменте компилятор Java производит анализ кода, оптимизирует его и транслирует из того кода на английском языке,
что вы пишете в файлах Java, в байт-код, который уже достаточно тяжело читать человеку, и сохраняет его в файлы формата
_class_.  
Если компилятор находит ошибку в коде (например, вы где-то пропустили), компиляция останавливается, и вы видите много
красного текста в вашей консоли.
Обычно там указывается текст ошибки и строка файла, где эта ошибка была найдена.
**IDEA** подсвечивает эту строку синим, делая ее ссылкой, по нажатию на которую можно перейти в то место, где была
ошибка.
В тот момент, когда все необходимые файлы формата _class_ сформированы, а формируются они в таком соотношении: 1
Java-файл преобразуется в 1 class-файл — **JVM** получает возможность запустить ваш код.

[**JVM (Java Virtual Machine)**](/conspect/definitions.md/#j) в упрощенном представлении является программой, которая
читает этот самый байт-код и транслирует его в машинные инструкции, которые уже понимает процессор.  
Именно за счет **JVM** у приложений на Java появилась одна из киллер фич, а именно: мультиплатформенность. Компилятор
может быть один, его задача — сформировать на основе Java-кода байт-код и записать его в class-файлы.  
Ответственность за запуск приложения ложится на JVM, которые уникальны для каждого типа систем (_Windows_, _Linux_,
_Android_, _iOS_, умный дом), ведь их архитектура отличается.  
Если вы хотите, чтобы ваш код выполнялся на абсолютно новой системе, вам необходимо написать реализацию **JVM** под эту
новую систему (будь это умная лампочка, кофеварка или холодильник), и Java-приложения будут запускаться на этой системе.

Если суммировать, то **JVM** отвечает за запуск вашего приложения. Она управляет памятью, управляет (просит операционную
систему) созданием потоков для многопоточных приложений, осуществляет сборку мусора и так далее.

Так как передавать сотни и сотни class-файлов было бы накладным и неудобным, их принято объединять в архивы в формате
_jar_, где в конфигурации прописан класс с методом `main`, который запускает приложение.  
Этот архив тоже запускается с помощью **JVM**.

## 2.2 Объектно-ориентированное программирование (ООП)

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Объектно-ориентированный подход (ООП)**](/conspect/definitions.md/#о) - это построение приложений в виде множества
различных объектов (каждый из них является реализацией какого-либо класса), которые взаимодействуют друг с другом.
Причем любой объект может реализовывать не просто какой-то конкретный класс, а целую иерархию унаследованных друг от
друга классов, каждый из которых внес частичку себя в общее целое.  
У объектов могут быть свойства.  
[**Свойства объектов**](/conspect/definitions.md/#с) - это переменные, привязанные к объекту.

Принципы ООП:

- инкапсуляция;
- наследование;
- полиморфизм;
- абстракция.

### 2.2.1 Инкапсуляция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

Инкапсуляция является одним из принципов ООП.  
[**Инкапсуляция**](/conspect/definitions.md/#и) — это принцип ООП, согласно которого мы не даем прямой доступ к
свойствам объекта, а получаем их значения через методы.

Для реализации принципа инкапсуляции существуют [модификаторы доступа](/conspect/1.md/#181-модификаторы-доступа).

![5.png](/pictures/5.png)

Пользователь не должен иметь доступ к методам, которые ему не положено вызывать, или к полям, которые ему запрещено
читать или даже изменять. Пользователь должен работать только с тем, что ему нужно.

### 2.2.2 Наследование

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Наследование**](/conspect/definitions.md/#н) - это принцип ООП, согласно которого можно создавать новый класс на
основе существующего. При этом класс-наследник заимствует все свойства и функциональность родительского класса.

![6.png](/pictures/6.png)

Для реализации принципа наследования в Java используется ключевое слово `extends`.

> [**extends**](/conspect/definitions.md/#e) – это ключевое слово, которое применяется для обозначения того, что данный
> класс является наследником другого класса и расширяет свойства и функциональность класса-родителя.

Следует знать, что `private`-члены класса (поля и методы) не наследуются. Это значит, что ими будет управлять родитель,
но доступа к ним из наследника не будет.  
Если влезть в реализацию этого механизма, то Java неявно подкладывает объект класса-родителя в ваш объект и присваивает
его переменной `super` (по аналогии с `this`, которая ссылается на ваш текущий объект).  
А по переменной `super`, соответственно, можно вызвать конструктор родителя.

[**super**](/conspect/definitions.md/#s) - это переменная, которая всегда ссылается на конкретный объект родительского
класса.  
Ключевое слово `super` используется для того, чтобы явно показать, к какому конкретно конструктору родительского класса
мы обращаемся.  
При использовании ключевого слова `super` вызывается конструктор по умолчанию родительского класса.

Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст
сообщение об ошибке. Из чего следует, что в одном конструкторе для поля _с одним и тем же именем_ не может быть
одновременно и `this`, и `super`.

Пример использования:

```java
public class Person {
    private String name;
    private String surname;
    private int age;

    public Person(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name) && Objects.equals(surname, person.surname);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname, age);
    }

    @Override
    public String toString() {
        return "Person[" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", age=" + age +
                ']';
    }
}
```

```java
public class Worker extends Person {
    private static int counter = 1;
    private final int id;
    private String position;

    public Worker(String name, String surname, int age, String position) {
        super(name, surname, age);
        this.position = position;
        this.id = counter++;
    }

    public int getId() {
        return id;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Worker worker = (Worker) o;
        return id == worker.id && Objects.equals(position, worker.position);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), id, position);
    }

    @Override
    public String toString() {
        return "Worker[" +
                "id=" + id +
                ", person=" + super.toString() +
                ", position='" + position + '\'' +
                ']';
    }
}
```

```java
private static void inheritanceExample() {
    Person ivan = new Person("Ivan", "Ivanov", 21);
    Worker petr = new Worker("Petr", "Petrov", 22, "programmer");
    Worker fedor = new Worker("Fedor", "Fedorov", 23, "manager");
    Worker sidor = new Worker("Sidor", "Sidorov", 25, "manager");
    System.out.println(ivan);
    System.out.println(petr);
    System.out.println(fedor);
    System.out.println(sidor);
    sidor.setPosition("commercial director");
    System.out.println(sidor);
}
```

Если вдруг наследники должны иметь внутри себя логику по работе с содержимым полей родителя, то эти поля (или методы)
должны быть помечены модификаторами `default` (отсутствует модификатор, если родитель и наследник лежат в одном пакете)
или `protected`.

### 2.2.3 Полиморфизм

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Полиморфизм**](/conspect/definitions.md/#п) - это принцип ООП, согласно которого можно работать со многими классами,
как с одним, при условии, что все эти классы имеют одного базового предка; способность предоставлять один и тот же
интерфейс для различных базовых форм (типов данных).  
Это означает, что классы, имеющие различную функциональность, совместно используют один и тот же интерфейс и могут быть
динамически вызваны передачей параметров по ссылке.  
Процесс, применяемый объектно-ориентированными языками программирования для реализации динамического полиморфизма,
называется [**динамическим связыванием**](/conspect/definitions.md/#д).

![7.png](/pictures/7.png)

При использовании принципа полиморфизма необходимо учитывать следующее:

- любой прямой или косвенный наследник класса может быть использован в качестве экземпляра своего родителя;
- за набор полей и методов отвечает тип (класс) ссылки предка;
- за код, который выполняется при вызове этих методов (то, что после `=`), отвечает уже реализация (класс наследника);
- наследование должно быть только от одного класса.

> **_!!! Множественное наследование в Java запрещено !!!_**

### 2.2.4 Абстракция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстракция**](/conspect/definitions.md/#а) – это принцип ООП, согласно которому при проектировании классов и создании
объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные; процесс сокрытия деталей
реализации от пользователя, предоставляя ему только функционал (интерфейс).  
Иными словами, пользователь будет владеть информацией о том, что объект делает, а не как он это делает.  
В Java абстракция достигается с использованием абстрактных классов и интерфейсов.

#### 2.2.4.1 Абстрактные классы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстрактный класс**](/conspect/definitions.md/#а) - это класс, который не может быть использован для создания
объектов.  
Вместо создания объектов абстрактный класс служит как базовый элемент для других классов.

Для создания абстрактного класса в Java используется ключевое слово `abstract`.

> [**abstract**](/conspect/definitions.md/#a) - это ключевое слово, которое применяется для создания абстрактных классов
> и методов.

Абстрактный класс может содержать и абстрактные и конкретные методы. Классы, которые наследуют от абстрактного класса,
должны реализовывать все его абстрактные методы. Если хоть один метод в классе объявлен абстрактным, весь класс должен
так же быть объявлен абстрактным. Тем не менее, в обратную сторону правило не обязано соблюдаться. Если класс объявлен
абстрактным, он может и не содержать абстрактные методы.

[**Абстрактный метод**](/conspect/definitions.md/#а) - это метод, который всего лишь определяет свои сигнатуры и не
обеспечивает реализацию.

Абстрактные классы рекомендуется применять в следующих случаях:

- необходимо поделиться кодом между несколькими тесно связанными классами;
- классы, которые расширяют абстрактный класс, имеют много общих методов или полей, или требуют других модификаторов
  доступа, кроме `public` (например, `protected` и `private`);
- необходимо объявить нестатические или не-final поля, что позволяет определять методы, которые могут получить доступ и
  изменить состояние объекта, которому они принадлежат.

#### 2.2.4.2 Интерфейсы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Интерфейс**](/conspect/definitions.md/#и) - это конструкция языка Java, в рамках которой принято описывать
абстрактные публичные (`abstract public`) методы и статические константы (`final static`).  
Интерфейсы создаются по аналогии с классами, но с помощью ключевого слова `interface`, а не `class`.

> [**interface**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для создания интерфейсов.

Свойства интерфейса:

- содержит только абстрактные методы (слово `abstract` писать не нужно);
- у интерфейсов все методы `public`;
- может наследоваться только от интерфейсов;
- в Java есть множественное наследование интерфейсов (родителей у интерфейса может быть много);
- класс может реализовывать несколько интерфейсов (и наследоваться только от одного класса);

> [**implements**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для обозначения того, что
> данный класс реализует какой-либо интерфейс.

- в интерфейсах нельзя объявлять переменные, кроме статических.

Начиная с Java 8, в интерфейсах можно создавать методы по умолчанию с использованием ключевого слова `default`.

> [**default**](/conspect/definitions.md/#d) - это ключевое слово, которое применяется для создания методов по
> умолчанию.

К примеру:

```java
public interface Swimmable {

    public default void swim() {
        System.out.println("Плыви!");
    }

    public void eat();

    public void run();
}
```

Во всех классах, имплементирующих интерфейс _Swimmable_, необходимо будет переопределять методы _eat()_ и _run()_, а для
метода _swim()_ этого делать будет не обязательно (но может быть), так как его реализация во всех классах будет
одинаковой.

Интерфейсы рекомендуется применять в следующих случаях:

- интерфейс будут реализовывать несвязанные классы;
- необходимо определить поведение конкретного типа данных, при этом не важно, кто его реализует;
- необходимо использовать множественное наследование.

#### 2.2.4.3 Различия между абстрактным классом и интерфейсом:

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

- интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (
  кроме `public static final`), в то время как у абстрактного класса они могут быть;
- абстрактный класс наследуется (`extends`), а интерфейс — реализуется (`implements`): можно наследовать только один
  класс, а реализовать интерфейсов — сколько угодно (интерфейс может наследовать (`extends`) другой
  интерфейс/интерфейсы);
- абстрактные классы используются, когда есть отношение _"is-a"_, то есть класс-наследник расширяет базовый абстрактный
  класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом;
- методы и члены абстрактного класса могут быть обозначены любым модификатором доступа, в свою очередь все методы
  интерфейса обязаны быть открытыми (`public`);
- когда происходит наследование абстрактного класса, класс-наследник должен определить абстрактные методы, в то время
  как интерфейс может наследовать другой интерфейс и при этом не обязательно определять его методы;
- класс-наследник может расширять только один абстрактный класс, а интерфейс может расширять или класс может
  реализовывать множество других интерфейсов;
- класс-наследник может определять абстрактные методы с тем же или менее ограниченным модификатором доступа, при этом
  класс, реализующий интерфейс, должен определять методы с тем же уровнем видимости;
- интерфейс не содержит конструкторы, в том время, как они есть в абстрактном классе;
- переменные, объявленные в интерфейсе по умолчанию являются `final`, абстрактный класс может содержать переменные,
  которые не являются `final`;
- все участники интерфейса по умолчанию являются `public`, а участники абстрактного класса могут позволить себе
  быть `public`, `protected` и др.

## 2.3 MVC

> [[_оглавление_]](../README.md/#23-mvc)

[**MVC (Model-View-Controller)**](/conspect/definitions.md/#m) - это Модель-Представление-Контроллер; архитектурный
шаблон проектирования, который предполагает разделение данных приложения, пользовательского интерфейса и управляющей
логики на три отдельных компонента: Модель, Представление и Контроллер – таким образом, что модификация каждого
компонента может осуществляться независимо.

![10.png](/pictures/10.png)

Этот шаблон делит web-приложение на три логические части:

- Controller - сущность, которая получает запрос и обрабатывает его (контроллер обращается к определенным классам и
  запрашивает у них данные);
- Model - модель данных, которую эти самые классы контроллеру предоставляют (обычно хранится в базе данных);
- View — то, что видит пользователь (контроллер конвертирует данные из Model и возвращает их в виде web-страницы
  или `JSON`/`XML`).

## 2.4 Системы сборки

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Система сборки**](/conspect/definitions.md/#с) - это программное обеспечение, обеспечивающее автоматизацию сборки
проекта. Основное отличие от _IDE_ в том, что конфигурационный файл для системы сборки описывается в текстовом виде. Как
следствие, проект может быть начат быстрее, за счет того, что все типовые задачи заключаются в копировании уже готовых
сниппетов (фрагментов исходного текста или кода программы).

### 2.4.1 Maven

> [[_оглавление_]](../README.md/#24-системы-сборки)

![11.jpg](/pictures/11.jpg)

