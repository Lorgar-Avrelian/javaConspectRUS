# 2 Java Core

> [[_оглавление_]](../README.md/#2-java-core)

## 2.1 Память в Java

> [[_оглавление_]](../README.md/#21-память-в-java)

Все данные <u>_вне зависимости от используемого языка программирования_</u> хранятся в виде структур данных.  
[**Структура данных**](/conspect/definitions.md/#с) - это программная единица, позволяющая хранить и обрабатывать
множество однотипных и/или логически связанных данных в вычислительной технике.  
Структур данных существует огромное множество. Самыми популярными из них являются:

- связный список;
- ассоциативный массив;
- стек;
- очередь.

[**Связный список**](/conspect/definitions.md/#с) - это базовая динамическая структура данных в информатике, состоящая
из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или
предыдущий узел списка.  
В Java структура данных связный список реализован в классе `Linkedlist`.

[**Ассоциативный массив**](/conspect/definitions.md/#а) - это абстрактный тип данных (интерфейс к хранилищу данных),
позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления
пары по ключу.  
В Java структура данных ассоциативный массив реализован в классе `Map`.

[**Стек (Stack)**](/conspect/definitions.md/#с) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого *
*вершиной стека**.  
В стеке реализован принцип _LIFO_.  
[**LIFO (last-in, first-out)**](/conspect/definitions.md/#l) - это принцип, при котором первым удаляется элемент,
который был помещен туда последним («последним вошел — первым вышел»).

![1.jpeg](/pictures/1.jpeg)

В Java структура данных ассоциативный массив реализован в классе `java.util.Stack`.

[**Очередь (Queue)**](/conspect/definitions.md/#q) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов производится в конец, называемый **хвостом очереди**, а удаление
существующих производится с другого конца, называемого **головой очереди**.  
В очереди реализован принцип _FIFO_.  
[**FIFO (first-in, first-out)**](/conspect/definitions.md/#f) - это принцип, при котором первым удаляется элемент,
который был помещен туда первым («первым вошел — первым вышел»).

![2.png](/pictures/2.png)

В Java структура данных очередь представлена не классом, а интерфейсом - `Queue`.  
Но вместе с тем, очередь в Java - это интерфейс, у которого есть очень много реализаций. Самым распространённым из
используемых субинтерфейсов, реализующих интерфейс `Queue`, является интерфейс `Deque` (двусторонняя очередь).  
Двусторонняя очередь `Deque` расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и
конец очереди) и забирать элементы с обоих краев очереди.

![3.png](/pictures/3.png)

Структуры данных в Java, как и в других объектно-ориентированных языках, хранят примитивы и объекты.  
[Примитивы](/conspect/1.md/#112-типизация-переменных) содержат в себе одно значение и не более, за счёт этого они имеют
заранее известный фиксированный размер, интервал допустимых значений и работать с ними быстро и легко.  
[Объекты](/conspect/1.md/#191-объекты) могут хранить в себе как какие-то данные (в виде полей), так и методы по работе с
ними. Java не может заранее знать размер объекта, ведь объекты созданных типов могут создаваться и во время исполнения
программы. Потому была придумана система ссылок.

> Ссылка на объект всегда весит 64 бита (для 64-битных систем, которых сейчас абсолютное большинство).

Каждая ссылка ведёт на область в памяти, где лежит объект.

То есть, переменные примитивных типов хранят в себе само значение, а переменные ссылочных типов хранят в себе ссылку на
область памяти, в которой хранится значение объекта.

> Всё в Java передается по значению.  
> В том числе значения переменных в методы. При попадании в метод сущность копирует то, что хранится в ней, свое
> значение. А для объектов значение переменной - это ссылка на объект.

Все объекты имеют значение по умолчанию `null`, которое представляет собой пустоту.  
Примитивы не могут иметь значение `null`, только объекты.  
`null` не является реализацией объекта, потому любая попытка запросить у пустой переменной (`null`) какие-то данные или
вызвать ее методы приведет к выбросу ошибки (_NullPointerException_ или _NPE_).

### 2.1.1 Стек (Stack)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Стек (Stack)**](/conspect/definitions.md/#s) - это массив, который состоит из ячеек, имеет определенный размер (
количество ячеек) и предоставляет быстрый доступ к своим элементам, так как структурирован и обращение к актуальной
ячейке происходит за константное время.
Этот массив хранит сущности, которые называются _Frame_. Каждый раз, когда вызывается новый метод, в стеке создается
новый фрейм. Как только метод заканчивает выполнение, фрейм удаляется из стека.  
Следовательно, первым фреймом в стеке создается фрейм метода `main`, а затем, когда метод `main` вызывает какой-то
метод, в стеке создается фрейм этого метода и существует до тех пор, пока Java не закончит выполнять код внутри этого
метода.

Примитивы, так как они хранит в себе значение, помещаются во фрейм полностью.  
В случае с объектами во фрейм помещаются только ссылки на объекты, а сами объекты хранятся в куче (_Heap_).

В тот момент, когда память стека заканчивается (количество элементов вышло за границы допустимых для Java-приложения),
приложение будет завершено ошибкой _StackOverflowError_.

> Так как Java позволяет нам писать многопоточные приложения, которые могут вызывать методы параллельно друг другу,
> каждый поток имеет свой собственный стек.  
> Так main-поток имеет в качестве первого фрейма метод `main()`.  
> Другие потоки в качестве первого фрейма имеют тот метод, который был первый выполнен. Обычно это метод `run()`.

### 2.1.2 Куча (Heap)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Куча (Heap)**](/conspect/definitions.md/#h) - это место в памяти, где хранятся объекты.  
Когда создаётся объект через ключевое слово `new`, в куче выделяется место для хранения этого самого объекта.

Куча, в отличие от стека, сама очищать себя не может, потому этим занимается специальная сопрограмма, которая называется
«сборщик мусора» (_garbage collector_), а сам процесс, как ни странно, называется «сборка мусора» (_garbage
collection_).  
Этот процесс анализирует объекты на актуальность и, если приходит к выводу, что объект больше не нужен, удаляет его.  
При переполнении кучи приложение выбрасывает ошибку _OutOfMemoryError_ и завершает работу.

Куча делится на несколько частей. Они созданы для оптимизации сборки мусора:

- два поколения:
    - старое (_Old Generation_);
    - новое (_New Generation_);
- метапространство (_Metaspace_).

![4.png](/pictures/4.png)

Все объекты создаются в новом поколении, и в тот момент, когда эти объекты «переживают» несколько сборок мусора, они
переводятся в старое поколение.  
Метапространство (ранее до 8-й версии Java называлось _Permanent Generation_) хранит в себе метаинформацию о классах, на
основе которых создаются объекты в куче, и статические данные приложения.

### 2.1.3 Сборка мусора (Garbage Collection)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Сборщик мусора (Garbage Collection)**](/conspect/definitions.md/#g) - это инструмент, который находит все объекты в
коде, недоступные для программиста, и удаляет их.  
В программировании часто используются два подхода для реализации сборки мусора:

- подсчёт ссылок;
- трассировка.

Подсчет ссылок подразумевает, что на каждом объекте есть условный счетчик ссылок. Когда на объект создается новая
ссылка, счетчик увеличивается. Когда ссылка отрабатывает свою задачу и перестает быть актуальной, счетчик уменьшается.
При достижении нуля объект помечается мусором и удаляется.

Трассировка встречается чаще, и ее идея построена на том, что в определенный момент мы начинаем идти по коду и искать,
какие объекты еще являются достижимыми в коде дальше. То есть в какой-то момент времени в дальнейшем приложение
обратится к нашему объекту. Эти объекты остаются «жить».

Сборка мусора представляет собой процесс, когда Java анализирует кучу на предмет «мертвых» объектов и удаляет их.  
Именно трассировка и используется в Java. Хотя этот подход и является более сложным и ресурсоёмким, он обеспечивает
большую надежность.  
Процесс трассировки делится на два этапа:

- Mark (маркировка) - сборщик мусора отмечает недостижимые объекты в качестве мусора;
- Sweep (уборка) - объекты, отмеченные мусором на прошлой стадии, удаляются, освобождая место в куче.

В Java существует несколько реализаций сборщиков мусора.  
Какой из них запускать, выбирает разработчик с помощью специального флага при запуске приложения.

#### 2.1.3.1 Serial GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данный сборщик мусора является классической и самой простой реализацией. _Serial GC_ использует один поток и отлично
подходит для работы в приложениях на клиентской стороне (пользовательские ПК), где нет жестких требований к минимизации
остановок приложения и ресурсы ограничены.

#### 2.1.3.2 Parallel GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Отличается от _Serial GC_ использованием нескольких потоков, но также останавливает приложение в ходе сборки мусора.  
Является выбором по умолчанию во многих JVM.

#### 2.1.3.3 CMS (Concurrent Mark Sweep) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация делит ресурсы с приложением, замедляя его работу, но позволяет минимизировать остановки приложения во
время сборки мусора.  
В 9-й версии Java был помечен устаревшим и в 14-й полностью удален.

#### 2.1.3.4 G1 (Garbage First) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация пришла на смену _CMS_. Отличия в том, что данный сборщик мусора делит кучу на равные части и маркирует
их на предмет общей «жизнеспособности». На фазе сборки мусора в первую очередь очищаются наиболее заполненные области,
освобождая максимальный объем памяти.

### 2.1.4 Жизненный цикл приложения

> [[_оглавление_]](../README.md/#21-память-в-java)

Первым делом происходит сборка проекта.  
В этот момент **IDEA** подтягивает все указанные вами зависимости, затем производит процесс компиляции вашего кода.  
На этом моменте компилятор Java производит анализ кода, оптимизирует его и транслирует из того кода на английском языке,
что вы пишете в файлах Java, в байт-код, который уже достаточно тяжело читать человеку, и сохраняет его в файлы формата
_class_.  
Если компилятор находит ошибку в коде (например, вы где-то пропустили), компиляция останавливается, и вы видите много
красного текста в вашей консоли.
Обычно там указывается текст ошибки и строка файла, где эта ошибка была найдена.
**IDEA** подсвечивает эту строку синим, делая ее ссылкой, по нажатию на которую можно перейти в то место, где была
ошибка.
В тот момент, когда все необходимые файлы формата _class_ сформированы, а формируются они в таком соотношении: 1
Java-файл преобразуется в 1 class-файл — **JVM** получает возможность запустить ваш код.

[**JVM (Java Virtual Machine)**](/conspect/definitions.md/#j) в упрощенном представлении является программой, которая
читает этот самый байт-код и транслирует его в машинные инструкции, которые уже понимает процессор.  
Именно за счет **JVM** у приложений на Java появилась одна из киллер фич, а именно: мультиплатформенность. Компилятор
может быть один, его задача — сформировать на основе Java-кода байт-код и записать его в class-файлы.  
Ответственность за запуск приложения ложится на JVM, которые уникальны для каждого типа систем (_Windows_, _Linux_,
_Android_, _iOS_, умный дом), ведь их архитектура отличается.  
Если вы хотите, чтобы ваш код выполнялся на абсолютно новой системе, вам необходимо написать реализацию **JVM** под эту
новую систему (будь это умная лампочка, кофеварка или холодильник), и Java-приложения будут запускаться на этой системе.

Если суммировать, то **JVM** отвечает за запуск вашего приложения. Она управляет памятью, управляет (просит операционную
систему) созданием потоков для многопоточных приложений, осуществляет сборку мусора и так далее.

Так как передавать сотни и сотни class-файлов было бы накладным и неудобным, их принято объединять в архивы в формате
_jar_, где в конфигурации прописан класс с методом `main`, который запускает приложение.  
Этот архив тоже запускается с помощью **JVM**.

## 2.2 Объектно-ориентированное программирование (ООП)

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Объектно-ориентированный подход (ООП)**](/conspect/definitions.md/#о) - это построение приложений в виде множества
различных объектов (каждый из них является реализацией какого-либо класса), которые взаимодействуют друг с другом.
Причем любой объект может реализовывать не просто какой-то конкретный класс, а целую иерархию унаследованных друг от
друга классов, каждый из которых внес частичку себя в общее целое.  
У объектов могут быть свойства.  
[**Свойства объектов**](/conspect/definitions.md/#с) - это переменные, привязанные к объекту.

Принципы ООП:

- инкапсуляция;
- наследование;
- полиморфизм;
- абстракция.

### 2.2.1 Инкапсуляция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

Инкапсуляция является одним из принципов ООП.  
[**Инкапсуляция**](/conspect/definitions.md/#и) — это принцип ООП, согласно которого мы не даем прямой доступ к
свойствам объекта, а получаем их значения через методы.

Для реализации принципа инкапсуляции существуют [модификаторы доступа](/conspect/1.md/#181-модификаторы-доступа).

![5.png](/pictures/5.png)

Пользователь не должен иметь доступ к методам, которые ему не положено вызывать, или к полям, которые ему запрещено
читать или даже изменять. Пользователь должен работать только с тем, что ему нужно.

### 2.2.2 Наследование

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Наследование**](/conspect/definitions.md/#н) - это принцип ООП, согласно которого можно создавать новый класс на
основе существующего. При этом класс-наследник заимствует все свойства и функциональность родительского класса.

![6.png](/pictures/6.png)

Для реализации принципа наследования в Java используется ключевое слово `extends`.

> [**extends**](/conspect/definitions.md/#e) – это ключевое слово, которое применяется для обозначения того, что данный
> класс является наследником другого класса и расширяет свойства и функциональность класса-родителя.

Следует знать, что `private`-члены класса (поля и методы) не наследуются. Это значит, что ими будет управлять родитель,
но доступа к ним из наследника не будет.  
Если влезть в реализацию этого механизма, то Java неявно подкладывает объект класса-родителя в ваш объект и присваивает
его переменной `super` (по аналогии с `this`, которая ссылается на ваш текущий объект).  
А по переменной `super`, соответственно, можно вызвать конструктор родителя.

[**super**](/conspect/definitions.md/#s) - это переменная, которая всегда ссылается на конкретный объект родительского
класса.  
Ключевое слово `super` используется для того, чтобы явно показать, к какому конкретно конструктору родительского класса
мы обращаемся.  
При использовании ключевого слова `super` вызывается конструктор по умолчанию родительского класса.

Внутри конструктора `this` и `super` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст
сообщение об ошибке. Из чего следует, что в одном конструкторе для поля _с одним и тем же именем_ не может быть
одновременно и `this`, и `super`.

Пример использования:

```java
public class Person {
    private String name;
    private String surname;
    private int age;

    public Person(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && Objects.equals(name, person.name) && Objects.equals(surname, person.surname);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname, age);
    }

    @Override
    public String toString() {
        return "Person[" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", age=" + age +
                ']';
    }
}
```

```java
public class Worker extends Person {
    private static int counter = 1;
    private final int id;
    private String position;

    public Worker(String name, String surname, int age, String position) {
        super(name, surname, age);
        this.position = position;
        this.id = counter++;
    }

    public int getId() {
        return id;
    }

    public String getPosition() {
        return position;
    }

    public void setPosition(String position) {
        this.position = position;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Worker worker = (Worker) o;
        return id == worker.id && Objects.equals(position, worker.position);
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), id, position);
    }

    @Override
    public String toString() {
        return "Worker[" +
                "id=" + id +
                ", person=" + super.toString() +
                ", position='" + position + '\'' +
                ']';
    }
}
```

```java
private static void inheritanceExample() {
    Person ivan = new Person("Ivan", "Ivanov", 21);
    Worker petr = new Worker("Petr", "Petrov", 22, "programmer");
    Worker fedor = new Worker("Fedor", "Fedorov", 23, "manager");
    Worker sidor = new Worker("Sidor", "Sidorov", 25, "manager");
    System.out.println(ivan);
    System.out.println(petr);
    System.out.println(fedor);
    System.out.println(sidor);
    sidor.setPosition("commercial director");
    System.out.println(sidor);
}
```

Если вдруг наследники должны иметь внутри себя логику по работе с содержимым полей родителя, то эти поля (или методы)
должны быть помечены модификаторами `default` (отсутствует модификатор, если родитель и наследник лежат в одном пакете)
или `protected`.

### 2.2.3 Полиморфизм

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Полиморфизм**](/conspect/definitions.md/#п) - это принцип ООП, согласно которого можно работать со многими классами,
как с одним, при условии, что все эти классы имеют одного базового предка; способность предоставлять один и тот же
интерфейс для различных базовых форм (типов данных).  
Это означает, что классы, имеющие различную функциональность, совместно используют один и тот же интерфейс и могут быть
динамически вызваны передачей параметров по ссылке.  
Процесс, применяемый объектно-ориентированными языками программирования для реализации динамического полиморфизма,
называется [**динамическим связыванием**](/conspect/definitions.md/#д).

![7.png](/pictures/7.png)

При использовании принципа полиморфизма необходимо учитывать следующее:

- любой прямой или косвенный наследник класса может быть использован в качестве экземпляра своего родителя;
- за набор полей и методов отвечает тип (класс) ссылки предка;
- за код, который выполняется при вызове этих методов (то, что после `=`), отвечает уже реализация (класс наследника);
- наследование должно быть только от одного класса.

> **_!!! Множественное наследование в Java запрещено !!!_**

### 2.2.4 Абстракция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстракция**](/conspect/definitions.md/#а) – это принцип ООП, согласно которому при проектировании классов и создании
объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные; процесс сокрытия деталей
реализации от пользователя, предоставляя ему только функционал (интерфейс).  
Иными словами, пользователь будет владеть информацией о том, что объект делает, а не как он это делает.  
В Java абстракция достигается с использованием абстрактных классов и интерфейсов.

#### 2.2.4.1 Абстрактные классы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Абстрактный класс**](/conspect/definitions.md/#а) - это класс, который не может быть использован для создания
объектов.  
Вместо создания объектов абстрактный класс служит как базовый элемент для других классов.

Для создания абстрактного класса в Java используется ключевое слово `abstract`.

> [**abstract**](/conspect/definitions.md/#a) - это ключевое слово, которое применяется для создания абстрактных классов
> и методов.

Абстрактный класс может содержать и абстрактные и конкретные методы. Классы, которые наследуют от абстрактного класса,
должны реализовывать все его абстрактные методы. Если хоть один метод в классе объявлен абстрактным, весь класс должен
так же быть объявлен абстрактным. Тем не менее, в обратную сторону правило не обязано соблюдаться. Если класс объявлен
абстрактным, он может и не содержать абстрактные методы.

[**Абстрактный метод**](/conspect/definitions.md/#а) - это метод, который всего лишь определяет свои сигнатуры и не
обеспечивает реализацию.

Абстрактные классы рекомендуется применять в следующих случаях:

- необходимо поделиться кодом между несколькими тесно связанными классами;
- классы, которые расширяют абстрактный класс, имеют много общих методов или полей, или требуют других модификаторов
  доступа, кроме `public` (например, `protected` и `private`);
- необходимо объявить нестатические или не-final поля, что позволяет определять методы, которые могут получить доступ и
  изменить состояние объекта, которому они принадлежат.

#### 2.2.4.2 Интерфейсы

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

[**Интерфейс**](/conspect/definitions.md/#и) - это конструкция языка Java, в рамках которой принято описывать
абстрактные публичные (`abstract public`) методы и статические константы (`final static`).  
Интерфейсы создаются по аналогии с классами, но с помощью ключевого слова `interface`, а не `class`.

> [**interface**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для создания интерфейсов.

Свойства интерфейса:

- содержит только абстрактные методы (слово `abstract` писать не нужно);
- у интерфейсов все методы `public`;
- может наследоваться только от интерфейсов;
- в Java есть множественное наследование интерфейсов (родителей у интерфейса может быть много);
- класс может реализовывать несколько интерфейсов (и наследоваться только от одного класса);

> [**implements**](/conspect/definitions.md/#i) - это ключевое слово, которое применяется для обозначения того, что
> данный класс реализует какой-либо интерфейс.

- в интерфейсах нельзя объявлять переменные, кроме статических.

Начиная с Java 8, в интерфейсах можно создавать методы по умолчанию с использованием ключевого слова `default`.

> [**default**](/conspect/definitions.md/#d) - это ключевое слово, которое применяется для создания методов по
> умолчанию.

К примеру:

```java
public interface Swimmable {

    public default void swim() {
        System.out.println("Плыви!");
    }

    public void eat();

    public void run();
}
```

Во всех классах, имплементирующих интерфейс _Swimmable_, необходимо будет переопределять методы _eat()_ и _run()_, а для
метода _swim()_ этого делать будет не обязательно (но может быть), так как его реализация во всех классах будет
одинаковой.

Интерфейсы рекомендуется применять в следующих случаях:

- интерфейс будут реализовывать несвязанные классы;
- необходимо определить поведение конкретного типа данных, при этом не важно, кто его реализует;
- необходимо использовать множественное наследование.

#### 2.2.4.3 Различия между абстрактным классом и интерфейсом:

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

- интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (
  кроме `public static final`), в то время как у абстрактного класса они могут быть;
- абстрактный класс наследуется (`extends`), а интерфейс — реализуется (`implements`): можно наследовать только один
  класс, а реализовать интерфейсов — сколько угодно (интерфейс может наследовать (`extends`) другой
  интерфейс/интерфейсы);
- абстрактные классы используются, когда есть отношение _"is-a"_, то есть класс-наследник расширяет базовый абстрактный
  класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом;
- методы и члены абстрактного класса могут быть обозначены любым модификатором доступа, в свою очередь все методы
  интерфейса обязаны быть открытыми (`public`);
- когда происходит наследование абстрактного класса, класс-наследник должен определить абстрактные методы, в то время
  как интерфейс может наследовать другой интерфейс и при этом не обязательно определять его методы;
- класс-наследник может расширять только один абстрактный класс, а интерфейс может расширять или класс может
  реализовывать множество других интерфейсов;
- класс-наследник может определять абстрактные методы с тем же или менее ограниченным модификатором доступа, при этом
  класс, реализующий интерфейс, должен определять методы с тем же уровнем видимости;
- интерфейс не содержит конструкторы, в том время, как они есть в абстрактном классе;
- переменные, объявленные в интерфейсе по умолчанию являются `final`, абстрактный класс может содержать переменные,
  которые не являются `final`;
- все участники интерфейса по умолчанию являются `public`, а участники абстрактного класса могут позволить себе
  быть `public`, `protected` и др.

## 2.3 MVC

> [[_оглавление_]](../README.md/#23-mvc)

[**MVC (Model-View-Controller)**](/conspect/definitions.md/#m) - это Модель-Представление-Контроллер; архитектурный
шаблон проектирования, который предполагает разделение данных приложения, пользовательского интерфейса и управляющей
логики на три отдельных компонента: Модель, Представление и Контроллер – таким образом, что модификация каждого
компонента может осуществляться независимо.

![10.png](/pictures/10.png)

Этот шаблон делит web-приложение на три логические части:

- Controller - сущность, которая получает запрос и обрабатывает его (контроллер обращается к определенным классам и
  запрашивает у них данные);
- Model - модель данных, которую эти самые классы контроллеру предоставляют (обычно хранится в базе данных);
- View — то, что видит пользователь (контроллер конвертирует данные из Model и возвращает их в виде web-страницы
  или `JSON`/`XML`).

## 2.4 Системы сборки

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Система сборки**](/conspect/definitions.md/#с) - это программное обеспечение, обеспечивающее автоматизацию сборки
проекта. Основное отличие от _IDE_ в том, что конфигурационный файл для системы сборки описывается в текстовом виде. Как
следствие, проект может быть начат быстрее, за счет того, что все типовые задачи заключаются в копировании уже готовых
сниппетов (фрагментов исходного текста или кода программы).

### 2.4.1 Maven

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Apache Maven**](/conspect/definitions.md/#m) - это фреймворк для автоматизации сборки проектов на основе описания их
структуры в файлах _POM_ (Project Object Model) в формате _XML_.

![11.jpg](/pictures/11.jpg)

Конфигурирование _Maven_ производится в файле _pom.xml_.

Структура типового конфигурационного файла _pom.xml_ выглядит следующим образом:

```xml
<!-- 1 -->
<!-- Служебный фрагмент кода, в котором описывается кодировка XML документа и заголовок проекта, -->
<!-- а так же указывается версия используемой объектной модели для файла -->
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!-- 2 -->
    <!-- Фрагмент кода, который отвечает за подключение родительского pom.xml, где указаны версии всех -->
    <!-- библиотек, которые соответствуют текущей версии Spring Boot -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.1</version>
        <relativePath/>
    </parent>
    <!-- 3 -->
    <!-- Фрагмент кода, который хранит в себе информацию о проекте: -->
    <!-- groupId - группа проекта (проекты одного автора имеют один и тот же groupId, например - com.companyname) -->
    <!-- artifactId - уникальное имя проекта внутри группы groupId -->
    <!-- version - текущая версия проекта -->
    <!-- name - человекочитаемое имя проекта (может отличаться от artifactId и может содержать пробелы) -->
    <!-- description - описание проекта для человека который будет читать данный pom.xml -->
    <groupId>pro.sky</groupId>
    <artifactId>counter-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>Counter Service</name>
    <description>Counter service that counts amount of requests to page</description>
    <!-- 4 -->
    <!-- Фрагмент кода, который хранит в себе значения таких переменных, как версии библиотек, версии Java. -->
    <!-- Блок </properties> является необязательным -->
    <properties>
        <java.version>17</java.version>
    </properties>
    <!-- 5 -->
    <!-- Блок кода, содержащий необходимые зависимости -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope> <!-- Скоуп для данной библиотеки -->
        </dependency>
    </dependencies>

    <!-- 6 -->
    <!-- Блок кода, содержащий плагины -->
    <!-- В данном случае указан плагин, который собирает финальный JAR архив с приложением -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```

Особенности _Maven_:

- наличие чёткой структуры каталогов (которую автоматически создаёт _IDE_ при создании проекта):
    - в _src/main/java_ содержатся java-классы;
    - в _src/main/resources_ - ресурсы, которые использует приложение (HTML-страницы, картинки, таблицы стилей и тд);
    - в _src/test_ содержатся тесты;

> Также у каждого проекта может быть только один файл JAR-файл

- автоматическое управление зависимостями (скачивание, распаковка, подключение и контроль версий);
- стандартизированное название билдов (каждый имеет атрибуты _groupId_, _artifactId_ и _version_);
- наличие фаз жизненного цикла проекта:
    - _clean_ - удаляются все скомпилированные файлы из каталога _target_ (место, в котором сохраняются готовые
      артефакты);
    - _validate_ - идёт проверка, вся ли информация доступна для сборки проекта;
    - _compile_ - компилируются файлы с исходным кодом;
    - _test_ - запускаются тесты;
    - _package_ - упаковываются скомпилированные файлы (в jar-, war- и т.д. архив);
    - _verify_ - выполняются проверки для подтверждения готовности упакованного файла;
    - _install_ - пакет помещается в локальный репозиторий. (после чего он может использоваться другими проектами как
      внешняя библиотека);
    - _site_ - создается документация проекта;
    - _deploy_ - собранный архив копируется в удаленный репозиторий.

> Все фазы выполняются последовательно: нельзя запустить последующую без запуска предыдущей.

Запуск фаз возможен посредством _IDE_ или через терминал:

```text
mvn clean
```

> Фазу _clean_ желательно вызывать перед каждой новой сборкой проекта.

У каждой фазы есть цели (goal). Стандартные цели заложены по умолчанию, дополнительные добавляются Maven-плагинами.  
[Список официальных плагинов](https://maven.apache.org/plugins/) можно посмотреть на официальном сайте _Maven_.  
Чтобы добавить Maven-плагин в проект, его описание, аналогично зависимостям, нужно поместить в _pom.xml_ в
теги `<build>` и `<plugins>`.

### 2.4.2 Gradle

> [[_оглавление_]](../README.md/#24-системы-сборки)

[**Gradle**](/conspect/definitions.md/#g) - это система для автоматизации сборки приложений и сбора статистики об
использовании программных библиотек, применяющая языки **Android**, **Java**, **Kotlin**, **Groovy**, **Scala**,
**Javascript** и **C/C++**, а также решения из фреймворков _Apache Ant_ и _Apache Maven_.  
_Gradle_ основан на графе задач (_task_), которые предоставляются различными плагинами и могут зависеть друг от друга.
Задачи выполняют какую-то работу. _Maven_ же использует модель определённых фаз (_phase_), к которым присоединяются
определённые "цели" (_goals_). В этих _goals_ и выполняется какая-то работа.

![12.png](/pictures/12.png)

Конфигурирование _Gradle_ производится в файле _build.gradle_.

Типы плагинов:

- _бинарные плагины_ - это скомпилированные плагины, обычно написанные на Java или Kotlin DSL и упакованные в файлы
  JAR (применяются к проекту с помощью блока `plugins {}`);
- _предварительно скомпилированные скриптовые плагины_ - это скрипты Groovy DSL или Kotlin DSL, скомпилированные и
  распространяемые как файлы классов Java, упакованные в библиотеку (применяются к проекту с помощью
  блока `plugins {}`);
- _скриптованные плагины_ - это скрипты Groovy DSL или Kotlin DSL, которые применяются непосредственно к скрипту сборки
  Gradle с использованием синтаксиса `apply from:` (применяются в строке внутри скрипта сборки для добавления
  функциональности или настройки процесса сборки).

Чтобы использовать логику сборки, инкапсулированную в плагин, _Gradle_ необходимо выполнить два шага: разрешить плагин,
а затем применить его к цели (обычно к _Project_).

![13.png](/pictures/13.png)

Первое отличие _Gradle_ от _Maven_ заключается в наличии _Gradle Wrapper_ (или просто _Wrapper_), специального скрипта
(а также несколько дополнительных файлов), который вызывает объявленную версию _Gradle_, при необходимости загружая ее
заранее. Конфигурирование _Wrapper_ производится в файле _gradle/wrapper/gradle-wrapper.properties_.  
Стартер _Gradle_ при условии наличия нескольких модулей в проекте можно отредактировать в файле _settings.gradle_.

Структура типового конфигурационного файла _build.gradle_ выглядит следующим образом:

```groovy
// Блок, содержащий используемые плагины
plugins {
    // Основные плагины, для которого достаточно указать только id
    id 'java'
    // Бинарные плагины, для которых обязательно необходимо указывать версию
    id 'org.springframework.boot' version '3.4.0-SNAPSHOT'
    id 'io.spring.dependency-management' version '1.1.6'
}

// Блок, содержащий текущие группу и версию
group = 'com.example'
version = '0.0.1-SNAPSHOT'

// Блок конфигурации плагина java
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

// Блок конфигураций данного проекта
configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

// Блок репозиториев, содержащих необходимые зависимости
repositories {
    // Репозиторий по умолчанию Maven
    mavenCentral()
    maven { url 'https://repo.spring.io/milestone' }
    maven { url 'https://repo.spring.io/snapshot' }
}

// Блок зависимостей
// implementation - зависимости, необходимые на этапе компиляции проекта и во время его выполнения
// compileOnly - зависимости, необходимые только на этапе компиляции проекта
// compileClasspath - содержит путь к зависимостям, необходимым для компиляции проекта
// annotationProcessor - зависимости, которые являются процессорами аннотаций (используются во время компиляции для обработки аннотаций)
// runtimeOnly - зависимости, которые необходимы только на этапе выполнения
// runtimeClasspath - содержит путь к зависимостям, необходимым для выполнения проекта
// testImplementation - зависимости, необходимые на этапе компиляции тестового кода и во время его выполнения
// testCompileOnly - зависимости, необходимые только на этапе компиляции тестового кода
// testRuntimeOnly - зависимости, которые необходимы только на этапе выполнения тестового кода
// testCompileClasspath - содержит путь к зависимостям, необходимым для компиляции тестового кода
// testRuntimeClasspath - содержит путь к зависимостям, необходимым для выполнения тестового кода
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.liquibase:liquibase-core'
    compileOnly 'org.projectlombok:lombok'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    developmentOnly 'org.springframework.boot:spring-boot-docker-compose'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

// Задача (task) по запуску всех тестов
tasks.named('test') {
    useJUnitPlatform()
}

```

Полный перечень возможных [настроек проекта](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html),
указываемых в _build.gradle_ можно найти на официальном сайте _Gradle_.

Настройка свойств _Gradle_ производится в файле _gradle.properties_ (зарезервированное
имя). [Перечень возможных настроек](https://docs.gradle.org/current/userguide/build_environment.html) можно найти на
официальном сайте _Gradle_.

_Gradle_ обладает теми же особенностями, коими обладает _Maven_, однако имеет ряд других особенностей:

- DSL (Domain Specific Language) конфига _Groovy_ (_Kotlin_), который менее громоздкий чем XML-конфиг _Maven_;
- менее громоздкая система плагинов;
- большая гибкость и расширяемость (возможность писать настройки для отдельных модулей приложения).

## 2.5 Исключения

> [[_оглавление_]](../README.md/#25-исключения)

[**Исключения (Exceptions)**](/conspect/definitions.md/#и) - это механизм, который позволяет программе обрабатывать
нетипичную ситуацию и при этом не прекращать работу.

### 2.5.1 Иерархия исключений

> [[_оглавление_]](../README.md/#25-исключения)

![14.png](/pictures/14.png)

Исключения имеют общего предка - класс _Throwable_. Его потомками являются подклассы _Exception_ и _Error_.  
_Исключения (Exceptions)_ являются результатом проблем в программе, которые в принципе решаемы и предсказуемы.  
_Ошибки (Errors)_ представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует пытаться
обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM.

Все исключения подразделяются на _проверяемые_ и _непроверяемые_.  
К непроверяемым исключениям относятся все ошибки (класс _Error_ и его потомки) и все исключения времени выполнения
(класс _RuntimeException_ и его потомки), к проверяемым - все остальные.

В коде можно создавать и выбрасывать свои исключения.

Синтаксис выброса исключений выглядит следующим образом:

```java
throw new RuntimeException();
```

> [**throw**](/conspect/definitions.md/#t) – это ключевое слово, которое применяется для выбрасывания исключений в коде.

При возникновении исключения в Java-коде модуль _Spring Web_ возвращает пользователю соответствующий HTTP-статус.

> [**Ссылка**](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) на список возможных HTTP-статусов.

Чтобы сообщить _Spring_, какой именно статус необходимо возвращать пользователю, используют аннотацию `@ResponseStatus`.

### 2.5.2 Обработка исключений

> [[_оглавление_]](../README.md/#25-исключения)

Когда проверяемое исключение не обрабатывается внутри того метода, где это исключение кидается, необходимо использовать
ключевое слово `throws` и указывать тип выбрасываемого проверяемого исключения.

Например:

```java
public static void check(File file) throws FileNotFoundException {
    if (!file.exists()) {
        throw new FileNotFoundException();
    }
    if (file.isDirectory()) {
        throw new IllegalArgumentException(file.getPath() + " is a directory");
    }
}
```

> [**throws**](/conspect/definitions.md/#t) – это ключевое слово, которое используется в объявлении метода для указания,
> что метод может выбрасывать проверяемые исключения.  
> При использовании ключевого слова `throws` проверка выбрасываемого исключения делегируется тому методу, который
> вызывает данный.

Обработка исключений в Java построена на конструкции _try-catch-finally_.

![15.png](/pictures/15.png)

> [**try**](/conspect/definitions.md/#t) – это ключевое слово, определяющее блок кода, в котором может произойти
> исключение.

> [**catch**](/conspect/definitions.md/#c) – это ключевое слово, определяющее блок кода, в котором происходит обработка
> исключения.

> [**finally**](/conspect/definitions.md/#f) – это ключевое слово, определяющее блок кода, который является
> необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока `try`.  
> Блок `finally` иерархически выше блока `try`. Это означает, что если оба блока будут содержать оператор `return`, то
> выполнится тот, который содержится в блоке `finally`.

Конструкция _try-catch-finally_ выглядит следующим образом:

```java
try([создание_какого-либо_ресурса])
        {
        // код, в котором может возникнуть исключение
        }
        catch([тип_ошибки][имя_переменной])
        {
        // действия по обработке исключения
        }
        finally
        {
        // код, выполняемый в любом случае
        }
```

Блоки `catch` могут объединяться в цепочки, а также отвечать за обработку нескольких типов исключений. В последнем
случае типы обрабатываемых исключений указываются через вертикальную черту (`|`).

Например:

```java
private static void tryCatchFinallyExample() {
    try {
        File file = new File("pictures/16.png");
        System.out.println(Files.size(file.toPath()));
    } catch (NoSuchElementException e) {
        System.out.println("File not found!");
    } catch (IOException | ClassCastException e) {
        System.out.println("Internal error!");
    } finally {
        System.out.println("The end");
    }
}
```

Блоки `catch` анализируются по очереди. И если указать родительское исключение раньше, чем его наследника, то будет
вызван код из первого совпавшего блока, а не из более узкоспециализированного, но написанного после.

Блок `try` также применяется в многопоточных приложениях для того, чтобы гарантированно закрывать открываемые в процессе
выполнения потоки.

Пример 1:

- контроллер:

```java
import lombok.extern.log4j.Log4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import Animals.entity.PetAvatar;
import Animals.service.PetAvatarServiceImpl;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;

@RestController
@Log4j
@RequestMapping(path = "/pet-avatar")
public class PetAvatarController {
    private final PetAvatarServiceImpl petAvatarService;

    public PetAvatarController(PetAvatarServiceImpl petAvatarService) {
        this.petAvatarService = petAvatarService;
    }

    @GetMapping(path = "/{id}")
    public void downloadAvatar(@PathVariable Long id, HttpServletResponse response) throws IOException {
        PetAvatar petAvatar = petAvatarService.findAvatar(id);
        Path avatarPath = Path.of(petAvatar.getFilePath());
        try (
                InputStream is = Files.newInputStream(avatarPath);
                OutputStream os = response.getOutputStream()
        ) {
            response.setContentType(petAvatar.getMediaType());
            response.setContentLength((int) petAvatar.getFileSize());
            is.transferTo(os);
        }
    }

    @GetMapping(path = "{id}/preview")
    public ResponseEntity<byte[]> downloadAvatarPreview(@PathVariable Long id) {
        PetAvatar petAvatar = petAvatarService.findAvatar(id);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(petAvatar.getMediaType()));
        headers.setContentLength(petAvatar.getData().length);
        return ResponseEntity.ok().headers(headers).body(petAvatar.getData());
    }

    @PostMapping(value = "/{id}", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity uploadAvatar(@RequestParam @PathVariable Long id, @RequestParam MultipartFile avatar) throws IOException {
        if (avatar.getSize() >= 1024 * 500) {
            return ResponseEntity.status(400).body("File is too big!");
        }
        try {
            petAvatarService.uploadAvatar(id, avatar);
        } catch (RuntimeException e) {
            log.error(e.getMessage());
        }
        return ResponseEntity.ok().build();
    }
}
```

- сервис:

```java
import lombok.extern.log4j.Log4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import Animals.entity.Pet;
import Animals.entity.PetAvatar;
import Animals.repository.PetAvatarRepository;

import javax.imageio.ImageIO;
import javax.transaction.Transactional;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;

import static java.nio.file.StandardOpenOption.CREATE_NEW;

@Service
@Log4j
@Transactional
public class PetAvatarServiceImpl implements PetAvatarService {
    Logger log = LoggerFactory.getLogger(PetAvatarServiceImpl.class);
    @Value("${pet.avatar.dir.path}")
    private String petAvatarsDir;
    private final PetServiceImpl petService;
    private final PetAvatarRepository petAvatarRepository;

    public PetAvatarServiceImpl(PetServiceImpl petService, PetAvatarRepository petAvatarRepository) {
        this.petService = petService;
        this.petAvatarRepository = petAvatarRepository;
    }

    @Override
    @Cacheable("avatar")
    public PetAvatar findAvatar(Long id) {
        log.info("Searching avatar by id " + id);
        PetAvatar answer = petAvatarRepository.findById(id).get();
        log.debug("Getting answer " + answer);
        return answer;
    }

    @Override
    @CachePut(value = "avatar", key = "#avatar.id")
    public void uploadAvatar(Long id, MultipartFile file) throws IOException {
        log.info("Trying to upload avatar for student with id " + id);
        Pet pet = petService.getById(id);
        Path filePath = Path.of(petAvatarsDir, id + "." + getExtension(file.getOriginalFilename()));
        Files.createDirectories(filePath.getParent());
        Files.deleteIfExists(filePath);
        try (
                InputStream is = file.getInputStream();
                OutputStream os = Files.newOutputStream(filePath, CREATE_NEW);
                BufferedInputStream bis = new BufferedInputStream(is, 1024);
                BufferedOutputStream bos = new BufferedOutputStream(os, 1024)
        ) {
            bis.transferTo(bos);
        }
        PetAvatar petAvatar = getPetAvatar(id);
        petAvatar.setPet(pet);
        petAvatar.setFilePath(filePath.toString());
        petAvatar.setFileSize(file.getSize());
        petAvatar.setMediaType(file.getContentType());
        petAvatar.setData(generateImagePreview(filePath));
        petAvatarRepository.save(petAvatar);
    }

    private String getExtension(String filename) {
        return filename.substring(filename.lastIndexOf(".") + 1);
    }

    public PetAvatar getPetAvatar(Long id) {
        return petAvatarRepository.findByPetId(id).orElse(new PetAvatar());
    }

    public byte[] generateImagePreview(Path filePath) throws IOException {
        try (
                InputStream is = Files.newInputStream(filePath);
                BufferedInputStream bis = new BufferedInputStream(is, 1024);
                ByteArrayOutputStream baos = new ByteArrayOutputStream()
        ) {
            BufferedImage image = ImageIO.read(bis);
            int height = 0;
            int width = 0;
            BufferedImage preview = null;
            if (image.getHeight() > image.getWidth()) {
                height = image.getHeight() / (image.getWidth() / 100);
                preview = new BufferedImage(100, height, image.getType());
            } else {
                width = image.getWidth() / (image.getHeight() / 100);
                preview = new BufferedImage(width, 100, image.getType());
            }
            Graphics2D graphics = preview.createGraphics();
            graphics.drawImage(image, 0, 0, 100, height, null);
            graphics.dispose();
            ImageIO.write(preview, getExtension(filePath.getFileName().toString()), baos);
            return baos.toByteArray();
        }
    }
}
```

- модель:

```java
import javax.persistence.*;
import java.util.Arrays;
import java.util.Objects;

import static javax.persistence.GenerationType.IDENTITY;

@Entity
@Table(name = "avatar")
public class PetAvatar {
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Long id;
    private String filePath;
    private long fileSize;
    private String mediaType;
    @Lob
    private byte[] data;
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pet_id")
    private Pet pet;

    public PetAvatar() {
    }

    public PetAvatar(Long id, String filePath, long fileSize, String mediaType, byte[] data, Pet pet) {
        this.id = id;
        this.filePath = filePath;
        this.fileSize = fileSize;
        this.mediaType = mediaType;
        this.data = data;
        this.pet = pet;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFilePath() {
        return filePath;
    }

    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }

    public long getFileSize() {
        return fileSize;
    }

    public void setFileSize(long fileSize) {
        this.fileSize = fileSize;
    }

    public String getMediaType() {
        return mediaType;
    }

    public void setMediaType(String mediaType) {
        this.mediaType = mediaType;
    }

    public byte[] getData() {
        return data;
    }

    public void setData(byte[] data) {
        this.data = data;
    }

    public Pet getPet() {
        return pet;
    }

    public void setPet(Pet pet) {
        this.pet = pet;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PetAvatar petAvatar = (PetAvatar) o;
        return fileSize == petAvatar.fileSize && Objects.equals(id, petAvatar.id) && Objects.equals(filePath, petAvatar.filePath) && Objects.equals(pet, petAvatar.pet);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, filePath, fileSize, pet);
    }

    @Override
    public String toString() {
        return "PetAvatar{" +
                "id=" + id +
                ", filePath='" + filePath + '\'' +
                ", fileSize=" + fileSize +
                ", mediaType='" + mediaType + '\'' +
                ", data=" + Arrays.toString(data) +
                ", pet=" + pet +
                '}';
    }
}
```

- репозиторий:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import Animals.entity.PetAvatar;

import java.util.Optional;

@Repository
public interface PetAvatarRepository extends JpaRepository<PetAvatar, Long> {
    Optional<PetAvatar> findByPetId(Long petId);
}
```

Пример 2:

- контроллер:

```java
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import ru.hogwarts.school.model.Avatar;
import ru.hogwarts.school.service.AvatarService;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

@RestController
public class AvatarController {
    private final AvatarService avatarService;

    public AvatarController(AvatarService avatarService) {
        this.avatarService = avatarService;
    }

    @GetMapping(path = "/{id}/avatar")
    public void downloadAvatar(@PathVariable Long id, HttpServletResponse response) throws IOException {
        Avatar avatar = avatarService.findAvatar(id);
        Path avatarPath = Path.of(avatar.getFilePath());
        try (
                InputStream is = Files.newInputStream(avatarPath);
                OutputStream os = response.getOutputStream()
        ) {
            response.setContentType(avatar.getMediaType());
            response.setContentLength((int) avatar.getFileSize());
            is.transferTo(os);
        }
    }

    @GetMapping(path = "{id}/avatar/preview")
    public ResponseEntity<byte[]> downloadAvatarPreview(@PathVariable Long id) {
        Avatar avatar = avatarService.findAvatar(id);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(avatar.getMediaType()));
        headers.setContentLength(avatar.getData().length);
        return ResponseEntity.ok().headers(headers).body(avatar.getData());
    }

    @PostMapping(value = "/{id}/avatar", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<String> uploadAvatar(@PathVariable Long id, @RequestParam MultipartFile avatar) throws IOException {
        if (avatar.getSize() >= 1024 * 500) {
            return ResponseEntity.status(400).body("File is too big!");
        }
        avatarService.uploadAvatar(id, avatar);
        return ResponseEntity.ok().build();
    }

    @GetMapping(path = "/avatars")
    public ResponseEntity<List<Avatar>> getAvatars(@RequestParam int pageNum, @RequestParam int pageSize) {
        if (pageNum <= 0 || pageSize <= 0) {
            return ResponseEntity.status(400).build();
        }
        return ResponseEntity.ok().body(avatarService.getAvatars(pageNum, pageSize));
    }
}
```

- сервис:

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import ru.hogwarts.school.model.Avatar;
import ru.hogwarts.school.model.Student;
import ru.hogwarts.school.repository.AvatarRepository;

import javax.imageio.ImageIO;
import javax.transaction.Transactional;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static java.nio.file.StandardOpenOption.CREATE_NEW;

@Service
@Transactional
public class AvatarServiceImpl implements AvatarService {
    @Value("${student.avatar.dir.path}")
    private String avatarsDir;
    private final StudentService studentService;
    private final AvatarRepository avatarRepository;
    private final Logger logger = LoggerFactory.getLogger(AvatarServiceImpl.class);

    public AvatarServiceImpl(StudentService studentService, AvatarRepository avatarRepository) {
        this.studentService = studentService;
        this.avatarRepository = avatarRepository;
    }

    @Override
    public Avatar findAvatar(Long id) {
        logger.info("Searching avatar by id {}", id);
        Avatar answer = avatarRepository.findById(id).get();
        logger.debug("Getting answer {}", answer);
        return answer;
    }

    @Override
    public void uploadAvatar(Long id, MultipartFile file) throws IOException {
        logger.info("Trying to upload avatar for student with id {}", id);
        Student student = studentService.findStudent(id);
        Path filePath = Path.of(avatarsDir, id + "." + getExtension(file.getOriginalFilename()));
        Files.createDirectories(filePath.getParent());
        Files.deleteIfExists(filePath);
        try (
                InputStream is = file.getInputStream();
                OutputStream os = Files.newOutputStream(filePath, CREATE_NEW);
                BufferedInputStream bis = new BufferedInputStream(is, 1024);
                BufferedOutputStream bos = new BufferedOutputStream(os, 1024)
        ) {
            bis.transferTo(bos);
        }
        Avatar avatar = getAvatar(id);
        avatar.setStudent(student);
        avatar.setFilePath(filePath.toString());
        avatar.setFileSize(file.getSize());
        avatar.setMediaType(file.getContentType());
        avatar.setData(generateImagePreview(filePath));
        avatarRepository.save(avatar);
    }

    private String getExtension(String filename) {
        return filename.substring(filename.lastIndexOf(".") + 1);
    }

    private Avatar getAvatar(Long id) {
        return avatarRepository.findByStudentId(id).orElse(new Avatar());
    }

    private byte[] generateImagePreview(Path filePath) throws IOException {
        try (
                InputStream is = Files.newInputStream(filePath);
                BufferedInputStream bis = new BufferedInputStream(is, 1024);
                ByteArrayOutputStream baos = new ByteArrayOutputStream()
        ) {
            BufferedImage image = ImageIO.read(bis);
            int height = image.getHeight() / (image.getWidth() / 100);
            BufferedImage preview = new BufferedImage(100, height, image.getType());
            Graphics2D graphics = preview.createGraphics();
            graphics.drawImage(image, 0, 0, 100, height, null);
            graphics.dispose();
            ImageIO.write(preview, getExtension(filePath.getFileName().toString()), baos);
            return baos.toByteArray();
        }
    }

    @Override
    public List<Avatar> getAvatars(int pageNum, int pageSize) {
        logger.info("Getting pageable list of avatars with page number {} and page size {}", pageNum, pageSize);
        PageRequest pageRequest = PageRequest.of(pageNum - 1, pageSize);
        List<Avatar> answer = avatarRepository.findAll(pageRequest).getContent();
        logger.debug("Getting answer {}", answer);
        return answer;
    }
}
```

- модель:

```java
import javax.persistence.*;
import java.util.Arrays;
import java.util.Objects;

import static javax.persistence.GenerationType.IDENTITY;

@Entity
@Table(name = "avatar")
public class Avatar {
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Long id;
    private String filePath;
    private long fileSize;
    private String mediaType;
    @Lob
    private byte[] data;
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "student_id")
    private Student student;

    public Avatar(Long id, String filePath, long fileSize, String mediaType, byte[] data) {
        this.id = id;
        this.filePath = filePath;
        this.fileSize = fileSize;
        this.mediaType = mediaType;
        this.data = data;
    }

    public Avatar() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getFilePath() {
        return filePath;
    }

    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }

    public long getFileSize() {
        return fileSize;
    }

    public void setFileSize(Long fileSize) {
        this.fileSize = fileSize;
    }

    public String getMediaType() {
        return mediaType;
    }

    public void setMediaType(String mediaType) {
        this.mediaType = mediaType;
    }

    public byte[] getData() {
        return data;
    }

    public void setData(byte[] data) {
        this.data = data;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Avatar avatar = (Avatar) o;
        return Objects.equals(id, avatar.id);
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(id);
        result = 31 * result + Arrays.hashCode(data);
        return result;
    }

    @Override
    public String toString() {
        return "Avatar{" +
                "id=" + id +
                ", filePath='" + filePath + '\'' +
                ", fileSize=" + fileSize +
                ", mediaType='" + mediaType + '\'' +
                ", data=" + Arrays.toString(data) +
                ", student=" + student +
                '}';
    }
}
```

- репозиторий:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import ru.hogwarts.school.model.Avatar;

import java.util.Optional;

public interface AvatarRepository extends JpaRepository<Avatar, Long> {
    Optional<Avatar> findByStudentId(Long studentId);
}
```

Пример 3:

- контроллер:

```java
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import org.apache.log4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import ru.service.ImageService;
import ru.service.impl.ImageServiceImpl;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.lang.reflect.Array;

/**
 * A controller for users and ads image requests. <br>
 * <br>
 * <hr>
 * <br>
 * Контроллер для запросов изображений пользователей и объявлений. <br>
 * <br>
 */
@CrossOrigin(value = "http://localhost:3000")
@RestController
public class ImageController {
    private final ImageServiceImpl imageService;
    private static final Logger log = Logger.getLogger(ImageController.class);

    public ImageController(ImageServiceImpl imageService) {
        this.imageService = imageService;
    }

    /**
     * A method of the controller for getting {@link Array} of {@link Byte} with image of user or ad. <br>
     * Used service method {@link ImageService#getImage(String, HttpServletResponse)}. <br>
     * <br>
     * <hr>
     * <br>
     * Метод контроллера для получения массива {@link Array} байтов {@link Byte} с изображением пользователя или объявления. <br>
     * Использован метод сервиса {@link ImageService#getImage(String, HttpServletResponse)}. <br>
     * <br>
     *
     * @param imageName
     * @param response
     * @return {@link HttpStatus#UNAUTHORIZED} or {@link HttpStatus#OK} and {@link Array} of {@link Byte}
     * @see ImageService#getImage(String, HttpServletResponse)
     */
    @Operation(
            tags = "Изображения",
            summary = "Получение изображения пользователя или объявления",
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            description = "OK"
                    ),
                    @ApiResponse(
                            responseCode = "400",
                            description = "Bad request",
                            content = @Content(
                                    schema = @Schema(
                                            implementation = Void.class
                                    )
                            )
                    )
            }
    )
    @GetMapping(path = "/{imageName}", produces = {MediaType.IMAGE_PNG_VALUE, MediaType.IMAGE_JPEG_VALUE, MediaType.IMAGE_GIF_VALUE})
    public ResponseEntity<byte[]> downloadImage(@Parameter(description = "Ссылка на изображение в файловой системе", example = "user_1.png") @PathVariable String imageName, HttpServletResponse response) {
        try {
            return imageService.getImage(imageName, response);
        } catch (IOException e) {
            log.error(e.getMessage());
            return ResponseEntity.status(400).build();
        }
    }
}
```

- сервис:

```java
import org.apache.log4j.Logger;
import org.apache.tika.Tika;
import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import service.ImageService;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Array;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * An implementation of the service for processing ads and ad commits requests {@link ImageService}. <br>
 * <br>
 * <hr>
 * <br>
 * Реализация сервиса для обработки запросов объявлений и комментариев к объявлениям {@link ImageService}. <br>
 * <br>
 *
 * @see ImageService
 */
@Service
public class ImageServiceImpl implements ImageService {
    @Value("${user.image.dir.path}")
    private String userImageDir;
    @Value("${ad.image.dir.path}")
    private String addsImageDir;
    private static final Logger log = Logger.getLogger(ImageServiceImpl.class);

    /**
     * A method of the service for getting {@link Array} of {@link Byte} with image of user or ad. <br>
     * <br>
     * <hr>
     * <br>
     * Метод сервиса для получения массива {@link Array} байтов {@link Byte} с изображением пользователя или объявления. <br>
     * <br>
     *
     * @param imageName
     * @param response
     * @return {@link HttpStatus#OK} and {@link Array} of {@link Byte}
     * @throws IOException
     * @see ImageService#getImage(String, HttpServletResponse)
     */
    @Override
    public ResponseEntity<byte[]> getImage(String imageName, HttpServletResponse response) throws IOException {
        Path imagePath = Path.of(userImageDir, imageName);
        if (!Files.isExecutable(imagePath)) {
            imagePath = Path.of(addsImageDir, imageName);
        }
        if (!Files.isExecutable(imagePath)) {
            throw new IOException("File doesn't exist");
        }
        Tika tika = new Tika();
        String mimeType = tika.detect(imagePath);
        MediaType mediaType = MediaType.parseMediaType(mimeType);
        byte[] imageInBytes = new byte[(int) Files.size(imagePath)];
        try (
                InputStream is = Files.newInputStream(imagePath)
        ) {
            IOUtils.readFully(is, imageInBytes);
        } catch (IOException e) {
            log.error(e.getMessage());
        }
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(mediaType);
        headers.setContentLength(imageInBytes.length);
        headers.setContentDispositionFormData(imageName, imageName);
        return ResponseEntity.ok().headers(headers).body(imageInBytes);
    }
}
```

- модель:

```java
import dto.Role;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;
import java.util.Objects;

import static javax.persistence.GenerationType.IDENTITY;

/**
 * DAO <br>
 * <hr>
 * <br>
 * User { <br><br>
 * Integer id <br>
 * id пользователя <br><br>
 * String email <br>
 * логин пользователя <br><br>
 * String firstName <br>
 * имя пользователя <br><br>
 * String lastName <br>
 * фамилия пользователя <br><br>
 * String phone <br>
 * телефон пользователя <br><br>
 * {@link Role} role <br>
 * роль пользователя <br><br>
 * String image <br>
 * ссылка на аватар пользователя <br><br>
 * String password <br>
 * minLength: 8 <br>
 * maxLength: 16 <br>
 * текущий пароль <br>
 * }
 */
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Integer id;
    private String email;
    private String firstName;
    private String lastName;
    private String phone;
    private Role role;
    private String image;
    private String password;

    public User() {
    }

    public User(Integer id, String email, String firstName, String lastName, String phone, Role role, String image, String password) {
        this.id = id;
        this.email = email;
        this.firstName = firstName;
        this.lastName = lastName;
        this.phone = phone;
        this.role = role;
        this.image = image;
        this.password = password;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id) && Objects.equals(email, user.email) && Objects.equals(firstName, user.firstName) && Objects.equals(lastName, user.lastName) && Objects.equals(phone, user.phone) && role == user.role;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, email, firstName, lastName, phone, role);
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", email='" + email + '\'' +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", phone='" + phone + '\'' +
                ", role=" + role +
                ", image='" + image + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```

```java
import com.fasterxml.jackson.annotation.JsonBackReference;

import javax.persistence.*;
import java.util.Objects;

import static javax.persistence.GenerationType.IDENTITY;

/**
 * DAO <br>
 * <hr>
 * <br>
 * Ad { <br><br>
 * Integer pk <br>
 * id автора объявления <br><br>
 * {@link User} author <br>
 * автор объявления <br><br>
 * String image <br>
 * ссылка на картинку объявления <br><br>
 * int price <br>
 * цена объявления <br><br>
 * String title <br>
 * заголовок объявления <br><br>
 * String description <br>
 * описание объявления <br>
 * }
 */
@Entity
@Table(name = "ad")
public class Ad {
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Integer pk;
    @ManyToOne(fetch = FetchType.EAGER)
    private User author;
    private String image;
    private int price;
    private String title;
    private String description;

    public Ad() {
    }

    public Ad(Integer pk, User author, String image, int price, String title, String description) {
        this.pk = pk;
        this.author = author;
        this.image = image;
        this.price = price;
        this.title = title;
        this.description = description;
    }

    public Integer getPk() {
        return pk;
    }

    public void setPk(Integer pk) {
        this.pk = pk;
    }

    @JsonBackReference
    public User getAuthor() {
        return author;
    }

    public void setAuthor(User author) {
        this.author = author;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Ad ad = (Ad) o;
        return price == ad.price && Objects.equals(pk, ad.pk) && Objects.equals(author, ad.author) && Objects.equals(image, ad.image) && Objects.equals(title, ad.title) && Objects.equals(description, ad.description);
    }

    @Override
    public int hashCode() {
        return Objects.hash(pk, author, image, price, title, description);
    }

    @Override
    public String toString() {
        return "Ad{" +
                "pk=" + pk +
                ", author=" + author +
                ", image='" + image + '\'' +
                ", price=" + price +
                ", title='" + title + '\'' +
                ", description='" + description + '\'' +
                '}';
    }
}
```

- DTO:

```java
import io.swagger.v3.oas.annotations.media.Schema;

/**
 * DTO <br>
 * <hr>
 * <br>
 * User { <br><br>
 * id	integer($int32) <br>
 * id пользователя <br><br>
 * email	string <br>
 * логин пользователя <br><br>
 * firstName	string <br>
 * имя пользователя <br><br>
 * lastName	string <br>
 * фамилия пользователя <br><br>
 * phone	string <br>
 * телефон пользователя <br><br>
 * {@link Role}	string <br>
 * роль пользователя <br><br>
 * image	string <br>
 * ссылка на аватар пользователя <br>
 * }
 */
public class UserDTO {
    @Schema(example = "1", description = "id пользователя")
    private int id;
    @Schema(example = "user@test.com", description = "логин автора объявления")
    private String email;
    @Schema(example = "Иван", description = "имя пользователя", minLength = 2, maxLength = 16)
    private String firstName;
    @Schema(example = "Иванов", description = "фамилия пользователя", minLength = 2, maxLength = 16)
    private String lastName;
    @Schema(example = "+79998887766", description = "телефон пользователя", pattern = "\\+7\\s?\\(?\\d{3}\\)?\\s?\\d{3}-?\\d{2}-?\\d{2}")
    private String phone;
    @Schema(description = "роль пользователя")
    private Role role;
    @Schema(example = "/user_1.png", description = "ссылка на картинку объявления")
    private String image;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }
}
```

```java
import io.swagger.v3.oas.annotations.media.Schema;

/**
 * DTO <br>
 * <hr>
 * <br>
 * Ad { <br><br>
 * author	integer($int32) <br>
 * id автора объявления <br><br>
 * image	string <br>
 * ссылка на картинку объявления <br><br>
 * pk	integer($int32) <br>
 * id объявления <br><br>
 * price	integer($int32) <br>
 * цена объявления <br><br>
 * title	string <br>
 * заголовок объявления <br>
 * }
 */
public class AdDTO {
    @Schema(example = "1", description = "id автора объявления")
    private int author;
    @Schema(example = "/user_1_ad_1.png", description = "ссылка на картинку объявления")
    private String image;
    @Schema(example = "1", description = "id объявления")
    private int pk;
    @Schema(example = "1000", description = "цена объявления")
    private int price;
    @Schema(example = "Новое объявление", description = "заголовок объявления")
    private String title;

    public int getAuthor() {
        return author;
    }

    public void setAuthor(int author) {
        this.author = author;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public int getPk() {
        return pk;
    }

    public void setPk(int pk) {
        this.pk = pk;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}
```

- репозиторий:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import entity.User;

import java.util.Optional;

/**
 * {@link JpaRepository} for storage DAO {@link User} and operating with it. <br>
 * <br>
 * <hr>
 * <br>
 * {@link JpaRepository} для хранения DAO {@link User} и работы с ней. <br>
 * <br>
 *
 * @see JpaRepository
 */
@Repository
public interface UserRepository extends JpaRepository<User, Integer> {
    Optional<User> findByEmail(String email);
}
```

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import entity.Ad;
import entity.User;

import java.util.List;
import java.util.Optional;

/**
 * {@link JpaRepository} for storage DAO {@link Ad} and operating with it. <br>
 * <br>
 * <hr>
 * <br>
 * {@link JpaRepository} для хранения DAO {@link Ad} и работы с ней. <br>
 * <br>
 *
 * @see JpaRepository
 */
@Repository
public interface AdRepository extends JpaRepository<Ad, Integer> {
    List<Ad> findByAuthor(User user);

    Optional<Ad> findByPk(Integer pk);
}
```

- маппер:

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import dto.*;
import entity.User;

/**
 * {@link Mapper} that converts DAO {@link User} to DTO's {@link UserDTO}, {@link UpdateUserDTO}, {@link RegisterDTO}, {@link ExtendedAdDTO} and {@link LoginDTO}, and vice versa. <br>
 * <br>
 * <hr>
 * <br>
 * {@link Mapper}, который конвертирует DAO {@link User} в DTO {@link UserDTO}, {@link UpdateUserDTO}, {@link RegisterDTO}, {@link ExtendedAdDTO} и {@link LoginDTO}, и наоборот. <br>
 * <br>
 *
 * @see Mapper
 */
@Mapper(componentModel = "spring")
public interface UserMapper {
    default UserDTO userToUserDto(User user) {
        if (user == null) {
            return null;
        }
        UserDTO userDTO = new UserDTO();
        if (user.getId() != null) {
            userDTO.setId(user.getId());
        }
        userDTO.setEmail(user.getEmail());
        userDTO.setFirstName(user.getFirstName());
        userDTO.setLastName(user.getLastName());
        userDTO.setPhone(user.getPhone());
        userDTO.setRole(user.getRole());
        userDTO.setImage("/" + user.getImage());
        return userDTO;
    }

    User userDtoToUser(UserDTO user);

    User updateUserDtoToUser(UpdateUserDTO updateUser);

    UpdateUserDTO userToUpdateUserDto(User user);

    @Mapping(target = "email", source = "register.username")
    User registerDtoToUser(RegisterDTO register);

    @Mapping(target = "firstName", source = "extendedAd.authorFirstName")
    @Mapping(target = "lastName", source = "extendedAd.authorLastName")
    @Mapping(target = "image", ignore = true)
    User extendedAdToUser(ExtendedAdDTO extendedAd);

    @Mapping(target = "username", source = "user.email")
    LoginDTO userToLoginDto(User user);

    @Mapping(target = "email", source = "loginDTO.username")
    User loginDtoToUser(LoginDTO loginDTO);
}

```

```java
import org.mapstruct.Mapper;
import dto.*;
import entity.Ad;
import entity.User;

import java.util.ArrayList;
import java.util.List;

/**
 * {@link Mapper} that converts DAO {@link Ad} to DTO's {@link AdDTO}, {@link AdsDTO}, {@link CreateOrUpdateAdDTO} and {@link ExtendedAdDTO}, and vice versa. <br>
 * <br>
 * <hr>
 * <br>
 * {@link Mapper}, который конвертирует DAO {@link Ad} в DTO {@link AdDTO}, {@link AdsDTO}, {@link CreateOrUpdateAdDTO} и {@link ExtendedAdDTO}, и наоборот. <br>
 * <br>
 *
 * @see Mapper
 */
@Mapper(componentModel = "spring")
public interface AdMapper {
    default AdDTO adToAdDto(Ad ad) {
        AdDTO adDto = new AdDTO();
        adDto.setAuthor(ad.getAuthor().getId());
        adDto.setImage("/" + ad.getImage());
        adDto.setPk(ad.getPk());
        adDto.setPrice(ad.getPrice());
        adDto.setTitle(ad.getTitle());
        return adDto;
    }

    default AdsDTO adsListToAdsDto(List<Ad> adsList) {
        AdsDTO ads = new AdsDTO();
        ads.setCount(adsList.size());
        List<AdDTO> adsDtoList = new ArrayList<>();
        for (Ad ad : adsList) {
            AdDTO adDto = adToAdDto(ad);
            adsDtoList.add(adDto);
        }
        ads.setResults(adsDtoList);
        return ads;
    }

    Ad createOrUpdateAdDtoToAd(CreateOrUpdateAdDTO createOrUpdateAd);

    CreateOrUpdateAdDTO adToCreateOrUpdateDto(Ad ad);

    default Ad extendedAdDtoToAd(ExtendedAdDTO extendedAd, User author) {
        Ad ad = new Ad(extendedAd.getPk(), author, extendedAd.getImage(), extendedAd.getPrice(), extendedAd.getTitle(), extendedAd.getDescription());
        return ad;
    }

    default ExtendedAdDTO adToExtendedAd(Ad ad, User author) {
        ExtendedAdDTO extendedAd = new ExtendedAdDTO();
        extendedAd.setPk(ad.getPk());
        extendedAd.setAuthorFirstName(author.getFirstName());
        extendedAd.setAuthorLastName(author.getLastName());
        extendedAd.setDescription(ad.getDescription());
        extendedAd.setEmail(author.getEmail());
        extendedAd.setImage("/" + ad.getImage());
        extendedAd.setPhone(author.getPhone());
        extendedAd.setPrice(ad.getPrice());
        extendedAd.setTitle(ad.getTitle());
        return extendedAd;
    }
}
```

- тест:

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.tika.io.IOUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.test.mock.mockito.SpyBean;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import config.ClockConfig;
import config.PasswordEncoderConfig;
import config.SecurityFilterChainConfig;
import controller.AdsController;
import controller.AuthenticationController;
import controller.ImageController;
import controller.UsersController;
import dto.*;
import entity.Ad;
import entity.Comment;
import mapper.AdMapper;
import mapper.CommentMapper;
import mapper.UserMapper;
import repository.AdRepository;
import repository.CommentRepository;
import repository.UserRepository;
import service.impl.AdsServiceImpl;
import service.impl.AuthenticationServiceImpl;
import service.impl.ImageServiceImpl;
import service.impl.UsersServiceImpl;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Clock;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.lenient;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.anonymous;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.user;
import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.springSecurity;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static constants.Constants.*;

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@TestPropertySource(locations = "classpath:application-test.properties")
class HomeworkApplicationTest {
    @Value("${user.image.dir.path}")
    private String userImageDir;
    @Value("${ad.image.dir.path}")
    private String adsImageDir;
    @Value("${source.image.dir.path}")
    private String sourceImageDir;
    private AdDTO AD_1_DTO = new AdDTO();
    private AdDTO AD_2_DTO = new AdDTO();
    private AdDTO AD_3_DTO = new AdDTO();
    private AdsDTO ADS_DTO = new AdsDTO();
    private AdsDTO ADS_USER_DTO = new AdsDTO();
    private AdsDTO ADS_ADMIN_DTO = new AdsDTO();
    private CommentDTO COMMENT_1_DTO = new CommentDTO();
    private CommentDTO COMMENT_2_DTO = new CommentDTO();
    private CommentDTO COMMENT_3_DTO = new CommentDTO();
    private CommentsDTO COMMENTS_DTO = new CommentsDTO();
    private CreateOrUpdateAdDTO CREATE_OR_UPDATE_AD_1_DTO = new CreateOrUpdateAdDTO();
    private CreateOrUpdateAdDTO CREATE_OR_UPDATE_AD_2_DTO = new CreateOrUpdateAdDTO();
    private CreateOrUpdateAdDTO CREATE_OR_UPDATE_AD_3_DTO = new CreateOrUpdateAdDTO();
    private CreateOrUpdateCommentDTO CREATE_OR_UPDATE_COMMENT_1_DTO = new CreateOrUpdateCommentDTO();
    private CreateOrUpdateCommentDTO CREATE_OR_UPDATE_COMMENT_2_DTO = new CreateOrUpdateCommentDTO();
    private CreateOrUpdateCommentDTO CREATE_OR_UPDATE_COMMENT_3_DTO = new CreateOrUpdateCommentDTO();
    private ExtendedAdDTO EXTENDED_AD_1_DTO = new ExtendedAdDTO();
    private ExtendedAdDTO EXTENDED_AD_2_DTO = new ExtendedAdDTO();
    private ExtendedAdDTO EXTENDED_AD_3_DTO = new ExtendedAdDTO();
    private LoginDTO LOGIN_USER_DTO = new LoginDTO();
    private LoginDTO LOGIN_ADMIN_DTO = new LoginDTO();
    private LoginDTO LOGIN_ANOTHER_USER_DTO = new LoginDTO();
    private NewPasswordDTO NEW_PASSWORD_USER_DTO = new NewPasswordDTO();
    private NewPasswordDTO NEW_PASSWORD_ANOTHER_USER_DTO = new NewPasswordDTO();
    private NewPasswordDTO NEW_PASSWORD_ADMIN_DTO = new NewPasswordDTO();
    private RegisterDTO REGISTER_USER_DTO = new RegisterDTO();
    private RegisterDTO REGISTER_ADMIN_DTO = new RegisterDTO();
    private RegisterDTO REGISTER_ANOTHER_USER_DTO = new RegisterDTO();
    private UpdateUserDTO UPDATE_USER_DTO = new UpdateUserDTO();
    private UpdateUserDTO UPDATE_ADMIN_DTO = new UpdateUserDTO();
    private UserDTO USER_DTO = new UserDTO();
    private UserDTO ADMIN_DTO = new UserDTO();
    @Autowired
    MockMvc mockMvc;
    @Autowired
    WebApplicationContext context;
    @MockBean
    PasswordEncoderConfig passwordEncoderConfig;
    @MockBean
    DaoAuthenticationProvider daoAuthenticationProvider;
    @MockBean
    BCryptPasswordEncoder passwordEncoder;
    @Autowired
    SecurityFilterChainConfig securityFilterChainConfig;
    @MockBean
    AdRepository adRepository;
    @MockBean
    CommentRepository commentRepository;
    @MockBean
    UserRepository userRepository;
    @Autowired
    AdMapper adMapper;
    @Autowired
    CommentMapper commentMapper;
    @Autowired
    UserMapper userMapper;
    @SpyBean
    AdsServiceImpl adsService;
    @SpyBean
    AuthenticationServiceImpl authenticationService;
    @SpyBean
    ImageServiceImpl imageService;
    @SpyBean
    UsersServiceImpl usersService;
    @Autowired
    AdsController adsController;
    @Autowired
    AuthenticationController authenticationController;
    @Autowired
    ImageController imageController;
    @Autowired
    UsersController usersController;
    @MockBean
    Clock clock;
    @MockBean
    ClockConfig clockConfig;

    @BeforeEach
    void setUp() {
        mockMvc = MockMvcBuilders
                .webAppContextSetup(context)
                .apply(springSecurity())
                .build();
        AD_1_DTO.setAuthor(AD_1.getAuthor().getId());
        AD_1_DTO.setImage("/" + AD_1.getImage());
        AD_1_DTO.setPk(AD_1.getPk());
        AD_1_DTO.setPrice(AD_1.getPrice());
        AD_1_DTO.setTitle(AD_1.getTitle());
        AD_2_DTO.setAuthor(AD_2.getAuthor().getId());
        AD_2_DTO.setImage("/" + AD_2.getImage());
        AD_2_DTO.setPk(AD_2.getPk());
        AD_2_DTO.setPrice(AD_2.getPrice());
        AD_2_DTO.setTitle(AD_2.getTitle());
        AD_3_DTO.setAuthor(AD_3.getAuthor().getId());
        AD_3_DTO.setImage("/" + AD_3.getImage());
        AD_3_DTO.setPk(AD_3.getPk());
        AD_3_DTO.setPrice(AD_3.getPrice());
        AD_3_DTO.setTitle(AD_3.getTitle());
        ADS_DTO.setCount(3);
        ADS_DTO.setResults(List.of(AD_1_DTO, AD_2_DTO, AD_3_DTO));
        ADS_USER_DTO.setCount(2);
        ADS_USER_DTO.setResults(List.of(AD_1_DTO, AD_2_DTO));
        ADS_ADMIN_DTO.setCount(1);
        ADS_ADMIN_DTO.setResults(List.of(AD_3_DTO));
        COMMENT_1_DTO.setAuthor(COMMENT_1.getAuthor().getId());
        COMMENT_1_DTO.setAuthorImage("/" + COMMENT_1.getAuthorImage());
        COMMENT_1_DTO.setAuthorFirstName(COMMENT_1.getAuthorFirstName());
        COMMENT_1_DTO.setCreatedAt(COMMENT_1.getCreatedAt());
        COMMENT_1_DTO.setPk(COMMENT_1.getPk());
        COMMENT_1_DTO.setText(COMMENT_1.getText());
        COMMENT_2_DTO.setAuthor(COMMENT_2.getAuthor().getId());
        COMMENT_2_DTO.setAuthorImage("/" + COMMENT_2.getAuthorImage());
        COMMENT_2_DTO.setAuthorFirstName(COMMENT_2.getAuthorFirstName());
        COMMENT_2_DTO.setCreatedAt(COMMENT_2.getCreatedAt());
        COMMENT_2_DTO.setPk(COMMENT_2.getPk());
        COMMENT_2_DTO.setText(COMMENT_2.getText());
        COMMENT_3_DTO.setAuthor(COMMENT_3.getAuthor().getId());
        COMMENT_3_DTO.setAuthorImage("/" + COMMENT_3.getAuthorImage());
        COMMENT_3_DTO.setAuthorFirstName(COMMENT_3.getAuthorFirstName());
        COMMENT_3_DTO.setCreatedAt(COMMENT_3.getCreatedAt());
        COMMENT_3_DTO.setPk(COMMENT_3.getPk());
        COMMENT_3_DTO.setText(COMMENT_3.getText());
        COMMENTS_DTO.setCount(3);
        COMMENTS_DTO.setResults(List.of(COMMENT_1_DTO, COMMENT_2_DTO, COMMENT_3_DTO));
        CREATE_OR_UPDATE_AD_1_DTO.setTitle(AD_1.getTitle());
        CREATE_OR_UPDATE_AD_1_DTO.setPrice(AD_1.getPrice());
        CREATE_OR_UPDATE_AD_1_DTO.setDescription(AD_1.getDescription());
        CREATE_OR_UPDATE_AD_2_DTO.setTitle(AD_2.getTitle());
        CREATE_OR_UPDATE_AD_2_DTO.setPrice(AD_2.getPrice());
        CREATE_OR_UPDATE_AD_2_DTO.setDescription(AD_2.getDescription());
        CREATE_OR_UPDATE_AD_3_DTO.setTitle(AD_3.getTitle());
        CREATE_OR_UPDATE_AD_3_DTO.setPrice(AD_3.getPrice());
        CREATE_OR_UPDATE_AD_3_DTO.setDescription(AD_3.getDescription());
        CREATE_OR_UPDATE_COMMENT_1_DTO.setText(COMMENT_1.getText());
        CREATE_OR_UPDATE_COMMENT_2_DTO.setText(COMMENT_2.getText());
        CREATE_OR_UPDATE_COMMENT_3_DTO.setText(COMMENT_3.getText());
        EXTENDED_AD_1_DTO.setPk(AD_1.getPk());
        EXTENDED_AD_1_DTO.setAuthorFirstName(AD_1.getAuthor().getFirstName());
        EXTENDED_AD_1_DTO.setAuthorLastName(AD_1.getAuthor().getLastName());
        EXTENDED_AD_1_DTO.setDescription(AD_1.getDescription());
        EXTENDED_AD_1_DTO.setEmail(AD_1.getAuthor().getEmail());
        EXTENDED_AD_1_DTO.setImage("/" + AD_1.getImage());
        EXTENDED_AD_1_DTO.setPhone(AD_1.getAuthor().getPhone());
        EXTENDED_AD_1_DTO.setPrice(AD_1.getPrice());
        EXTENDED_AD_1_DTO.setTitle(AD_1.getTitle());
        EXTENDED_AD_2_DTO.setPk(AD_2.getPk());
        EXTENDED_AD_2_DTO.setAuthorFirstName(AD_2.getAuthor().getFirstName());
        EXTENDED_AD_2_DTO.setAuthorLastName(AD_2.getAuthor().getLastName());
        EXTENDED_AD_2_DTO.setDescription(AD_2.getDescription());
        EXTENDED_AD_2_DTO.setEmail(AD_2.getAuthor().getEmail());
        EXTENDED_AD_2_DTO.setImage("/" + AD_2.getImage());
        EXTENDED_AD_2_DTO.setPhone(AD_2.getAuthor().getPhone());
        EXTENDED_AD_2_DTO.setPrice(AD_2.getPrice());
        EXTENDED_AD_2_DTO.setTitle(AD_2.getTitle());
        EXTENDED_AD_3_DTO.setPk(AD_3.getPk());
        EXTENDED_AD_3_DTO.setAuthorFirstName(AD_3.getAuthor().getFirstName());
        EXTENDED_AD_3_DTO.setAuthorLastName(AD_3.getAuthor().getLastName());
        EXTENDED_AD_3_DTO.setDescription(AD_3.getDescription());
        EXTENDED_AD_3_DTO.setEmail(AD_3.getAuthor().getEmail());
        EXTENDED_AD_3_DTO.setImage("/" + AD_3.getImage());
        EXTENDED_AD_3_DTO.setPhone(AD_3.getAuthor().getPhone());
        EXTENDED_AD_3_DTO.setPrice(AD_3.getPrice());
        EXTENDED_AD_3_DTO.setTitle(AD_3.getTitle());
        LOGIN_USER_DTO.setUsername(USER.getEmail());
        LOGIN_USER_DTO.setPassword(USER.getPassword());
        LOGIN_ADMIN_DTO.setUsername(ADMIN.getEmail());
        LOGIN_ADMIN_DTO.setPassword(ADMIN.getPassword());
        LOGIN_ANOTHER_USER_DTO.setUsername(ANOTHER_USER.getEmail());
        LOGIN_ANOTHER_USER_DTO.setPassword(ANOTHER_USER.getPassword());
        NEW_PASSWORD_USER_DTO.setCurrentPassword(USER.getPassword());
        NEW_PASSWORD_USER_DTO.setNewPassword(ADMIN.getPassword());
        NEW_PASSWORD_ADMIN_DTO.setCurrentPassword(ADMIN.getPassword());
        NEW_PASSWORD_ADMIN_DTO.setNewPassword(USER.getPassword());
        NEW_PASSWORD_ANOTHER_USER_DTO.setCurrentPassword(ANOTHER_USER.getPassword());
        NEW_PASSWORD_ANOTHER_USER_DTO.setNewPassword(ADMIN.getPassword());
        REGISTER_USER_DTO.setUsername(USER.getEmail());
        REGISTER_USER_DTO.setPassword(USER.getPassword());
        REGISTER_USER_DTO.setFirstName(USER.getFirstName());
        REGISTER_USER_DTO.setLastName(USER.getLastName());
        REGISTER_USER_DTO.setPhone(USER.getPhone());
        REGISTER_USER_DTO.setRole(USER.getRole());
        REGISTER_ADMIN_DTO.setUsername(ADMIN.getEmail());
        REGISTER_ADMIN_DTO.setPassword(ADMIN.getPassword());
        REGISTER_ADMIN_DTO.setFirstName(ADMIN.getFirstName());
        REGISTER_ADMIN_DTO.setLastName(ADMIN.getLastName());
        REGISTER_ADMIN_DTO.setPhone(ADMIN.getPhone());
        REGISTER_ADMIN_DTO.setRole(ADMIN.getRole());
        REGISTER_ANOTHER_USER_DTO.setUsername(ANOTHER_USER.getEmail());
        REGISTER_ANOTHER_USER_DTO.setPassword(ANOTHER_USER.getPassword());
        REGISTER_ANOTHER_USER_DTO.setFirstName(ANOTHER_USER.getFirstName());
        REGISTER_ANOTHER_USER_DTO.setLastName(ANOTHER_USER.getLastName());
        REGISTER_ANOTHER_USER_DTO.setPhone(ANOTHER_USER.getPhone());
        REGISTER_ANOTHER_USER_DTO.setRole(ANOTHER_USER.getRole());
        UPDATE_USER_DTO.setFirstName(USER.getFirstName());
        UPDATE_USER_DTO.setLastName(USER.getLastName());
        UPDATE_USER_DTO.setPhone(USER.getPhone());
        UPDATE_ADMIN_DTO.setFirstName(ADMIN.getFirstName());
        UPDATE_ADMIN_DTO.setLastName(ADMIN.getLastName());
        UPDATE_ADMIN_DTO.setPhone(ADMIN.getPhone());
        USER_DTO.setId(USER.getId());
        USER_DTO.setEmail(USER.getEmail());
        USER_DTO.setFirstName(USER.getFirstName());
        USER_DTO.setLastName(USER.getLastName());
        USER_DTO.setPhone(USER.getPhone());
        USER_DTO.setRole(USER.getRole());
        USER_DTO.setImage("/" + USER.getImage());
        ADMIN_DTO.setId(ADMIN.getId());
        ADMIN_DTO.setEmail(ADMIN.getEmail());
        ADMIN_DTO.setFirstName(ADMIN.getFirstName());
        ADMIN_DTO.setLastName(ADMIN.getLastName());
        ADMIN_DTO.setPhone(ADMIN.getPhone());
        ADMIN_DTO.setRole(ADMIN.getRole());
        ADMIN_DTO.setImage("/" + ADMIN.getImage());
        lenient().when(clockConfig.clock()).thenReturn(clock);
        lenient().when(clock.millis()).thenReturn(111111L);
        lenient().when(userRepository.findByEmail(USER.getEmail())).thenReturn(Optional.of(USER));
        lenient().when(userRepository.findByEmail(ADMIN.getEmail())).thenReturn(Optional.of(ADMIN));
        lenient().when(userRepository.save(USER)).thenReturn(USER);
        lenient().when(userRepository.save(ADMIN)).thenReturn(ADMIN);
        lenient().when(userRepository.save(ANOTHER_USER_REGISTER)).thenReturn(ANOTHER_USER);
        lenient().when(passwordEncoderConfig.passwordEncoder()).thenReturn(passwordEncoder);
        lenient().when(passwordEncoder.encode(USER.getPassword())).thenReturn(USER.getPassword());
        lenient().when(passwordEncoder.encode(ADMIN.getPassword())).thenReturn(ADMIN.getPassword());
        lenient().when(passwordEncoder.encode(ANOTHER_USER.getPassword())).thenReturn(ANOTHER_USER.getPassword());
        lenient().when(passwordEncoder.matches(USER.getPassword(), USER.getPassword())).thenReturn(true);
        lenient().when(passwordEncoder.matches(ADMIN.getPassword(), ADMIN.getPassword())).thenReturn(true);
        lenient().when(adRepository.findAll()).thenReturn(ADS);
        lenient().when(adRepository.findByPk(AD_1.getPk())).thenReturn(Optional.of(AD_1));
        lenient().when(adRepository.findByPk(AD_2.getPk())).thenReturn(Optional.of(AD_2));
        lenient().when(adRepository.findByPk(AD_3.getPk())).thenReturn(Optional.of(AD_3));
        lenient().doNothing().when(adRepository).delete(any(Ad.class));
        lenient().when(adRepository.save(AD_1)).thenReturn(AD_1);
        lenient().when(adRepository.save(AD_2)).thenReturn(AD_2);
        lenient().when(adRepository.save(AD_3)).thenReturn(AD_3);
        lenient().when(adRepository.save(AD_1_CREATE)).thenReturn(AD_1);
        lenient().when(adRepository.save(AD_2_CREATE)).thenReturn(AD_2);
        lenient().when(adRepository.save(AD_3_CREATE)).thenReturn(AD_3);
        lenient().when(adRepository.findByAuthor(USER)).thenReturn(ADS_USER);
        lenient().when(adRepository.findByAuthor(ADMIN)).thenReturn(ADS_ADMIN);
        lenient().when(commentRepository.findByAd(AD_1)).thenReturn(COMMENTS);
        lenient().when(commentRepository.save(COMMENT_1_SAVE)).thenReturn(COMMENT_1);
        lenient().when(commentRepository.save(COMMENT_2_SAVE)).thenReturn(COMMENT_2);
        lenient().when(commentRepository.save(COMMENT_3_SAVE)).thenReturn(COMMENT_3);
        lenient().when(commentRepository.save(COMMENT_1)).thenReturn(COMMENT_1);
        lenient().when(commentRepository.save(COMMENT_2)).thenReturn(COMMENT_2);
        lenient().when(commentRepository.save(COMMENT_3)).thenReturn(COMMENT_3);
        lenient().when(commentRepository.findByPk(COMMENT_1.getPk())).thenReturn(Optional.of(COMMENT_1));
        lenient().when(commentRepository.findByPk(COMMENT_2.getPk())).thenReturn(Optional.of(COMMENT_2));
        lenient().when(commentRepository.findByPk(COMMENT_3.getPk())).thenReturn(Optional.of(COMMENT_3));
        lenient().doNothing().when(commentRepository).delete(any(Comment.class));
    }

    /**
     * Should return status code {@link HttpStatus#OK} when password changed. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#FORBIDDEN} when current password not equals user password. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK}, когда пароль изменён. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#FORBIDDEN}, когда текущий пароль не совпадает с паролем пользователя. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void setPassword() throws Exception {
        mockMvc.perform(post("/users/set_password")
                                .with(user(USER.getEmail()).password(USER.getPassword()))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(NEW_PASSWORD_USER_DTO)))
               .andExpect(status().isOk());
        mockMvc.perform(post("/users/set_password")
                                .with(user(ADMIN.getEmail()).password(ADMIN.getPassword()))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(NEW_PASSWORD_ADMIN_DTO)))
               .andExpect(status().isOk());
        mockMvc.perform(post("/users/set_password")
                                .with(anonymous())
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(NEW_PASSWORD_ANOTHER_USER_DTO)))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(post("/users/set_password")
                                .with(user(ADMIN.getEmail()).password(ADMIN.getPassword()))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(NEW_PASSWORD_ANOTHER_USER_DTO)))
               .andExpect(status().isForbidden());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link UserDTO} when user is authorized. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link UserDTO}, когда пользователь авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void me() throws Exception {
        mockMvc.perform(get("/users/me")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.id").value(USER_DTO.getId()))
               .andExpect(jsonPath("$.email").value(USER_DTO.getEmail()))
               .andExpect(jsonPath("$.firstName").value(USER_DTO.getFirstName()))
               .andExpect(jsonPath("$.lastName").value(USER_DTO.getLastName()))
               .andExpect(jsonPath("$.role").value(String.valueOf(USER_DTO.getRole())))
               .andExpect(jsonPath("$.image").value(USER_DTO.getImage()));
        mockMvc.perform(get("/users/me")
                                .with(user("admin@test.com").password("321"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.id").value(ADMIN_DTO.getId()))
               .andExpect(jsonPath("$.email").value(ADMIN_DTO.getEmail()))
               .andExpect(jsonPath("$.firstName").value(ADMIN_DTO.getFirstName()))
               .andExpect(jsonPath("$.lastName").value(ADMIN_DTO.getLastName()))
               .andExpect(jsonPath("$.role").value(String.valueOf(ADMIN_DTO.getRole())))
               .andExpect(jsonPath("$.image").value(ADMIN_DTO.getImage()));
        mockMvc.perform(get("/users/me")
                                .with(anonymous())
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link UpdateUserDTO} when user is authorized. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link UpdateUserDTO}, когда пользователь авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void meUpdate() throws Exception {
        mockMvc.perform(patch("/users/me")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(UPDATE_USER_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.firstName").value(UPDATE_USER_DTO.getFirstName()))
               .andExpect(jsonPath("$.lastName").value(UPDATE_USER_DTO.getLastName()))
               .andExpect(jsonPath("$.phone").value(UPDATE_USER_DTO.getPhone()));
        mockMvc.perform(patch("/users/me")
                                .with(user("admin@test.com").password("321"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(UPDATE_ADMIN_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.firstName").value(UPDATE_ADMIN_DTO.getFirstName()))
               .andExpect(jsonPath("$.lastName").value(UPDATE_ADMIN_DTO.getLastName()))
               .andExpect(jsonPath("$.phone").value(UPDATE_ADMIN_DTO.getPhone()));
        mockMvc.perform(patch("/users/me")
                                .with(anonymous())
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(UPDATE_ADMIN_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
    }

    /**
     * Should return status code {@link HttpStatus#OK} when user is authorized. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK}, когда пользователь авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void meImage() throws Exception {
        byte[] inputImage = Files.readAllBytes(Path.of(sourceImageDir, "user.jpg"));
        MockMultipartFile multipartFile = new MockMultipartFile("image", "user.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/users/me/image").file(multipartFile)
                                                                      .with(user("user@test.com").password("123")))
               .andExpect(status().isOk());
        byte[] result = Files.readAllBytes(Path.of(userImageDir, USER.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(result);
                InputStream inputStream2 = new FileInputStream(Path.of(userImageDir, USER.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "admin.jpg"));
        multipartFile = new MockMultipartFile("image", "admin.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/users/me/image").file(multipartFile)
                                                                      .with(user("admin@test.com").password("321")))
               .andExpect(status().isOk());
        result = Files.readAllBytes(Path.of(userImageDir, ADMIN.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(result);
                InputStream inputStream2 = new FileInputStream(Path.of(userImageDir, ADMIN.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "user.jpg"));
        multipartFile = new MockMultipartFile("image", "user.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/users/me/image").file(multipartFile)
                                                                      .with(anonymous()))
               .andExpect(status().isUnauthorized());
    }

    /**
     * Should return status code {@link HttpStatus#OK} when user is authorized. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK}, когда пользователь авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void login() throws Exception {
        mockMvc.perform(post("/login")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(LOGIN_USER_DTO)))
               .andExpect(status().isOk());
        mockMvc.perform(post("/login")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(LOGIN_ADMIN_DTO)))
               .andExpect(status().isOk());
        mockMvc.perform(post("/login")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(LOGIN_ANOTHER_USER_DTO)))
               .andExpect(status().isUnauthorized());
    }

    /**
     * Should return status code {@link HttpStatus#CREATED} when user is registered. <br>
     * Should return status code {@link HttpStatus#BAD_REQUEST} when user already registered before. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#CREATED}, когда пользователь зарегистрирован. <br>
     * Должен возвращать статус-код {@link HttpStatus#BAD_REQUEST}, когда пользователь был зарегистрирован ранее. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void register() throws Exception {
        mockMvc.perform(post("/register")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(REGISTER_USER_DTO)))
               .andExpect(status().isBadRequest());
        mockMvc.perform(post("/register")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(REGISTER_ADMIN_DTO)))
               .andExpect(status().isBadRequest());
        mockMvc.perform(post("/register")
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(REGISTER_ANOTHER_USER_DTO)))
               .andExpect(status().isCreated());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link AdsDTO}. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} {@link AdsDTO}. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void getAll() throws Exception {
        mockMvc.perform(get("/ads")
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.count").value(ADS_DTO.getCount()))
               .andExpect(jsonPath("$.results[0].author").value(AD_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[0].image").value(AD_1_DTO.getImage()))
               .andExpect(jsonPath("$.results[0].pk").value(AD_1_DTO.getPk()))
               .andExpect(jsonPath("$.results[0].price").value(AD_1_DTO.getPrice()))
               .andExpect(jsonPath("$.results[0].title").value(AD_1_DTO.getTitle()))
               .andExpect(jsonPath("$.results[1].author").value(AD_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[1].image").value(AD_2_DTO.getImage()))
               .andExpect(jsonPath("$.results[1].pk").value(AD_2_DTO.getPk()))
               .andExpect(jsonPath("$.results[1].price").value(AD_2_DTO.getPrice()))
               .andExpect(jsonPath("$.results[1].title").value(AD_2_DTO.getTitle()))
               .andExpect(jsonPath("$.results[2].author").value(AD_3_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[2].image").value(AD_3_DTO.getImage()))
               .andExpect(jsonPath("$.results[2].pk").value(AD_3_DTO.getPk()))
               .andExpect(jsonPath("$.results[2].price").value(AD_3_DTO.getPrice()))
               .andExpect(jsonPath("$.results[2].title").value(AD_3_DTO.getTitle()));
    }

    /**
     * Should return status code {@link HttpStatus#CREATED} and {@link AdDTO} when ad created. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#CREATED} и {@link AdDTO}, когда объявление создано. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void postAd() throws Exception {
        byte[] inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_1.jpg"));
        MockMultipartFile multipartFile = new MockMultipartFile("image", "ad_1.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        MockMultipartFile propertiesFile = new MockMultipartFile("properties", "properties", MediaType.APPLICATION_JSON_VALUE, new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_1_DTO).getBytes());
        mockMvc.perform(multipart(HttpMethod.POST, "/ads").file(multipartFile).file(propertiesFile)
                                                          .with(user("user@test.com").password("123"))
                                                          .contentType(MediaType.MULTIPART_FORM_DATA_VALUE)
                                                          .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isCreated())
               .andExpect(jsonPath("$.author").value(AD_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.image").value(AD_1_DTO.getImage()))
               .andExpect(jsonPath("$.pk").value(AD_1_DTO.getPk()))
               .andExpect(jsonPath("$.price").value(AD_1_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(AD_1_DTO.getTitle()));
        byte[] outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_1.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_2.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_2.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        propertiesFile = new MockMultipartFile("properties", "properties", MediaType.APPLICATION_JSON_VALUE, new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_2_DTO).getBytes());
        mockMvc.perform(multipart(HttpMethod.POST, "/ads").file(multipartFile).file(propertiesFile)
                                                          .with(user("user@test.com").password("123"))
                                                          .contentType(MediaType.MULTIPART_FORM_DATA_VALUE)
                                                          .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isCreated())
               .andExpect(jsonPath("$.author").value(AD_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.image").value(AD_2_DTO.getImage()))
               .andExpect(jsonPath("$.pk").value(AD_2_DTO.getPk()))
               .andExpect(jsonPath("$.price").value(AD_2_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(AD_2_DTO.getTitle()));
        outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_2.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_3.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_3.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        propertiesFile = new MockMultipartFile("properties", "properties", MediaType.APPLICATION_JSON_VALUE, new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_3_DTO).getBytes());
        mockMvc.perform(multipart(HttpMethod.POST, "/ads").file(multipartFile).file(propertiesFile)
                                                          .with(user("admin@test.com").password("321"))
                                                          .contentType(MediaType.MULTIPART_FORM_DATA_VALUE)
                                                          .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isCreated())
               .andExpect(jsonPath("$.author").value(AD_3_DTO.getAuthor()))
               .andExpect(jsonPath("$.image").value(AD_3_DTO.getImage()))
               .andExpect(jsonPath("$.pk").value(AD_3_DTO.getPk()))
               .andExpect(jsonPath("$.price").value(AD_3_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(AD_3_DTO.getTitle()));
        outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_3.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_1.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_1.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        propertiesFile = new MockMultipartFile("properties", "properties", MediaType.APPLICATION_JSON_VALUE, new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_1_DTO).getBytes());
        mockMvc.perform(multipart(HttpMethod.POST, "/ads").file(multipartFile).file(propertiesFile)
                                                          .with(anonymous())
                                                          .contentType(MediaType.MULTIPART_FORM_DATA_VALUE)
                                                          .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link ExtendedAdDTO} when ad is exist. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link ExtendedAdDTO}, когда объявление существует. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда объявление не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void getAd() throws Exception {
        mockMvc.perform(get("/ads/1")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.pk").value(EXTENDED_AD_1_DTO.getPk()))
               .andExpect(jsonPath("$.authorFirstName").value(EXTENDED_AD_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.authorLastName").value(EXTENDED_AD_1_DTO.getAuthorLastName()))
               .andExpect(jsonPath("$.description").value(EXTENDED_AD_1_DTO.getDescription()))
               .andExpect(jsonPath("$.email").value(EXTENDED_AD_1_DTO.getEmail()))
               .andExpect(jsonPath("$.image").value(EXTENDED_AD_1_DTO.getImage()))
               .andExpect(jsonPath("$.phone").value(EXTENDED_AD_1_DTO.getPhone()))
               .andExpect(jsonPath("$.price").value(EXTENDED_AD_1_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(EXTENDED_AD_1_DTO.getTitle()));
        mockMvc.perform(get("/ads/1")
                                .with(user("admin@test.com").password("321"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.pk").value(EXTENDED_AD_1_DTO.getPk()))
               .andExpect(jsonPath("$.authorFirstName").value(EXTENDED_AD_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.authorLastName").value(EXTENDED_AD_1_DTO.getAuthorLastName()))
               .andExpect(jsonPath("$.description").value(EXTENDED_AD_1_DTO.getDescription()))
               .andExpect(jsonPath("$.email").value(EXTENDED_AD_1_DTO.getEmail()))
               .andExpect(jsonPath("$.image").value(EXTENDED_AD_1_DTO.getImage()))
               .andExpect(jsonPath("$.phone").value(EXTENDED_AD_1_DTO.getPhone()))
               .andExpect(jsonPath("$.price").value(EXTENDED_AD_1_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(EXTENDED_AD_1_DTO.getTitle()));
        mockMvc.perform(get("/ads/1")
                                .with(anonymous())
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(get("/ads/4")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#NO_CONTENT} when ad is deleted. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#FORBIDDEN} when user doesn't have such rights. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#NO_CONTENT}, когда объявление удалено. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#FORBIDDEN}, когда пользователь не имеет таких прав. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда объявление не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void deleteAd() throws Exception {
        mockMvc.perform(delete("/ads/1")
                                .with(user("user@test.com").password("123")))
               .andExpect(status().isNoContent());
        mockMvc.perform(delete("/ads/1")
                                .with(user("admin@test.com").password("321")))
               .andExpect(status().isNoContent());
        mockMvc.perform(delete("/ads/1")
                                .with(anonymous()))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(delete("/ads/3")
                                .with(user("user@test.com").password("123")))
               .andExpect(status().isForbidden());
        mockMvc.perform(delete("/ads/4")
                                .with(user("user@test.com").password("123")))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link AdDTO} when ad is updated. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#FORBIDDEN} when user doesn't have such rights. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link AdDTO}, когда объявление обновлено. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#FORBIDDEN}, когда пользователь не имеет таких прав. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда объявление не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void updateAd() throws Exception {
        mockMvc.perform(patch("/ads/2")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_2_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.author").value(AD_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.image").value(AD_2_DTO.getImage()))
               .andExpect(jsonPath("$.pk").value(AD_2_DTO.getPk()))
               .andExpect(jsonPath("$.price").value(AD_2_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(AD_2_DTO.getTitle()));
        mockMvc.perform(patch("/ads/2")
                                .with(user("admin@test.com").password("321"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_2_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.author").value(AD_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.image").value(AD_2_DTO.getImage()))
               .andExpect(jsonPath("$.pk").value(AD_2_DTO.getPk()))
               .andExpect(jsonPath("$.price").value(AD_2_DTO.getPrice()))
               .andExpect(jsonPath("$.title").value(AD_2_DTO.getTitle()));
        mockMvc.perform(patch("/ads/2")
                                .with(anonymous())
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_2_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(patch("/ads/3")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_2_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isForbidden());
        mockMvc.perform(patch("/ads/4")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_AD_2_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link AdsDTO} when user is authorized. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link AdsDTO}, когда пользователь авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void getMe() throws Exception {
        mockMvc.perform(get("/ads/me")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.count").value(ADS_USER_DTO.getCount()))
               .andExpect(jsonPath("$.results[0].author").value(AD_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[0].image").value(AD_1_DTO.getImage()))
               .andExpect(jsonPath("$.results[0].pk").value(AD_1_DTO.getPk()))
               .andExpect(jsonPath("$.results[0].price").value(AD_1_DTO.getPrice()))
               .andExpect(jsonPath("$.results[0].title").value(AD_1_DTO.getTitle()))
               .andExpect(jsonPath("$.results[1].author").value(AD_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[1].image").value(AD_2_DTO.getImage()))
               .andExpect(jsonPath("$.results[1].pk").value(AD_2_DTO.getPk()))
               .andExpect(jsonPath("$.results[1].price").value(AD_2_DTO.getPrice()))
               .andExpect(jsonPath("$.results[1].title").value(AD_2_DTO.getTitle()));
        mockMvc.perform(get("/ads/me")
                                .with(user("admin@test.com").password("321"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.count").value(ADS_ADMIN_DTO.getCount()))
               .andExpect(jsonPath("$.results[0].author").value(AD_3_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[0].image").value(AD_3_DTO.getImage()))
               .andExpect(jsonPath("$.results[0].pk").value(AD_3_DTO.getPk()))
               .andExpect(jsonPath("$.results[0].price").value(AD_3_DTO.getPrice()))
               .andExpect(jsonPath("$.results[0].title").value(AD_3_DTO.getTitle()));
        mockMvc.perform(get("/ads/me")
                                .with(anonymous())
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link String} when ad image is updated. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#FORBIDDEN} when user doesn't have such rights. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link String}, когда изображение объявления обновлено. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#FORBIDDEN}, когда пользователь не имеет таких прав. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда объявление не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void patchAdImage() throws Exception {
        byte[] inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_1.jpg"));
        MockMultipartFile multipartFile = new MockMultipartFile("image", "ad_1.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/1/image").file(multipartFile)
                                                                   .with(user("user@test.com").password("123"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(content().string(String.valueOf(Path.of(adsImageDir, AD_1.getImage()))));
        byte[] outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_1.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_2.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_2.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/2/image").file(multipartFile)
                                                                   .with(user("user@test.com").password("123"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(content().string(String.valueOf(Path.of(adsImageDir, AD_2.getImage()))));
        outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_2.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_3.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_3.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/3/image").file(multipartFile)
                                                                   .with(user("user@test.com").password("123"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isForbidden());
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_1.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_1.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/1/image").file(multipartFile)
                                                                   .with(user("admin@test.com").password("321"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(content().string(String.valueOf(Path.of(adsImageDir, AD_1.getImage()))));
        outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_1.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_2.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_2.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/2/image").file(multipartFile)
                                                                   .with(user("admin@test.com").password("321"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(content().string(String.valueOf(Path.of(adsImageDir, AD_2.getImage()))));
        outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_2.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_3.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_3.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/3/image").file(multipartFile)
                                                                   .with(user("admin@test.com").password("321"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(content().string(String.valueOf(Path.of(adsImageDir, AD_3.getImage()))));
        outputImage = Files.readAllBytes(Path.of(adsImageDir, AD_3.getImage()));
        try (
                InputStream inputStream1 = new ByteArrayInputStream(inputImage);
                InputStream inputStream2 = new ByteArrayInputStream(outputImage)
        ) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_3.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_3.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/3/image").file(multipartFile)
                                                                   .with(anonymous())
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        inputImage = Files.readAllBytes(Path.of(sourceImageDir, "ad_1.jpg"));
        multipartFile = new MockMultipartFile("image", "ad_1.jpg", MediaType.IMAGE_JPEG_VALUE, inputImage);
        mockMvc.perform(multipart(HttpMethod.PATCH, "/ads/4/image").file(multipartFile)
                                                                   .with(user("user@test.com").password("123"))
                                                                   .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link CommentsDTO} when ad comments are exist. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad comments are not exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link CommentsDTO}, когда комментарии к объявлению существуют. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда комментарии к объявлению не существуют. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void getAdComments() throws Exception {
        mockMvc.perform(get("/ads/1/comments")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.count").value(COMMENTS_DTO.getCount()))
               .andExpect(jsonPath("$.results[0].author").value(COMMENT_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[0].authorImage").value(COMMENT_1_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.results[0].authorFirstName").value(COMMENT_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.results[0].createdAt").value(COMMENT_1_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.results[0].pk").value(COMMENT_1_DTO.getPk()))
               .andExpect(jsonPath("$.results[0].text").value(COMMENT_1_DTO.getText()))
               .andExpect(jsonPath("$.results[1].author").value(COMMENT_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[1].authorImage").value(COMMENT_2_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.results[1].authorFirstName").value(COMMENT_2_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.results[1].createdAt").value(COMMENT_2_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.results[1].pk").value(COMMENT_2_DTO.getPk()))
               .andExpect(jsonPath("$.results[1].text").value(COMMENT_2_DTO.getText()))
               .andExpect(jsonPath("$.results[2].author").value(COMMENT_3_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[2].authorImage").value(COMMENT_3_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.results[2].authorFirstName").value(COMMENT_3_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.results[2].createdAt").value(COMMENT_3_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.results[2].pk").value(COMMENT_3_DTO.getPk()))
               .andExpect(jsonPath("$.results[2].text").value(COMMENT_3_DTO.getText()));
        mockMvc.perform(get("/ads/1/comments")
                                .with(user("admin@test.com").password("321"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.count").value(COMMENTS_DTO.getCount()))
               .andExpect(jsonPath("$.results[0].author").value(COMMENT_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[0].authorImage").value(COMMENT_1_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.results[0].authorFirstName").value(COMMENT_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.results[0].createdAt").value(COMMENT_1_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.results[0].pk").value(COMMENT_1_DTO.getPk()))
               .andExpect(jsonPath("$.results[0].text").value(COMMENT_1_DTO.getText()))
               .andExpect(jsonPath("$.results[1].author").value(COMMENT_2_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[1].authorImage").value(COMMENT_2_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.results[1].authorFirstName").value(COMMENT_2_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.results[1].createdAt").value(COMMENT_2_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.results[1].pk").value(COMMENT_2_DTO.getPk()))
               .andExpect(jsonPath("$.results[1].text").value(COMMENT_2_DTO.getText()))
               .andExpect(jsonPath("$.results[2].author").value(COMMENT_3_DTO.getAuthor()))
               .andExpect(jsonPath("$.results[2].authorImage").value(COMMENT_3_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.results[2].authorFirstName").value(COMMENT_3_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.results[2].createdAt").value(COMMENT_3_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.results[2].pk").value(COMMENT_3_DTO.getPk()))
               .andExpect(jsonPath("$.results[2].text").value(COMMENT_3_DTO.getText()));
        mockMvc.perform(get("/ads/1/comments")
                                .with(anonymous())
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(get("/ads/2/comments")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link CommentDTO} when ad comment is added. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link CommentDTO}, когда комментарий к объявлению добавлен. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда объявление не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void postAdComment() throws Exception {
        mockMvc.perform(post("/ads/1/comments")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.author").value(COMMENT_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.authorImage").value(COMMENT_1_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.authorFirstName").value(COMMENT_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.createdAt").value(COMMENT_1_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.pk").value(COMMENT_1_DTO.getPk()))
               .andExpect(jsonPath("$.text").value(COMMENT_1_DTO.getText()));
        mockMvc.perform(post("/ads/1/comments")
                                .with(user("admin@test.com").password("321"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_3_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.author").value(COMMENT_3_DTO.getAuthor()))
               .andExpect(jsonPath("$.authorImage").value(COMMENT_3_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.authorFirstName").value(COMMENT_3_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.createdAt").value(COMMENT_3_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.pk").value(COMMENT_3_DTO.getPk()))
               .andExpect(jsonPath("$.text").value(COMMENT_3_DTO.getText()));
        mockMvc.perform(post("/ads/3/comments")
                                .with(anonymous())
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(post("/ads/4/comments")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} when ad comment is deleted. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#FORBIDDEN} when user doesn't have such rights. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad comment isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK}, когда комментарий к объявлению удалён. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#FORBIDDEN}, когда пользователь не имеет таких прав. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда комментарий к объявлению не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void deleteAdComment() throws Exception {
        mockMvc.perform(delete("/ads/1/comments/1")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk());
        mockMvc.perform(delete("/ads/1/comments/1")
                                .with(user("admin@test.com").password("321"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk());
        mockMvc.perform(delete("/ads/1/comments/1")
                                .with(anonymous())
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(delete("/ads/1/comments/3")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isForbidden());
        mockMvc.perform(delete("/ads/2/comments/1")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
        mockMvc.perform(delete("/ads/1/comments/4")
                                .with(user("user@test.com").password("123"))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link CommentDTO} when ad comment is updated. <br>
     * Should return status code {@link HttpStatus#UNAUTHORIZED} when user isn't authorized. <br>
     * Should return status code {@link HttpStatus#FORBIDDEN} when user doesn't have such rights. <br>
     * Should return status code {@link HttpStatus#NOT_FOUND} when ad comment isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link CommentDTO}, когда комментарий к объявлению обновлён. <br>
     * Должен возвращать статус-код {@link HttpStatus#UNAUTHORIZED}, когда пользователь не авторизован. <br>
     * Должен возвращать статус-код {@link HttpStatus#FORBIDDEN}, когда пользователь не имеет таких прав. <br>
     * Должен возвращать статус-код {@link HttpStatus#NOT_FOUND}, когда комментарий к объявлению не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void updateAdComment() throws Exception {
        mockMvc.perform(patch("/ads/1/comments/1")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.author").value(COMMENT_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.authorImage").value(COMMENT_1_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.authorFirstName").value(COMMENT_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.createdAt").value(COMMENT_1_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.pk").value(COMMENT_1_DTO.getPk()))
               .andExpect(jsonPath("$.text").value(COMMENT_1_DTO.getText()));
        mockMvc.perform(patch("/ads/1/comments/1")
                                .with(user("admin@test.com").password("321"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.author").value(COMMENT_1_DTO.getAuthor()))
               .andExpect(jsonPath("$.authorImage").value(COMMENT_1_DTO.getAuthorImage()))
               .andExpect(jsonPath("$.authorFirstName").value(COMMENT_1_DTO.getAuthorFirstName()))
               .andExpect(jsonPath("$.createdAt").value(COMMENT_1_DTO.getCreatedAt()))
               .andExpect(jsonPath("$.pk").value(COMMENT_1_DTO.getPk()))
               .andExpect(jsonPath("$.text").value(COMMENT_1_DTO.getText()));
        mockMvc.perform(patch("/ads/1/comments/1")
                                .with(anonymous())
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isUnauthorized());
        mockMvc.perform(patch("/ads/1/comments/3")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_3_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isForbidden());
        mockMvc.perform(patch("/ads/2/comments/1")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
        mockMvc.perform(patch("/ads/1/comments/4")
                                .with(user("user@test.com").password("123"))
                                .contentType(MediaType.APPLICATION_JSON_VALUE)
                                .content(new ObjectMapper().writeValueAsString(CREATE_OR_UPDATE_COMMENT_1_DTO))
                                .accept(MediaType.APPLICATION_JSON_VALUE))
               .andExpect(status().isNotFound());
    }

    /**
     * Should return status code {@link HttpStatus#OK} and {@link ByteArrayOutputStream} when image is exist. <br>
     * Should return status code {@link HttpStatus#BAD_REQUEST} when image isn't exist. <br>
     * <br>
     * <hr>
     * <br>
     * Должен возвращать статус-код {@link HttpStatus#OK} и {@link ByteArrayOutputStream}, когда изображение существует. <br>
     * Должен возвращать статус-код {@link HttpStatus#BAD_REQUEST}, когда изображение не существует. <br>
     * <br>
     *
     * @throws Exception
     */
    @Test
    void downloadImage() throws Exception {
        byte[] result = mockMvc.perform(get("/" + USER.getImage())
                                                .with(user("user@test.com").password("123")))
                               .andExpect(status().isOk())
                               .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(userImageDir, USER.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        result = mockMvc.perform(get("/" + ADMIN.getImage())
                                         .with(user("user@test.com").password("123")))
                        .andExpect(status().isOk())
                        .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(userImageDir, ADMIN.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        result = mockMvc.perform(get("/" + USER.getImage())
                                         .with(user("admin@test.com").password("321")))
                        .andExpect(status().isOk())
                        .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(userImageDir, USER.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        result = mockMvc.perform(get("/" + ADMIN.getImage())
                                         .with(user("admin@test.com").password("321")))
                        .andExpect(status().isOk())
                        .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(userImageDir, ADMIN.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        result = mockMvc.perform(get("/" + AD_1.getImage())
                                         .with(user("user@test.com").password("123")))
                        .andExpect(status().isOk())
                        .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(adsImageDir, AD_1.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        result = mockMvc.perform(get("/" + AD_2.getImage())
                                         .with(user("admin@test.com").password("321")))
                        .andExpect(status().isOk())
                        .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(adsImageDir, AD_2.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        result = mockMvc.perform(get("/" + AD_3.getImage())
                                         .with(anonymous()))
                        .andExpect(status().isOk())
                        .andReturn().getResponse().getContentAsByteArray();
        try (InputStream inputStream1 = new ByteArrayInputStream(result);
             InputStream inputStream2 = new FileInputStream(Path.of(adsImageDir, AD_3.getImage()).toFile())) {
            assertTrue(IOUtils.contentEquals(inputStream1, inputStream2));
        }
        mockMvc.perform(get("/wrong_image_name.jpg")
                                .with(user("user@test.com").password("123")))
               .andExpect(status().isBadRequest());
        mockMvc.perform(get("/wrong_image_name.jpg")
                                .with(user("admin@test.com").password("321")))
               .andExpect(status().isBadRequest());
        mockMvc.perform(get("/wrong_image_name.jpg")
                                .with(anonymous()))
               .andExpect(status().isBadRequest());
    }
}
```

### 2.5.3 Написание своих исключений

> [[_оглавление_]](../README.md/#25-исключения)

Исключение представляет собой обычный класс, не имеющий собственных методов, наследующийся от _Exception_ или от
_RuntimeException_ и вызывающий соответствующий конструктор родителя.

Например:

```java
import java.io.IOException;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class FileIsDirectoryException extends IOException {
    public FileIsDirectoryException() {
        super();
    }

    public FileIsDirectoryException(String message) {
        super(message);
    }

    public FileIsDirectoryException(String message, Throwable t) {
        super(message, t);
    }

    public FileIsDirectoryException(Throwable t) {
        super(t);
    }
}
```

После создания свои исключения могут использоваться точно также как и библиотечные исключения Java с использованием
ключевого слова `throw`.