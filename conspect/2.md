# 2 Java Core

> [[_оглавление_]](../README.md/#2-java-core)

## 2.1 Память в Java

> [[_оглавление_]](../README.md/#21-память-в-java)

Все данные <u>_вне зависимости от используемого языка программирования_</u> хранятся в виде структур данных.  
[**Структура данных**](/conspect/definitions.md/#с) - это программная единица, позволяющая хранить и обрабатывать
множество однотипных и/или логически связанных данных в вычислительной технике.  
Структур данных существует огромное множество. Самыми популярными из них являются:

- связный список;
- ассоциативный массив;
- стек;
- очередь.

[**Связный список**](/conspect/definitions.md/#с) - это базовая динамическая структура данных в информатике, состоящая
из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или
предыдущий узел списка.  
В Java структура данных связный список реализован в классе `Linkedlist`.

[**Ассоциативный массив**](/conspect/definitions.md/#а) - это абстрактный тип данных (интерфейс к хранилищу данных),
позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления
пары по ключу.  
В Java структура данных ассоциативный массив реализован в классе `Map`.

[**Стек (Stack)**](/conspect/definitions.md/#с) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого *
*вершиной стека**.  
В стеке реализован принцип _LIFO_.  
[**LIFO (last-in, first-out)**](/conspect/definitions.md/#l) - это принцип, при котором первым удаляется элемент,
который был помещен туда последним («последним вошел — первым вышел»).

![1.jpeg](/pictures/1.jpeg)

В Java структура данных ассоциативный массив реализован в классе `java.util.Stack`.

[**Очередь (Queue)**](/conspect/definitions.md/#q) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов производится в конец, называемый **хвостом очереди**, а удаление
существующих производится с другого конца, называемого **головой очереди**.  
В очереди реализован принцип _FIFO_.  
[**FIFO (first-in, first-out)**](/conspect/definitions.md/#f) - это принцип, при котором первым удаляется элемент,
который был помещен туда первым («первым вошел — первым вышел»).

![2.png](/pictures/2.png)

В Java структура данных очередь представлена не классом, а интерфейсом - `Queue`.  
Но вместе с тем, очередь в Java - это интерфейс, у которого есть очень много реализаций. Самым распространённым из
используемых субинтерфейсов, реализующих интерфейс `Queue`, является интерфейс `Deque` (двусторонняя очередь).  
Двусторонняя очередь `Deque` расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и
конец очереди) и забирать элементы с обоих краев очереди.

![3.png](/pictures/3.png)

Структуры данных в Java, как и в других объектно-ориентированных языках, хранят примитивы и объекты.  
[Примитивы](/conspect/1.md/#112-типизация-переменных) содержат в себе одно значение и не более, за счёт этого они имеют
заранее известный фиксированный размер, интервал допустимых значений и работать с ними быстро и легко.  
[Объекты](/conspect/1.md/#191-объекты) могут хранить в себе как какие-то данные (в виде полей), так и методы по работе с
ними. Java не может заранее знать размер объекта, ведь объекты созданных типов могут создаваться и во время исполнения
программы. Потому была придумана система ссылок.

> Ссылка на объект всегда весит 64 бита (для 64-битных систем, которых сейчас абсолютное большинство).

Каждая ссылка ведёт на область в памяти, где лежит объект.

То есть, переменные примитивных типов хранят в себе само значение, а переменные ссылочных типов хранят в себе ссылку на
область памяти, в которой хранится значение объекта.

> Всё в Java передается по значению.  
> В том числе значения переменных в методы. При попадании в метод сущность копирует то, что хранится в ней, свое
> значение. А для объектов значение переменной - это ссылка на объект.

Все объекты имеют значение по умолчанию `null`, которое представляет собой пустоту.  
Примитивы не могут иметь значение `null`, только объекты.  
`null` не является реализацией объекта, потому любая попытка запросить у пустой переменной (`null`) какие-то данные или
вызвать ее методы приведет к выбросу ошибки (_NullPointerException_ или _NPE_).

### 2.1.1 Стек (Stack)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Стек (Stack)**](/conspect/definitions.md/#s) - это массив, который состоит из ячеек, имеет определенный размер (
количество ячеек) и предоставляет быстрый доступ к своим элементам, так как структурирован и обращение к актуальной
ячейке происходит за константное время.
Этот массив хранит сущности, которые называются _Frame_. Каждый раз, когда вызывается новый метод, в стеке создается
новый фрейм. Как только метод заканчивает выполнение, фрейм удаляется из стека.  
Следовательно, первым фреймом в стеке создается фрейм метода `main`, а затем, когда метод `main` вызывает какой-то
метод, в стеке создается фрейм этого метода и существует до тех пор, пока Java не закончит выполнять код внутри этого
метода.

Примитивы, так как они хранит в себе значение, помещаются во фрейм полностью.  
В случае с объектами во фрейм помещаются только ссылки на объекты, а сами объекты хранятся в куче (_Heap_).

В тот момент, когда память стека заканчивается (количество элементов вышло за границы допустимых для Java-приложения),
приложение будет завершено ошибкой _StackOverflowError_.

> Так как Java позволяет нам писать многопоточные приложения, которые могут вызывать методы параллельно друг другу,
> каждый поток имеет свой собственный стек.  
> Так main-поток имеет в качестве первого фрейма метод `main()`.  
> Другие потоки в качестве первого фрейма имеют тот метод, который был первый выполнен. Обычно это метод `run()`.

### 2.1.2 Куча (Heap)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Куча (Heap)**](/conspect/definitions.md/#h) - это место в памяти, где хранятся объекты.  
Когда создаётся объект через ключевое слово `new`, в куче выделяется место для хранения этого самого объекта.

Куча, в отличие от стека, сама очищать себя не может, потому этим занимается специальная сопрограмма, которая называется
«сборщик мусора» (_garbage collector_), а сам процесс, как ни странно, называется «сборка мусора» (_garbage
collection_).  
Этот процесс анализирует объекты на актуальность и, если приходит к выводу, что объект больше не нужен, удаляет его.  
При переполнении кучи приложение выбрасывает ошибку _OutOfMemoryError_ и завершает работу.

Куча делится на несколько частей. Они созданы для оптимизации сборки мусора:

- два поколения:
    - старое (_Old Generation_);
    - новое (_New Generation_);
- метапространство (_Metaspace_).

![4.png](/pictures/4.png)

Все объекты создаются в новом поколении, и в тот момент, когда эти объекты «переживают» несколько сборок мусора, они
переводятся в старое поколение.  
Метапространство (ранее до 8-й версии Java называлось _Permanent Generation_) хранит в себе метаинформацию о классах, на
основе которых создаются объекты в куче, и статические данные приложения.

### 2.1.3 Сборка мусора (Garbage Collection)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Сборщик мусора (Garbage Collection)**](/conspect/definitions.md/#g) - это инструмент, который находит все объекты в
коде, недоступные для программиста, и удаляет их.  
В программировании часто используются два подхода для реализации сборки мусора:

- подсчёт ссылок;
- трассировка.

Подсчет ссылок подразумевает, что на каждом объекте есть условный счетчик ссылок. Когда на объект создается новая
ссылка, счетчик увеличивается. Когда ссылка отрабатывает свою задачу и перестает быть актуальной, счетчик уменьшается.
При достижении нуля объект помечается мусором и удаляется.

Трассировка встречается чаще, и ее идея построена на том, что в определенный момент мы начинаем идти по коду и искать,
какие объекты еще являются достижимыми в коде дальше. То есть в какой-то момент времени в дальнейшем приложение
обратится к нашему объекту. Эти объекты остаются «жить».

Сборка мусора представляет собой процесс, когда Java анализирует кучу на предмет «мертвых» объектов и удаляет их.  
Именно трассировка и используется в Java. Хотя этот подход и является более сложным и ресурсоёмким, он обеспечивает
большую надежность.  
Процесс трассировки делится на два этапа:

- Mark (маркировка) - сборщик мусора отмечает недостижимые объекты в качестве мусора;
- Sweep (уборка) - объекты, отмеченные мусором на прошлой стадии, удаляются, освобождая место в куче.

В Java существует несколько реализаций сборщиков мусора.  
Какой из них запускать, выбирает разработчик с помощью специального флага при запуске приложения.

#### 2.1.3.1 Serial GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данный сборщик мусора является классической и самой простой реализацией. _Serial GC_ использует один поток и отлично подходит для работы в приложениях на клиентской стороне (пользовательские ПК), где нет жестких требований к минимизации остановок приложения и ресурсы ограничены.

#### 2.1.3.2 Parallel GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Отличается от _Serial GC_ использованием нескольких потоков, но также останавливает приложение в ходе сборки мусора.  
Является выбором по умолчанию во многих JVM.

#### 2.1.3.3 CMS (Concurrent Mark Sweep) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация делит ресурсы с приложением, замедляя его работу, но позволяет минимизировать остановки приложения во время сборки мусора.  
В 9-й версии Java был помечен устаревшим и в 14-й полностью удален.

#### 2.1.3.4 G1 (Garbage First) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация пришла на смену _CMS_. Отличия в том, что данный сборщик мусора делит кучу на равные части и маркирует их на предмет общей «жизнеспособности». На фазе сборки мусора в первую очередь очищаются наиболее заполненные области, освобождая максимальный объем памяти.

### 2.1.4 Жизненный цикл приложения

> [[_оглавление_]](../README.md/#21-память-в-java)

Первым делом происходит сборка проекта.  
В этот момент **IDEA** подтягивает все указанные вами зависимости, затем производит процесс компиляции вашего кода.  
На этом моменте компилятор Java производит анализ кода, оптимизирует его и транслирует из того кода на английском языке, что вы пишете в файлах Java, в байт-код, который уже достаточно тяжело читать человеку, и сохраняет его в файлы формата _class_.  
Если компилятор находит ошибку в коде (например, вы где-то пропустили), компиляция останавливается, и вы видите много красного текста в вашей консоли.
Обычно там указывается текст ошибки и строка файла, где эта ошибка была найдена.
**IDEA** подсвечивает эту строку синим, делая ее ссылкой, по нажатию на которую можно перейти в то место, где была ошибка.
В тот момент, когда все необходимые файлы формата _class_ сформированы, а формируются они в таком соотношении: 1 Java-файл преобразуется в 1 class-файл — **JVM** получает возможность запустить ваш код.  

[**JVM (Java Virtual Machine)**](/conspect/definitions.md/#j) в упрощенном представлении является программой, которая читает этот самый байт-код и транслирует его в машинные инструкции, которые уже понимает процессор.  
Именно за счет **JVM** у приложений на Java появилась одна из киллер фич, а именно: мультиплатформенность. Компилятор может быть один, его задача — сформировать на основе Java-кода байт-код и записать его в class-файлы.  
Ответственность за запуск приложения ложится на JVM, которые уникальны для каждого типа систем (_Windows_, _Linux_, _Android_, _iOS_, умный дом), ведь их архитектура отличается.  
Если вы хотите, чтобы ваш код выполнялся на абсолютно новой системе, вам необходимо написать реализацию **JVM** под эту новую систему (будь это умная лампочка, кофеварка или холодильник), и Java-приложения будут запускаться на этой системе.  

Если суммировать, то **JVM** отвечает за запуск вашего приложения. Она управляет памятью, управляет (просит операционную систему) созданием потоков для многопоточных приложений, осуществляет сборку мусора и так далее.

Так как передавать сотни и сотни class-файлов было бы накладным и неудобным, их принято объединять в архивы в формате _jar_, где в конфигурации прописан класс с методом `main`, который запускает приложение.  
Этот архив тоже запускается с помощью **JVM**.

## 2.2 Объектно-ориентированное программирование (ООП)

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

### 2.2.1 Инкапсуляция

> [[_оглавление_]](../README.md/#22-объектно-ориентированное-программирование-ооп)

Инкапсуляция является одним из принципов ООП.  
**Инкапсуляция** — концепция, согласно которой мы не даем доступ к свойствам объекта, а получаем их значения через
методы.  
Для реализации принципа инкапсуляции существуют [модификаторы доступа](/conspect/1.md/#181-модификаторы-доступа).  
Пользователь не должен иметь доступ к методам, которые ему не положено вызывать, или к полям, которые ему запрещено
читать или даже изменять.