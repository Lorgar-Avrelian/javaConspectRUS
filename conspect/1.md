# 1 Синтаксис языка

> [[_оглавление_]](../README.md/#оглавление)

## 1.1 Переменные

> [[_оглавление_]](../README.md/#11)

[**Переменная** ](/conspect/definitions.md/#п)– это ячейка в памяти компьютера, которой можно присвоить имя и в которой
можно хранить данные.  
[**Объявление переменной**](/conspect/definitions.md/#о) – это создание переменной (выделение ячейки памяти, присвоение
ей имени).  
[**Инициализация переменной**](/conspect/definitions.md/#и) – это присваивание какого-то значения переменной.
Выделение памяти для хранения переменных происходит в момент их инициализации.  
[**Синтаксис языка программирования**](/conspect/definitions.md/#с) – это набор правил и конструкций, из которых
строится язык.

### 1.1.1 Виды переменных:

> [[_оглавление_]](../README.md/#11)

* примитивные;
* не примитивные (ссылочные).

[**Примитивный тип**](/conspect/definitions.md/#п) - это простое значение: число или символ.  
Примитивы не имеют своего поведения, возможностей и лишь используются как тип-значение.  
[**Ссылочный тип**](/conspect/definitions.md/#с) - это ссылка на адрес ячейки памяти, в которой хранится значение
объекта.  
Ссылочные типы не просто хранят число или символ, они имеют какие-то свойства (как `length` у массивов) и методы (
как `toUpperCase()` или `replace()` у строк).  
Параметры в Java передаются по значению:

- если это тип-значение (примитив), то копируется само значение;
- если же это ссылочный тип (объект), то копируется ссылка.

Если копируется ссылка, ссылающаяся на определенный объект, то в системе будут две ссылки, которые ссылаются на один и
тот же объект.  
Если внутри [метода](#18-методы) модифицируется примитив, то значение вне метода не поменяется, но если в методе
модифицируется объект, значение объекта вне метода поменяется тоже.  
Все объекты (ссылочные типы) создаются при помощи ключевого слова `new`.

> [**new**](/conspect/definitions.md/#n) – это ключевое слово, которое применяется для создания объектов.

### 1.1.2 Типизация переменных

> [[_оглавление_]](../README.md/#11)

|             **Тип данных**              |         **Обозначение**         |                                                             **Диапазон значений**                                                             |             **Объём памяти**              |
|:---------------------------------------:|:-------------------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------:|:-----------------------------------------:|
|             _Целочисленные_             | byte<br/>short<br/>int<br/>long | от -128 до 127<br/>от -32 768 до 32 768<br/>от -2 147 483 648 до 2 147 483 648<br/>от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 | 1 байт<br/>2 байта<br/>4 байта<br/>8 байт |
| _Вещественные<br/>(с плавающей точкой)_ |        float<br/>double         |                                              от -3.4E+38 до 3.4E+38<br/>от -1.7E+308 до 1.7E+308                                              |            4 байта<br/>8 байт             |
|              _Символьные_               |              char               |                                                                от 0 до 65 536                                                                 |                  2 байта                  |
|              _Логические_               |             boolean             |                                                                  true/false                                                                   |                   1 бит                   |

[**Целочисленные типы**](/conspect/definitions.md/#ц) – это типы, которые содержат в себе целое число (без дробной
части).  
[**Вещественные типы (типы с плавающей точкой)**](/conspect/definitions.md/#в) – это типы, которые содержат в себе не
только целую, но еще и дробную часть.  
[**Логический тип переменных**](/conspect/definitions.md/#л) – это тип, в котором хранится информация в
формате `true`/`false` (т. е. истина/ложь).  
[**Символьные переменные**](/conspect/definitions.md/#с) – это тип, который позволяет хранить значения символов, а также
буквы или цифры. Значения символьных переменных пишутся в одинарных кавычках (`' '`).

> [**Scope (Область видимости)**](/conspect/definitions.md/#s) – это участок кода, сгруппированный в фигурные
> скобки (`{ }`). Все переменные, объявленные внутри блока, не видны за его пределами.

### 1.1.3 Значения переменных по умолчанию

> [[_оглавление_]](../README.md/#11)

|         **Тип переменной**         | **Значение по умолчанию** |
|:----------------------------------:|:-------------------------:|
|               `byte`               |             0             |
|              `short`               |             0             |
|               `int`                |             0             |
|               `long`               |            0L             |
|              `float`               |           0.0f            |
|              `double`              |           0.0d            |
|               `char`               |             0             |
| `String` (или любой другой объект) |           null            |
|             `boolean`              |           false           |

В случае, если переменная определённого типа объявлена, но не проинициализирована, то при обращении к ней будет получено
значение «по-умолчанию» из таблицы выше.

## 1.2 Условные операторы

> [[_оглавление_]](../README.md/#12)

| Оператор |      Функция оператора      |   Пример   |
|:--------:|:---------------------------:|:----------:|
|    <     |      Операция "Меньше"      |  `a < b`   |
|    <=    | Операция "Меньше или равно" |  `a <= b`  |
|    >     |      Операция "Больше"      |  `a > b`   |
|    >=    | Операция "Больше или равно" |  `a >= b`  |
|    ==    |      Операция "Равно"       |  `a == b`  |
|    !=    |     Операция "Не равно"     |  `a != b`  |
|    &&    |        Операция "И"         |  `a && b`  |
|   \|\|   |       Операция "Или"        | `a \|\| b` |

### 1.2.1 Виды условных операторов в Java:

#### 1.2.1.1 Оператор if

> [[_оглавление_]](../README.md/#12)

**if** – это условный оператор или оператор ветвления. Он позволяет запускать код только в том случае, когда условия,
помещенные в скобки, являются истиной, т. е. соблюдаются.

#### 1.2.1.2 Оператор if-else

> [[_оглавление_]](../README.md/#12)

**if-else** – это условный оператор или оператор ветвления. Он позволяет запускать код только в том случае, когда
условия, помещенные в скобки, являются истиной, т. е. соблюдаются, а если они не соблюдаются, то выполняется тот блок
кода, который помещён в блок `else`.  
Конструкция `else-if` используется при вложенности.  
[**Вложенный условный оператор**](/conspect/definitions.md/#в) – это условный оператор, который находится внутри другого
условного оператора.

#### 1.2.1.3 Оператор switch

> [[_оглавление_]](../README.md/#12)

**switch** – это условный оператор, который применяется при выборе между несколькими решениями, когда вариантов много, и
прописывать для каждого `if-else` будет долго.  
В операторе `switch` необходимо не забывать использовать ключевое слово `break`.

> [**break**](/conspect/definitions.md/#b) – это ключевое слово, которое применяется для прерывания выполнения блока
> кода.

Конструкция оператора `switch` выглядит следующим образом:

```java
public static void switchMethod(int variable) {
    switch (variable) {
        case 1:
            // код выполнится, если variable == 1
            action1();
            break;
        case 2:
            // код выполнится, если variable == 2
            action2();
            break;
        case 3:
            // код выполнится, если variable == 3
            action3();
            break;
        default:
            // код выполнится, если ни одно значение в case не было равно variable
            actionByDefault();
    }
}
```

Пример использования:

```java
private static void dayOfWeek(int day) {
    switch (day) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            System.out.println("Работаем!");
            break;
        case 6:
        case 7:
            System.out.println("Отдыхаем!");
            break;
        default:
            System.out.println("Такого дня не существует!");
    }
}
```

По сравнению с конструкциями `if-else`, которые могут быть громоздкими, оператор `switch` представляется удобным
решением. Однако он позволяет сравнивать переключатель только с конкретными значениями. Задать условие с помощью
операторов сравнения для `switch` нельзя.

#### 1.2.1.4 Тернарный оператор

> [[_оглавление_]](../README.md/#12)

[**Тернарный оператор**](/conspect/definitions.md/#т) – это условный оператор, который содержит три выражения.  
Тернарный оператор используется вместо оператора `if-else`. В коде это выглядит так:

```java
private static void ternarOperator(int a, int b) {
    int result = a > b ? 1 : 2;
    switchMethod(result);
}
```

Если первое выражение верно (`true`), то возвращается значение 1, иначе (`false`) - 2.

## 1.3 Циклы

> [[_оглавление_]](../README.md/#13)

[**Цикл**](/conspect/definitions.md/#ц) – это конструкция кода, которая повторяет одно и то же действие несколько (
столько, сколько нам потребуется) раз.  
[**Итерация**](/conspect/definitions.md/#и) – это один повтор какого-то действия (одно прохождение цикла).

### 1.3.1 Цикл for

> [[_оглавление_]](../README.md/#13)

Конструкция цикла `for` выглядит следующим образом:

```java
for([блок_объявления_переменной];[блок_условия];[действие_при_каждой_итерации])
        {
        [тело_цикла];
        }
```

Например:

```java
private static void forExample() {
    for (int i = 0; i < 10; i++) {
        action1();
    }
}
```

[**Инкремент**](/conspect/definitions.md/#и) – это операция, которая увеличивает значение переменной.  
Блоки цикла `for` не являются строго стандартизированными и могут отсутствовать.  
В первом блоке возможно объявить большое количество переменных внутри себя, но так делать не рекомендуется.  
Второй блок тоже может отсутствовать. В таком случае мы получим вечный цикл, который каждый шаг будет вызывать третий
блок.  
Третий блок, как и два других, тоже не является обязательным и может быть пропущен. В таком случае есть вероятность
запустить вечный цикл, если инициализировать переменную в первом блоке, во втором проверить условие ее размера, а в
третьем не изменять ее.  
Цикл `for` позволяет создать себя с полностью пустыми блоками. В этой ситуации будет создан бесконечный
цикл: `for (;;) {}`

### 1.3.2 Цикл while

> [[_оглавление_]](../README.md/#13)

Конструкция цикла `while` выглядит следующим образом:

```java
while([условие])
        {
        [тело_цикла];
        }
```

Например:

```java
private static void whileExample() {
    int i = 10;
    while (i > 0) {
        action1();
        i--;
    }
}
```

Цикл `while` может быть запущен в бесконечном режиме. Но при этом зачастую используют оператор `break`, который
прерывает цикл вне зависимости от условия.  
Также с циклом `while` часто применяют ключевое слово `continue`.

> [**continue**](/conspect/definitions.md/#c) – это ключевое слово, которое применяется для пропуска выполнения блока
> кода в цикле.

### 1.3.3 Цикл do-while

> [[_оглавление_]](../README.md/#13)

Конструкция цикла `do-while` выглядит следующим образом:

```java 
do{([действие]);}
        while([условие]);
```

Например:

```java
private static void doWhileExample() {
    int i = 0;
    do {
        action1();
        i++;
    } while (i < 10);
}
```

По принципу работы цикл `do-while` похож на `while`. Отличие в том, что `while` может не выполниться ни разу (если
условие изначально равняется `false`), а цикл `do-while` выполнится минимум 1 раз.
Цикл `while` сначала проверяет условие в скобках и затем выполняет блок, а цикл `do-while` сначала запускает блок, а
потом проверяет условие.

### 1.3.4 Цикл for each

> [[_оглавление_]](../README.md/#13)

Цикл `for each` позволяет проходить по всем элементам массива без необходимости работать с индексами ячеек и применяется
при работе с массивами (класс `Arrays`), коллекциями (класс `Collection`) и мапами (класс `Map`).  
Конструкция цикла `for each` выглядит следующим образом:

```java
for(тип_переменной имя :массив)
        {
        [действия_с_переменной,_которая_создана_в_первом_блоке];
        }
```

Например:

```java
private static void forEachExample() {
    List<Integer> testList = new ArrayList<>(List.of(1, 2, 3));
    for (Integer i : testList) {
        System.out.println("i = " + i);
    }
}
```

## 1.4 Массивы

> [[_оглавление_]](../README.md/#14)

[**Массив**](/conspect/definitions.md/#м) – это структура данных, которая позволяет хранить несколько значений одного
типа; это непрерывная область памяти, в которой хранятся однотипные данные.  
Массив является объектом и хранит в себе данные того типа, которым он инициализирован.  
Размер массива изменять нельзя.  
[**Индекс**](/conspect/definitions.md/#и) – это порядковый номер элемента в массиве.  
Первый элемент массива находится в ячейке под номером 0.  
[**Ячейка (элемент) массива**](/conspect/definitions.md/#я) – это место в памяти, где хранится значение.  
[**Элемент массива**](/conspect/definitions.md/#э) – это также само значение, которое хранится в ячейке массива.  
Массив при создании формирует не просто ячейки типов, но и заполняет
их [стандартными значениями](#113-значения-переменных-по-умолчанию).

### 1.4.1 Виды массивов

- одномерные;
- многомерные.

> [[_оглавление_]](../README.md/#14)

### 1.4.2 Способы создания массивов

#### 1.4.2.1 Объявление массива

> [[_оглавление_]](../README.md/#14)

Признаком того, что данная переменная является массивом, являются квадратные скобки (`[ ]`), которые в момент
объявления:

* следуют, как правило, после типа массива: `dataType[] arrayName;`
* или (что не рекомендуется делать, но также работает) могут размещаться после имени переменной: `dataType arrayName[];`

#### 1.4.2.2 Инициализация массива

> [[_оглавление_]](../README.md/#14)

Массив может быть проинициализирован как в момент, так и после его объявления.  
Инициализация массива может производиться:

- путём непосредственного присвоения значений;
- с использованием ключевого слова `new` и указания размера массива.

Например:

```java
private static void arraysExample() {
    int[] array1 = {1, 2, 3};
    int[][] array2 = {
            {1, 2, 3},
            {4, 5, 6, 7},
            {8, 9, 10}
    };
    int[] array3 = new int[]{1, 2, 3};
    int[][] array4 = new int[][]{
            array3,
            {4, 5, 6, 7},
            {8, 9, 10}
    };
    int array5[] = array1;
    int array6[][] = array2;
    System.out.println(Arrays.toString(array5));
    System.out.println(Arrays.toString(array6[0]));
    System.out.println(Arrays.toString(array6[1]));
    System.out.println(Arrays.toString(array6[2]));
    System.out.println(Arrays.equals(array4, array2));
    System.out.println(Arrays.equals(array3, array1));
}
```

### 1.4.3 Получение значения элемента массива

> [[_оглавление_]](../README.md/#14)

Получение значения элемента массива осуществляется по его индексу.

```java
int value1 = array1[1];
int value2 = array2[2][0];
```

### 1.4.4 Свойство массива length

> [[_оглавление_]](../README.md/#14)

Свойство массива `length` возвращает длину массива, то есть количество элементов.

```java
boolean[] array;
int i = array.length;
```

Длина массива всегда имеет целое значение, поэтому свойство `length` всегда возвращает значение типа `int`.

### 1.4.5 Класс Arrays

> [[_оглавление_]](../README.md/#14)

В Java для работы с массивами существует utility-класс `Arrays`, который содержит соответствующие методы.

> Методы класса `Arrays` рассчитаны для работы с одномерными массивами. Поэтому для использования этих методов в
> многомерных массивах необходимо разбивать последний на одномерные составляющие и использовать их уже по отношению к
> этим составляющим.

#### 1.4.5.1 toString()

> [[_оглавление_]](../README.md/#14)

Наиболее часто используемый метод класса `Arrays` метод `toString()`, используемый для распечатывания элементов массива,
когда формат вывода элементов не принципиален, и в который необходимо передавать распечатываемый массив в виде
аргумента.

```java
private static void arraysExample() {
    int[] array1 = {1, 2, 3};
    int[][] array2 = {
            {1, 2, 3},
            {4, 5, 6, 7},
            {8, 9, 10}
    };
    System.out.println(Arrays.toString(array1));
    System.out.println(Arrays.toString(array2[0]));
    System.out.println(Arrays.toString(array2[1]));
    System.out.println(Arrays.toString(array2[2]));
}
```

#### 1.4.5.2 fill()

> [[_оглавление_]](../README.md/#14)

Метод `fill()` класса `Arrays` заполняет массив одинаковыми значениями.  
Синтаксис метода выглядит следующим образом:

```java 
Arrays.fill([имя_массива], [значение]);
```

Первым параметром передаётся имя массива, а вторым – значение, которым его надо заполнить.

#### 1.4.5.3 equals()

> [[_оглавление_]](../README.md/#14)

Метод `equals()` класса `Arrays` позволяет сравнивать два массива с учётом значений их элементов.  
Синтаксис метода выглядит следующим образом:

```java
Arrays.equals([имя_массива_1], [имя_массива_2]);
```

Результат сравнения будет значением типа `boolean` и может быть присвоен переменной типа `boolean`.

#### 1.4.5.4 copyOf()

> [[_оглавление_]](../README.md/#14)

Метод `copyOf()` класса `Arrays` помогает создать копию уже существующего массива, при этом сначала указывается тип
нового массива и его имя, затем в скобках метода имя имеющегося массива и необходимая длина нового массива.  
Синтаксис метода выглядит следующим образом:

```java
тип[] имя_2 = Arrays.copyOf(имя_1,[длина_массива_2]);
```  

Если длина нового массива меньше длины существующего, то лишние значения игнорируются.  
Если длина нового массива больше длины старого, ячейки заполняются значениями по умолчанию.

#### 1.4.5.5 sort()

> [[_оглавление_]](../README.md/#14)

Метод `sort()` класса `Array`s сортирует массив по возрастанию.  
Синтаксис метода выглядит следующим образом:

```java 
Arrays.sort([имя_массива]);
```

## 1.5 Строки (Класс String)

> [[_оглавление_]](../README.md/#15)

[**Строка** (тип данных **String**)](/conspect/definitions.md/#с) – это последовательность символов типа `char`.  
Значения строк пишутся в двойных кавычках (`" "`).  
Строки, как и массивы, являются объектами. Если им не присвоить значение (не инициализировать), они будут содержать в
себе `null`.  
Строка имеет внутренние свойства. Главное из них – массив типа `byte`, где и хранятся все символы конкретной строки.  
Строка – неизменяемый объект, после создания изменить её невозможно. Все создаваемые в коде строки попадают в пул
строк.  
Неизменяемость строк обусловлена способом их хранения в памяти, а также соображениями безопасности.

### 1.5.1 Пул строк (String pool)

> [[_оглавление_]](../README.md/#15)

[**Пул строк**](/conspect/definitions.md/#п) – это набор строк, который хранится в памяти Java heap; это один из
внутренних механизмов Java, благодаря которому в памяти сохраняется только один экземпляр строки идентичного
содержания.  
Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если
находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.  
Когда же строка создаётся с помощью ключевого слова `new`, мы принуждаем класс `String` создать новую строку в пуле.

### 1.5.2 Конкатенация (сложение) строк

> [[_оглавление_]](../README.md/#15)

[**Конкатенация**](/conspect/definitions.md/#к) – это операция склеивания объектов линейной структуры, обычно строк.

### 1.5.3 Методы для работы со строками

> [[_оглавление_]](../README.md/#15)

#### 1.5.3.1 equals()

> [[_оглавление_]](../README.md/#15)

Для сравнения строк используют метод `equals()`. Этот метод в качестве параметра принимает другую строку и возвращает
`true`/`false`.  
Синтаксис метода выглядит следующим образом:

```java 
s2.equals(s1);
```

#### 1.5.3.2 equalsIgnoreCase()

> [[_оглавление_]](../README.md/#15)

Для сравнения строк без учёта регистра используют метод `equalsIgnoreCase()`.  
Синтаксис метода выглядит следующим образом:

```java 
s2.equalsIgnoreCase(s1);
```

#### 1.5.3.3 length()

> [[_оглавление_]](../README.md/#15)

Для определения длины строки используют метод `length()`, аналогичный по своему назначению со свойством `length`
массивов. Не смотря на то, что строки являются массивами символов, строки свойства `length` не имеют.  
Синтаксис метода выглядит следующим образом:

```java 
int stringLength = s.length();
```

#### 1.5.3.4 isEmpty()

> [[_оглавление_]](../README.md/#15)

Для определения является ли строка пустой, то есть не содержащей ни одного символа, используют метод `isEmpty()`.  
Синтаксис метода выглядит следующим образом:

```java 
boolean sIsEmpty = s.isEmpty();
```

#### 1.5.3.5 isBlank()

> [[_оглавление_]](../README.md/#15)

Для определения является ли строка пустой, то есть не содержащей ни одного символа, или содержащей только пробелы
используют метод `isBlank()`.  
Синтаксис метода выглядит следующим образом:

```java 
boolean sIsBlank = s.isBlank();
``` 

Если в строке будет только пробел (" "), то метод `isEmpty()` вернет `false`, метод `isBlank()` – `true`.

#### 1.5.3.6 contains()

> [[_оглавление_]](../README.md/#15)

Метод `contains()` проверяет наличие в строке последовательности символов.  
Синтаксис метода выглядит следующим образом:

```java
boolean sContains = s.contains("последовательность_символов");
```

#### 1.5.3.7 endsWith()

> [[_оглавление_]](../README.md/#15)

Метод `endsWith()` проверяет наличие в окончании строки последовательности символов.  
Синтаксис метода выглядит следующим образом:

```java
boolean sEndsWith = s.endsWith("последовательность_символов");
```

#### 1.5.3.8 startsWith()

> [[_оглавление_]](../README.md/#15)

Метод `startsWith()` проверяет наличие в начале строки последовательности символов.  
Синтаксис метода выглядит следующим образом:

```java 
boolean sStartsWith = s.startsWith("последовательность_символов");
```

#### 1.5.3.9 charAt()

> [[_оглавление_]](../README.md/#15)

Метод `charAt()` возвращает символ строки с указанным индексом (позицией).  
Синтаксис метода выглядит следующим образом:

```java 
char c = s.charAt(2);
```

#### 1.5.3.10 substring()

> [[_оглавление_]](../README.md/#15)

Метод `substring()` извлекает символы, начиная с первого параметра в ячейке включительно, заканчивая вторым параметром
не включительно.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.substring(2, 4);
```

#### 1.5.3.11 toUpperCase()

> [[_оглавление_]](../README.md/#15)

Метод `toUpperCase()` возвращает значение строки, преобразованное в верхний регистр.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.toUpperCase();
```

#### 1.5.3.12 toLowerCase()

> [[_оглавление_]](../README.md/#15)

Метод `toLowerCase()` возвращает значение строки, преобразованное в нижний регистр.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.toLowerCase();
```

#### 1.5.3.13 trim()

> [[_оглавление_]](../README.md/#15)

Метод `trim()` удаляет все символы пробелов (" ") с начала и конца строки.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.trim();
```

#### 1.5.3.14 split()

> [[_оглавление_]](../README.md/#15)

Метод `split()` создает из строки массив, разбив ее на части. Разделитель, по которому будет произведена разбивка,
указывается в скобках.  
Синтаксис метода выглядит следующим образом:

```java 
String[] strings = s1.split(" ");
```

#### 1.5.3.15 toCharArray()

> [[_оглавление_]](../README.md/#15)

Метод `toCharArray()` преобразует строку в массив символов.  
Синтаксис метода выглядит следующим образом:

```java 
char[] c = s.toCharArray();
```

#### 1.5.3.16 replace()

> [[_оглавление_]](../README.md/#15)

Метод `replace()` возвращает новую строку с символами, замененными на указанные.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.replace(" ", "");
```

#### 1.5.3.17 repeat()

> [[_оглавление_]](../README.md/#15)

Метод `repeat()` возвращает новую строку, которая содержит указанное количество соединенных вместе копий строки, на
которой был вызван метод.  
Синтаксис метода выглядит следующим образом:

```java
String s1 = "#";
String s2 = s1.repeat(10);
```

Метод `repeat()` не изменяет строку, на которую был вызван, а возвращает новую: `s2` получит строку `s1`, которая будет
повторена 10 раз (значение из скобок).

### 1.5.4 Формирование строк из массивов

> [[_оглавление_]](../README.md/#15)

#### 1.5.4.1 Символьный массив

> [[_оглавление_]](../README.md/#15)

Бывают ситуации, когда у нас есть символьный массив, а мы хотим превратить его в строку.  
В такой ситуации нам поможет другой способ создания строки:

```java
char[] symbols = {'a', 'b', 'c'};
String string = new String(symbols);
```

Этот способ позволит нам получить строку на основе тех символов, что лежат в массиве.

#### 1.5.4.2 Массив байтов

> [[_оглавление_]](../README.md/#15)

Из массива байтов тоже можно собрать строку.  
Веб-приложения, помимо текста, могут передавать данные еще и в байтах.
Это быстрее, безопаснее и зачастую выигрывает в производительности.  
Предположим, что мы получили от соседнего приложения текстовые данные в байтовом формате и собрали их в массив.

```java
private static void textFromBytes() {
    byte[] textInBytes = {33, 33, 33};
    String stringFromBytes = new String(textInBytes);
    System.out.println(stringFromBytes);
}
```

В консоль выведется строка `!!!`, так как значение 33 соответствует символу восклицательного знака в таблице символов
ASCII.

## 1.6 Изменяемые строки (StringBuilder)

> [[_оглавление_]](../README.md/#16)

В Java есть возможности модернизировать строки без создания новых.  
[**StringBuilder**](/conspect/definitions.md/#s) – это сущность, которую можно создать на основе существующей строки или
абсолютно новой (пустой).  
Инициализация `StringBuilder` производится следующим образом:

```java
StringBuilder sb1 = new StringBuilder();
// создаётся сущность StringBuilder на основе пустой строки
StringBuilder sb2 = new StringBuilder("123");
// создаётся сущность StringBuilder на основе строки "123"
```

`StringBuilder` тоже состоит из массива символов, потому имеет много общего со строкой, в том числе и методы, при этом
он изменяет сам себя, а не создает новый измененный объект и возвращает его. Именно поэтому он называется изменяемым в
отличие от `String`.

### 1.6.1 append()

> [[_оглавление_]](../README.md/#16)

Добавить к текущей строке, хранящейся в `StringBuilder`, другие строки или символы можно через метод `append()`.  
Синтаксис метода выглядит следующим образом:

```java
sb.append("456");
```

### 1.6.2 toString()

> [[_оглавление_]](../README.md/#16)

По завершению работы со `StringBuilder` его результат можно присвоить строке или, например, распечатать. Для этого
необходимо вызвать метод `toString()`.  
Синтаксис метода выглядит следующим образом:

```java
String str = sb.toString();
```

Но при печати через `System.out.println()` вызывать метод `toString()` не требуется, так как `println()` делает это
самостоятельно.

## 1.7 Класс Scanner

> [[_оглавление_]](../README.md/#17)

[**Scanner**](/conspect/definitions.md/#s) – это класс в Java, который позволяет считывать данные из разных источников (
из строки, консоли или файла).  
Инициализация Scanner производится следующим образом:

```java
import java.util.Scanner;

Scanner scanner = new Scanner(System.in);
```

### 1.7.1 nextLine()

> [[_оглавление_]](../README.md/#17)

Метод `nextLine()` класса `Scanner` обращается к источнику данных, находит там следующую строку, которую он еще не
считывал и возвращает её.  
Синтаксис метода выглядит следующим образом:

```java
String s = scanner.nextLine();
```

### 1.7.2 nextInt()

> [[_оглавление_]](../README.md/#17)

Метод `nextInt()` класса `Scanner` считывает и возвращает введенное целое число.  
Синтаксис метода выглядит следующим образом:

```java
int i = scanner.nextInt();
```

### 1.7.3 hasNext()

> [[_оглавление_]](../README.md/#17)

Метод `hasNext()` класса `Scanner` проверяет, имеется ли ещё одна порция введенных данных, или нет (возвращает,
соответственно, `true` или `false`).  
Синтаксис метода выглядит следующим образом:

```java
boolean b = scanner.hasNext();
```

### 1.7.4 hasNextInt()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextInt()` класса `Scanner` проверяет, является ли следующая порция введенных данных числом, или нет (
возвращает, соответственно, `true` или `false`).  
Синтаксис метода выглядит следующим образом:

```java
boolean b = scanner.hasNextInt();
```

Пример использования:

```java
private static void scannerExample() {
    while (true) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Введите число: ");
        if (scanner.hasNextInt()) {
            int number = scanner.nextInt();
            System.out.println("Спасибо! Вы ввели число: " + number);
            break;
        } else {
            System.out.println("Извините! Введённое значение не является числом. Пожалуйста, попробуйте снова.");
        }
    }
}
```

### 1.7.5 hasNextLine()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextLine()` класса `Scanner` проверяет, является ли следующая порция введенных данных строкой, или нет (
возвращает, соответственно, `true` или `false`).  
Использование метода [аналогично](#174-hasnextint) методу `hasNextInt()`.

### 1.7.6 hasNextByte()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextByte()` класса `Scanner` проверяет, является ли следующая порция введенных данных типом `byte`, или нет (
возвращает, соответственно, `true` или `false`).  
Использование метода [аналогично](#174-hasnextint) методу `hasNextInt()`.

### 1.7.7 hasNextShort()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextShort()` класса `Scanner` проверяет, является ли следующая порция введенных данных типом `short`, или
нет (возвращает, соответственно, `true` или `false`).  
Использование метода [аналогично](#174-hasnextint) методу `hasNextInt()`.

### 1.7.8 hasNextLong()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextLong()` класса `Scanner` проверяет, является ли следующая порция введенных данных типом `long`, или нет (
возвращает, соответственно, `true` или `false`).  
Использование метода [аналогично](#174-hasnextint) методу `hasNextInt()`.

### 1.7.9 hasNextFloat()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextFloat()` класса `Scanner` проверяет, является ли следующая порция введенных данных типом `float`, или
нет (возвращает, соответственно, `true` или `false`).  
Использование метода [аналогично](#174-hasnextint) методу `hasNextInt()`.

### 1.7.10 hasNextDouble()

> [[_оглавление_]](../README.md/#17)

Метод `hasNextDouble()` класса `Scanner` проверяет, является ли следующая порция введенных данных типом `double`, или
нет (возвращает, соответственно, `true` или `false`).  
Использование метода [аналогично](#174-hasnextint) методу `hasNextInt()`.

### 1.7.11 useDelimiter()

> [[_оглавление_]](../README.md/#17)

В метод `useDelimiter()` класса `Scanner` передается строка, которая используется в качестве разделителя.

Пример использования:

```java
private static void scannerUseDelimiterExample() {
    Scanner scanner = new Scanner("У лукоморья дуб зелёный;`" +
                                          "Златая цепь на дубе том:`" +
                                          "И днём и ночью кот учёный`" +
                                          "Всё ходит по цепи кругом;`");
    scanner.useDelimiter("`");
    while (scanner.hasNext()) {
        System.out.println(scanner.next());
    }
    scanner.close();
}
```

### 1.7.12 close()

> [[_оглавление_]](../README.md/#17)

Как и любой объект, работающий с потоками ввода-вывода, `Scanner` должен быть закрыт по завершении своей работы, чтобы
больше не потреблять ресурсы компьютера. Для этого используется метод `close()`.

## 1.8 Методы

> [[_оглавление_]](../README.md/#18)

[**Метод**](/conspect/definitions.md/#м) - это блок кода, который выполняет определенную функцию и позволяет
переиспользовать себя в нескольких местах без необходимости снова писать один и тот же код.  
Метод принадлежит какому-то объекту, то есть может быть объявлен исключительно внутри фигурных скобок (`{ }`) какого-то
из классов. Все методы класса располагаются на одном уровне параллельно другим методам.  
Все методы в Java отвечают за решение одной определённой задачи.  
Имя метода может быть любым, но начинать его принято с глагола, а само имя должно описывать происходящее в методе.

> Только имя метода `main` остается неизменным, так как именно по такой сигнатуре Java ищет запускающий метод.

[**Параметр метода**](/conspect/definitions.md/#п) - это значение, указываемое в круглых скобках (`( )`); переменная,
передаваемая в метод для его выполнения.  
Имена переменных при передаче в метод не имеют значения. Внутри метода они в любом случае будут присвоены тем
переменным, которые объявлены в скобках при объявлении метода.

Если внутри метода [модифицируется](#111-виды-переменных) примитив, то значение вне метода не поменяется, но если в
методе модифицируется объект, значение объекта вне метода поменяется тоже.

К примеру:

```java
// Объявляем метод
public static void changeValues(int a, int[] arr2) {
    a = 5;
    arr2[0] = 5;
}

public static void main(String[] args) {
    // Примитивный тип
    int a = 1;
    // Ссылочный тип
    int[] arr = {1, 2, 3};
    // Вызываем метод
    changeValues(a, arr);
    System.out.println(a);
    System.out.println(Arrays.toString(arr));
}
```

В консоли будет:

```
1       // Значение не поменялось, потому что int a — примитив
[5,2,3] // Значение поменялось, потому что int[] arr — объект
```

### 1.8.1 Модификаторы доступа

> [[_оглавление_]](../README.md/#18)

[**Модификатор доступа**](/conspect/definitions.md/#м) — это чаще всего ключевое слово, которое регулирует уровень
доступа к разным частям кода.

|           Модификатор           |                                                                         Ограничение                                                                          |
|:-------------------------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|            `public`             |                         поле или метод, которые имеют данный модификатор, будут доступны для вызова в любом другом классе программы                          |
|           `protected`           |                    поле или метод будут доступны в пакете, а также наследникам класса, где объявлен метод, даже если они в других пакетах                    |
| `default`<br/>`package-private` | поле или метод будут доступны в том пакете, где объявлены,<br/>то есть вызвать их смогут все классы, которые имеют тот же package (находятся в той же папке) |
|            `private`            |                                          поле или метод будут доступны только в том классе/файле, где был объявлены                                          |

### 1.8.2 Типы методов

> [[_оглавление_]](../README.md/#18)

Методы бывают двух типов:

- статические;
- нестатические.
  Именно это отражает наличие или отсутствие ключевого слова `static`.

> [**static**](/conspect/definitions.md/#s) - это ключевое слово, которое применяется для обозначения статических полей
> и методов уровня класса.

[**Статические методы**](/conspect/definitions.md/#с) - это методы, которые принадлежат классу, то есть не требующие
иметь объект класса для его вызова.  
[**Нестатические методы**](/conspect/definitions.md/#н) - это методы, которые принадлежат объекту, то есть для их
использования нужно создать объект, инициализировать его и вызвать у этого объекта метод.

> [**void**](/conspect/definitions.md/#v) - это ключевое слово, которое применяется для обозначения типа возвращаемого
> методом значения, и обозначает, что не будет возвращено ничего, то есть метод выполняет какой-то код и не сообщает о
> своём выполнении.

### 1.8.3 Идентичность методов

> [[_оглавление_]](../README.md/#18)

Даже имея одинаковые названия, методы не идентичны друг другу. Такими они являются при полном совпадении сигнатур.  
[**Сигнатура метода**](/conspect/definitions.md/#с) - это имя и параметры метода, причем порядок параметров внутри
скобок имеет значение.

### 1.8.4 Возвращение значений из метода

> [[_оглавление_]](../README.md/#18)

Слово, указанное перед именем метода, является возвращаемым значением.  
Методы делятся на два типа:

- возвращающие результат (имеют перед именем метода указание типа);
- не возвращающие результат (имеют перед именем метода `void`).
  Для возврата значения нужно написать ключевое слово `return` и указать после него результат.

> [**return**](/conspect/definitions.md/#r) - это ключевое слово/оператор, которое применяется для управления ходом
> выполнения кода: прерывания хода выполнения метода и возврата значения (результата выполнения) из метода в то место,
> где
> этот метод был вызван.

Оператор `return` должен быть во всех возможных вариантах развитиях событий, которые покрываются методом.

Кроме того, оператор `return` может применяться (но не обязательно) и в методах, не возвращающих результат. В этом
случае его применение обусловлено необходимостью прервать выполнение метода при наступлении каких-либо условий.

Пример такого применения:

```java
private static void returnInVoidMethodExample(int day) {
    if (day < 1 || day > 7) {
        System.out.println("Такого дня не существует!");
        return;
    } else {
        dayOfWeek(day);
    }
}
```

## 1.9 Объекты и классы

> [[_оглавление_]](../README.md/#19)

В основе языка Java используются объекты и классы, поэтому Java - это объектно-ориентированный язык.

### 1.9.1 Объекты

> [[_оглавление_]](../README.md/#19)

Классом является шаблон по созданию объектов, а сами объекты являются экземплярами конкретных шаблонов (классов).  
Переменные, тип которых мы создаем сами, являются объектами. Все объекты создаются через ключевое слово `new`.  
[**Объект**](/conspect/definitions.md/#о) - это область памяти, которая содержит переменные, объявленные в классе.  
Объекты имеют свойства (поля) и методы.

### 1.9.2 Классы

> [[_оглавление_]](../README.md/#19)

В языке Java каждый новый класс принято записывать в отдельном файле проекта.  
[**Класс**](/conspect/definitions.md/#к) - это шаблон для создания объекта; сущность, которая описывает состояние (
переменные), поведение (методы) и способы создания своих объектов, если они подразумеваются.  
Чтобы объявить класс, нам нужно написать ключевое слово `class` и поставить перед ним модификатор доступа. Обычно
это `public`. После слова `class` пишется его название и открываются фигурные скобки (`{ }`).

> [**class**](/conspect/definitions.md/#c) - это ключевое слово, которое применяется для создания классов Java.

Имена классов в Java пишутся в `UpperCamelCase`, то есть начинаются с большой буквы и каждое следующее слово в имени
тоже начинается с большой буквы.

**Типы классов:**

- _хранитель данных_;  
  Обычно эти классы не имеют «умений» и созданы только для агрегации в себе некоторых данных.

- _утилити-класс_;  
  Обычно эти классы имеют только «умения» и созданы для работы с другими объектами (например класс `Arrays` и массивы).

- _самодостаточные классы_.  
  Например, `String`. Имеют и состояние (массив символов, в виде которого хранятся данные строки), и поведение (методы,
  которые с этим состоянием работают, такие как `replace`).

### 1.9.3 Конструктор

> [[_оглавление_]](../README.md/#19)

[**Конструктор**](/conspect/definitions.md/#к) - это специальный метод, который вызывается при создании нового объекта и
предназначенный для корректной инициализации этого объекта.  
Конструктор создаётся следующим образом: пишется стандартная сигнатура метода, но без возвращаемого значения, а имя
метода должно соответствовать имени класса.

Пример использования:

```java
public class Human {
    private String name;
    private String surname;
    private int age;

    public Human(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

    public Human() {
        // Блок внутри скобок пустой
        // Так как логики при инициализации объекта не требуется
    }
}
```

В случае использования утилити-классов зачастую конструкторы ограничивают модификатором доступа `private`. Это делается
для того, чтобы нельзя было создать несколько объектов утилити-класса, а можно было использовать только его
статические (!) методы.

Пример использования:

- создаём класс-хранитель данных _Human_:

```java
public class Human {
    private String name;
    private String surname;
    private int age;

    public Human(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }

    public Human() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSurname() {
        return surname;
    }

    public void setSurname(String surname) {
        this.surname = surname;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Human human = (Human) o;
        return age == human.age && Objects.equals(name, human.name) && Objects.equals(surname, human.surname);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, surname, age);
    }

    @Override
    public String toString() {
        return "Human{" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                ", age=" + age +
                '}';
    }
}
```

- создаём утилити-класс _HumanUtility_, ограничив конструктор класса модификатором `private`, а также добавив в него
  статический (!) метод _isHumanAdult()_:

```java
public class HumanUtility {
    private HumanUtility() {
    }

    public static boolean isHumanAdult(Human human) {
        if (human.getAge() >= 18) {
            return true;
        } else if (human.getAge() >= 0) {
            return false;
        } else {
            throw new IllegalArgumentException("Human age must be greater than or equal to 0");
        }
    }
}
```

- в результате можем использовать статические методы утилити-класса _HumanUtility_ в коде, но при этом создать объект
  этого класса будет невозможно (при попытке создания объекта класса
  через `HumanUtility humanUtility = new HumanUtility();` возникнет ошибка и код не запустится):

```java
private static void utilityClassUsingExample() {
//    HumanUtility humanUtility = new HumanUtility(); // при попытке создать экземпляр класса HumanUtility возникнет ошибка
    Human ivan = new Human();
    ivan.setName("Ivan");
    ivan.setSurname("Ivanov");
    ivan.setAge(17);
    System.out.println(ivan);
    System.out.println(HumanUtility.isHumanAdult(ivan));
}
```

Конструкторы не могут быть вызваны в произвольное время, а вызываются именно при создании объекта.  
Также у конструкторов нет возвращаемого значения, так как они, по сути, всегда возвращают экземпляр класса (объект) того
типа, который их объявил.  
Статическими конструкторы тоже быть не могут, ведь статические методы принадлежат классу, а не объекту.

Когда конструктор в классе не создан вручную, Java создает в этом классе пустой (не содержащий аргументов) конструктор "
по-умолчанию". В случае, если конструктор создан вручную, то Java создавать конструктор "по-умолчанию" не будет, а
объект класса можно будет создавать только по созданному конструктору.

## 1.9.4 Ключевое слово ***this***

> [[_оглавление_]](../README.md/#19)

[**this**](/conspect/definitions.md/#t) - это переменная, которая всегда ссылается на конкретный объект данного
класса.  
Ключевое слово `this` используется для того, чтобы явно показать, к какой конкретно переменной мы обращаемся.

Ключевое слово `this`, кроме того, может использоваться в случае переопределения конструктора для инициализации объекта
с использованием параметров по-умолчанию и другого конструктора.

Пример использования:

```java
public class Human {
    private String name;
    private String surname;
    private int age;

    public Human(String name, int age) {
        // по сути, говорим, что нужно вызвать другой конструктор этого же класса, но с тремя параметрами
        this(name, null, age);
    }

    public Human(String name, String surname, int age) {
        this.name = name;
        this.surname = surname;
        this.age = age;
    }
}
```

В случае, когда параметр и переменная класса имеют разные имена, слово `this` можно опустить:

```java
public Book(String author, int pageAmount, String publisher) {
    author = author2;
    // author и author2 — разные имена
    // Поэтому в данном случае this можно не писать
    pageAmount = pageAmount2;
    publisher = publisher2;
}
```

Однако рекомендуется использовать способ с `this`.

### 1.9.5 Переменные класса (поля)

> [[_оглавление_]](../README.md/#19)

[**Поля (состояния)**](/conspect/definitions.md/#п) - это переменные класса.  
Область видимости полей ограничивается классом, где они объявлены.  
Однако следует помнить, что если поле класса совпадает по имени с параметром метода, необходимо
использовать `this.имя_поля` для обращения к полю, так как параметр или локальная переменная, которая объявлена в
конкретном методе с тем же именем, что и поле, будут «затенять» поле.  
Также поля могут иметь [модификаторы доступа](/conspect/1.md/#181-модификаторы-доступа), которые работают по тому же
принципу, что и у методов.  
Важно заметить, что поля `static final` являются константами (значения переменных с модификатором `final` нельзя
изменять) и пишутся капсом с разделением в виде (`_`) между словами.

> [**final**](/conspect/definitions.md/#f) - это ключевое слово, которое применяется для обозначения того, что значение
> переменной не может быть изменено после того, как оно было инициализировано.

> Чтобы обратиться к статическому полю, если оно `public`, нужно использовать вместо `имя_объекта.имя_поля`
> конструкцию `имя_класса.имя_поля`.

Нестатические поля могут различаться для каждого из объектов и именно их значения инициализируются в конструкторе.  
Статические же поля обычно задаются вручную (инициализируются) и меняются (в случае, например, со счётчиком) внутри
класса.  
В случае с полями, которые не были инициализированы явно, им
присваивается [значение по умолчанию](/conspect/1.md/#113-значения-переменных-по-умолчанию), как было в элементах
массива при его создании.

### 1.9.6 Геттеры и сеттеры

> [[_оглавление_]](../README.md/#19)

В Java, как и в других объектно-ориентированных языках,
используется [принцип инкапсуляции](/conspect/2.md/#221-инкапсуляция), то есть закрытия пользователю доступа к отдельным
методам и полям класса. Для доступа пользователя к необходимым для выполнения задач методам и полям класса используются
геттеры и сеттеры.  
Геттеры и сеттеры регулируют доступ к приватному полю. В случае необходимости дать доступ на чтение, но закрыть доступ
на изменение создается только геттер, а сеттер - нет.  
[**Геттер (getter)**](/conspect/definitions.md/#g) - это метод класса, предназначенный для предоставления пользователю
возможности получить значение приватного (`private`) поля класса.  
[**Сеттер (setter)**](/conspect/definitions.md/#s) - это метод класса, предназначенный для предоставления пользователю
возможности изменить значение приватного (`private`) поля класса.  
В случае, когда нужно предоставить полный доступ к полю (и чтение, и изменение), создаются оба метода.

> Имена геттеров и сеттеров обычно строятся следующим образом: глагол get/set и имя поля.

В сеттерах тоже используется `this` для обращения к полю, так как параметр принято называть тем же именем.  
Для работы со статическими полями нужно объявлять статические геттеры и сеттеры, то есть добавить ключевое
слово `static` после модификатора доступа.  
Для констант (`static final` поля) создание геттеров и сеттеров не применяется, так как их изменяемость заблокирована
модификатором `final`. Доступ к ним (для чтения) регулируется модификатором `public`/`private`. И обращение идет по
схеме: `имя_класса.ИМЯ_КОНСТАНТЫ`.

### 1.9.7 Методы объектов

> [[_оглавление_]](../README.md/#19)

В Java есть несколько методов, которые принято объявлять в любом классе, который хранит в себе какие-то данные. Эти
методы нестатические, так как должны работать с данными из полей конкретного объекта, и имеют строгую сигнатуру.  
Java генерирует эти методы автоматически внутри нашего класса и присваивает им достаточно примитивное и шаблонное
поведение.  
Чтобы задать свое поведение, нужно эти сгенерированные методы «переписать», то есть реализовать самим внутри нашего
класса и пометить флагом `@Override`.  
В Java такие «переписанные» методы называются **переопределенными**, а сам процесс называется **переопределением**.

#### 1.9.7.1 Переопределение метода

> [[_оглавление_]](../README.md/#19)

[**Переопределение метода**](/conspect/definitions.md#п) - это одна из возможностей языка программирования, позволяющая
подклассу или дочернему классу обеспечивать специфическую реализацию метода, уже реализованного в одном из суперклассов
или родительских классов.  
У переопределения есть ряд ограничений:

- у переопределенного метода должны быть те же аргументы, что и у метода родителя;
- у переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя;
- модификатор доступа у переопределенного метода также не может отличаться от «оригинального».

Переопределение методов в Java — один из инструментов для реализации идеи [полиморфизма]().

### 1.9.7.2 toString()

> [[_оглавление_]](../README.md/#19)

Метод `toString()` используется для приведения объекта к строковому виду. В нем необходимо вернуть строку в том формате,
в котором нужно видеть объект в печати.  
Сигнатура метода выглядит следующим образом:

```java

@Override
public String toString() {
    return "Human{" +
            "name='" + name + '\'' +
            ", surname='" + surname + '\'' +
            ", age=" + age +
            '}';
}
```

В стандартном своем исполнении метод возвращает полное имя класса, затем символ `@`, затем _hashCode_, в котором
находится число, полученное из генератора случайных чисел.

### 1.9.7.3 equals()

> [[_оглавление_]](../README.md/#19)

Метод `equals()` предназначен для определения равенства двух объектов.  
Метод `equals()` позволяет считать объекты равными, если совпадают те данные этих объектов, которые нужны.  
Сигнатура метода выглядит следующим образом:

```java

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Human human = (Human) o;
    return age == human.age && Objects.equals(name, human.name) && Objects.equals(surname, human.surname);
}
```

Стандартная реализация метода `equals()` просто сравнивает два объекта через `==`, то есть возвращает `true`, в случае,
если обе ссылки указывают на один и тот же объект в памяти компьютера.  
Благодаря переопределению метода `equals()` можно самостоятельно задать условия равенства объектов класса при его
создании.

При переопределении метода `equals()` необходимо соблюдать следующие правила:

- рефлексивность - любой объект должен быть равен самому себе;
- симметричность - если `a.equals(b) == true`, то и` b.equals(a)` должно возвращать `true`;
- транзитивность - если два объекта равны какому-то третьему объекту, значит, они должны быть равны друг и другу;
- постоянность - результаты работы метода должны меняться только при изменении данных сравниваемых объектов;
- неравенство с `null` - для любого объекта проверка `a.equals(null)` должна возвращать `false`.

### 1.9.7.4 hashCode()

> [[_оглавление_]](../README.md/#19)

Метод `hashCode()` предназначен для повышения производительности при определении равенства двух объектов.  
Метод выполняет первую и наименее точную проверку на равенство объектов.
Метод `hashCode()` выполняет функцию превращения объекта в число - кодировки (числовое значение фиксированной длины для
любого объекта).

> Метод `hashCode()` возвращает для любого объекта 32-битное число типа `int`.

Сигнатура метода выглядит следующим образом:

```java

@Override
public int hashCode() {
    return Objects.hash(name, surname, age);
}
```

Необходимость метода обусловлена тем, что сравнить два числа между собой - гораздо быстрее, чем сравнить два объекта
методом `equals()`, особенно если в нем используется много полей.

Стандартная реализация метода `hashCode()` будет возвращать случайное число, которое генерируется при первом вызове
метода.

### 1.9.7.5 Контракт между equals() и hashCode()

> [[_оглавление_]](../README.md/#19)

Для методов `equals()` и `hashCode()` действуют обязательные правила (контракт):

- если два объекта равны (то есть метод `equals()` возвращает `true`), у них должен быть одинаковый хэш-код;
- если метод `hashCode()` вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то
  же число;
- одинаковый хэш-код может быть у двух разных объектов.

Совпадение хэш-кодов у двух разных объектов называется [**коллизией**](/conspect/definitions.md/#к).  
В Java есть одна небольшая хитрость, которая используется для сокращения числа коллизий: при вычислении хэш-кода
умножать промежуточный результат на нечетное простое число. Чаще всего используется число 29 или 31.