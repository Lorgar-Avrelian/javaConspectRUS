# 5 Тестирование

> [[_оглавление_]](../README.md/#5-тестирование)

Тесты нужны для проверки качества и корректности кода на самом раннем этапе, когда код еще не вышел из рук разработчика.

Виды тестирования:

* модульные (_unit_) тесты - заключаются в тестировании отдельных методов и функций классов, компонентов или модулей;
* интеграционные тесты - проверяется, хорошо ли работают вместе различные модули и сервисы, используемые приложением;
* функциональные тесты - проверяют только результат некоторого действия и не проверяют промежуточные состояния системы
  при выполнении этого действия;
* сквозные тесты - копирует поведение пользователя при работе с ПО в контексте всего приложения (сценарии тестирования);
* приёмочное тестирование - формальные тесты, которые проверяют, отвечает ли система требованиям Заказчика;
* тестирование производительности - оценивается работа системы при определённой рабочей нагрузке;
* smoke-тестирование - базовые тесты, которые проверяют основные функциональные возможности приложения.

## 5.1 JUnit

> [[_оглавление_]](../README.md/#51-junit-)

[**JUnit**](/conspect/definitions.md/#j) - это основной фреймворк для модульных тестов на Java.

Тесты выглядят так же, как обычные методы с дополнительными аннотациями.

Работа с _JUnit5_ (актуальная версия _JUnit_) строится следующим образом:

- создаётся класс в разделе _test_ (вместо _main_), имя которого соответствует тестируемому + приписка `Test` в конце;
  пакет должен соответствовать пакету тестируемого файла, что помогает избежать проблем с доступом к
  методам `package-private`;
- в тестовом классе создается объект тестируемого класса и тестовые данные;
- пишутся методы, каждый из которых покрывает отдельный вариант развития событий: имена даются соответствующие (
  например, `shouldReturnHelloIvanWhenNameIvanReceived()`);
- методы помечаются необходимыми аннотациями;
- при необходимости пишутся методы, которые подготавливают тестовые данные;
- _JUnit_ запускает каждый из методов отдельно друг от друга.

Основные аннотации, используемые фреймворком _JUnit_ указаны в
разделе [3.4 Аннотации Spring](/conspect/3.md/#34-аннотации-spring).

Пример:

```java

@DisplayName(value = "Test of CounterServiceImpl")
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class CounterServiceImplTest {
    private final CounterService counterService = new CounterServiceImpl();

    @Test
    @DisplayName(value = "Get counter test")
    @Order(1)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void getCounter() {
        counterService.setCounter(0);
        int counterValue = counterService.getCounter();
        int expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
        counterValue = counterService.getCounter();
        expectedValue = 2;
        Assertions.assertEquals(expectedValue, counterValue);
        counterValue = counterService.getCounter();
        expectedValue = 3;
        Assertions.assertEquals(expectedValue, counterValue);
    }

    @Test
    @DisplayName(value = "Set counter test")
    @Order(2)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void setCounter() {
        counterService.setCounter(0);
        int counterValue = counterService.getCounter();
        int expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.setCounter(0);
        counterValue = counterService.getCounter();
        expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
    }

    @Test
    @DisplayName(value = "Set counter test 2")
    @Disabled("Test off")
    @Order(3)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void setCounter2() {
        counterService.setCounter(0);
        int counterValue = counterService.getCounter();
        int expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.setCounter(0);
        counterValue = counterService.getCounter();
        expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
    }
}
```

### 5.1.1 Подключение JUnit

> [[_оглавление_]](../README.md/#51-junit-)

Подключение фреймворка _JUnit_ производится путём добавления зависимости в файл:

- _pom.xml_:

```xml

<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
</dependency>
```

- _build.gradle_:

```groovy
// https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine
testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.11.0'
```

### 5.1.2 Класс Assertions

> [[_оглавление_]](../README.md/#51-junit-)

Проверка данных в тестах производится с помощью методов специальных классов. Эти методы проверяют условие и, если
условие не выполняется, вызывают специальный метод, который сообщают фреймворку о непройденном условии, а уже фреймворк
роняет тест. В случае прохождения проверки методы не делают ничего и, соответственно, дают тесту выполниться, получив
отметку «успех».  
Библиотека _JUnit5_ хранит такие методы в классе _Assertions_.  
Все методы класса _Assertions_ статические и не требуют создания объектов для вызова.

#### 5.1.2.1 assertEquals()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertEquals()` класса `Assertions` проверяет, что два объекта или примитива равны друг другу.  
Для проверки объектов на равенство у них должен быть реализован метод `equals()`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertEquals([ожидаемое_значение], [полученное_значение]);
```

#### 5.1.2.2 assertNotEquals()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertNotEquals()` класса `Assertions` проверяет, что два объекта или примитива не равны друг другу.  
Для проверки объектов на равенство у них должен быть реализован метод `equals()`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertNotEquals([ожидаемое_значение], [полученное_значение]);
```

#### 5.1.2.3 assertArrayEquals()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertArrayEquals()` класса `Assertions` проверяет, что два массива равны друг другу.  
Для проверки объектов на равенство у них должен быть реализован метод `equals()`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertArrayEquals([ожидаемое_значение_массива], [полученное_значение_массива]);
```

#### 5.1.2.4 assertIterableEquals()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertIterableEquals()` класса `Assertions` проверяет, что две коллекции равны друг другу.  
Для проверки объектов на равенство у них должен быть реализован метод `equals()`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertIterableEquals([ожидаемое_значение_коллекции], [полученное_значение_коллекции]);
```

#### 5.1.2.5 assertTrue()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertTrue()` класса `Assertions` проверяет, что переданный в него объект или результат выполнения метода
возвращает `true`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertTrue([проверяемое_значение]);
```

#### 5.1.2.6 assertFalse()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertFalse()` класса `Assertions` проверяет, что переданный в него объект или результат выполнения метода
возвращает `false`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertFalse([проверяемое_значение]);
```

#### 5.1.2.7 assertNull()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertNull()` класса `Assertions` проверяет, что переданный в него объект или результат выполнения метода
является `null`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertNull([проверяемое_значение]);
```

#### 5.1.2.8 assertNotNull()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertNotNull()` класса `Assertions` проверяет, что переданный в него объект или результат выполнения метода не
является `null`.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertNotNull([проверяемое_значение]);
```

#### 5.1.2.9 assertThrows()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertThrows()` класса `Assertions` проверяет, что при выполнении операции выбрасывается исключение указанного
типа.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertThrows([класс_исключения], [лямбда_операции]);
```

Пример:

```text
Assertions.assertThrows(IllegalArgumentException.class, () -> out.generateGreetings(ILLEGAL_ARGUMENT_NAME));
```

Метод имеет два параметра. Первый параметр принимает класс ожидаемого исключения, второй параметр принимает лямбду,
которая не имеет параметров и должна вызывать тестируемый метод.

#### 5.1.2.10 assertDoesNotThrow()

> [[_оглавление_]](../README.md/#51-junit-)

Метод `assertDoesNotThrow()` класса `Assertions` проверяет, что при выполнении операции не выбрасывается исключений.

Синтаксис метода выглядит следующим образом:

```java
Assertions.assertDoesNotThrow([лямбда_операции]);
```

Пример:

```text
Assertions.assertThrows(() -> out.generateGreetings(NORMAL_ARGUMENT_NAME));
```

Метод имеет один параметр в виде лямбды без параметров, которая вызывает проверяемый код.

## 5.2 Параметризованные тесты

> [[_оглавление_]](../README.md/#52-параметризованные-тесты)

Параметризованные тесты позволяют вызвать тест несколько раз с различными параметрами: разные значения, разные входные
параметры, разные имена пользователей.

Для использования параметризованных тестов нужно добавить отдельную библиотеку в файл:

- _pom.xml_:

```xml
<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-params</artifactId>
    <version>5.11.0</version>
    <scope>test</scope>
</dependency>
```

- _build.gradle_:

```groovy
// https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params
testImplementation 'org.junit.jupiter:junit-jupiter-params:5.11.0'
```

Параметризованные тесты создаются в следующем порядке:

- создаётся сам тестовый класс стандартным способом (<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>);
- в тестовом классе создаётся статический метод, который возвращает `Stream<Arguments>` (объекты типа `Arguments`,
  которые затем фреймворк подставит в качестве параметра в тестирующий метод);
- отметить тестовый метод, который должен получать параметризованный поток, аннотациями `@ParameterizedTest` (вместо
  аннотации `@Test`) и аннотациями `@MethodSource`, `@EnumSource`, `@NullSource` или `@ValueSource`;
- запустить тест.

Пример:

```java
class GreetingsServiceParameterizedTest {

    private final GreetingsService out = new GreetingsService();

    @Test
    public void shouldReturnDefaultMessageWhenNameIsNotExists() {
        String result = out.generateGreetings();
        assertTrue(result.contains(DEFAULT_NAME));
        assertEquals(DEFAULT_MESSAGE, result);
    }

    @ParameterizedTest
    @MethodSource("provideParamsForTests")
    public void shouldGenerateCorrectMessages(String inputName, String messageName, String expectedMessage) {
        String result = out.generateGreetings(inputName);
        assertTrue(result.contains(messageName));
        assertEquals(expectedMessage, result);
    }

    @Test
    public void shouldThrowIllegalArgumentExceptionWhenNameContainsIllegalCharacters() {
        assertThrows(IllegalArgumentException.class,
                     () -> out.generateGreetings(ILLEGAL_CHARACTERS_NAME)
                    );
    }

    public static Stream<Arguments> provideParamsForTests() {
        return Stream.of(
                Arguments.of(null, DEFAULT_NAME, DEFAULT_MESSAGE),
                Arguments.of(EMPTY_NAME, DEFAULT_NAME, DEFAULT_MESSAGE),
                Arguments.of(ONLY_SPACES_NAME, DEFAULT_NAME, DEFAULT_MESSAGE),
                Arguments.of(CORRECT_NAME, CORRECT_NAME, CORRECT_MESSAGE),
                Arguments.of(UPPER_CASE_NAME, CORRECT_NAME, CORRECT_MESSAGE),
                Arguments.of(LOWER_CASE_NAME, CORRECT_NAME, CORRECT_MESSAGE)
                        );
    }
}
```

## 5.3 Mockito

> [[_оглавление_]](../README.md/#53-mockito)

[**Mockito**](/conspect/definitions.md/#m) - это фреймворк для тестирования приложений.  
С помощью _Mockito_ могут быть созданы и настроены объекты `Mock`, которые упрощают тем самым тестирование классов с
внешними зависимостями.

[**Mock**](/conspect/definitions.md/#m) - это объект, который является наследником (в случае мокирования классов) или
реализацией (в случае мокирования интерфейсов) создаваемых при тестировании сущностей, поведение которых задаётся
тестировщиком.

Типы моков фреймворка _Mockito_:

- _Mock_ - логика мокируемого объекта отсутствует;
- _Spy_ - логика мокируемого объекта присутствует.

> [[_Примеры использования_]](/conspect/example_3.md/#пример-1)

### 5.3.1 Подключение Mockito

> [[_оглавление_]](../README.md/#53-mockito)

Подключается _Mockito_ таким же образом, как любая библиотека или фреймворк, то есть через систему сборки.  
Для использования _Mockito_ нужно добавить отдельную библиотеку в файл:

- _pom.xml_:

```xml
<!-- https://mvnrepository.com/artifact/org.mockito/mockito-core -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.13.0</version>
    <scope>test</scope>
</dependency>
```

```xml
<!-- https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <version>5.13.0</version>
    <scope>test</scope>
</dependency>
```

- _build.gradle_:

```groovy
// https://mvnrepository.com/artifact/org.mockito/mockito-core
testImplementation 'org.mockito:mockito-core:5.13.0'
// https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter
testImplementation 'org.mockito:mockito-junit-jupiter:5.13.0'
```

> Добавляемая при создании проекта зависимость `spring-boot-starter-test` уже содержит внутри _JUnit_ и _Mockito_,
> поэтому вручную их подключать не требуется.

Тестовый класс, в котором планируется использование _Mockito_, должен быть расширен с помощью аннотации `@ExtendWith`, в
которую необходимо добавить класс `MockitoExtension.class`.

Пример:

```java

@DisplayName(value = "Test of CounterServiceImpl")
@ExtendWith(MockitoExtension.class)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class CounterServiceImplTest {
    private final CounterService counterService = new CounterServiceImpl();

    @Test
    @DisplayName(value = "Get counter test")
    @Order(1)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void getCounter() {
        counterService.setCounter(0);
        int counterValue = counterService.getCounter();
        int expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
        counterValue = counterService.getCounter();
        expectedValue = 2;
        Assertions.assertEquals(expectedValue, counterValue);
        counterValue = counterService.getCounter();
        expectedValue = 3;
        Assertions.assertEquals(expectedValue, counterValue);
    }

    @Test
    @DisplayName(value = "Set counter test")
    @Order(2)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void setCounter() {
        counterService.setCounter(0);
        int counterValue = counterService.getCounter();
        int expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.setCounter(0);
        counterValue = counterService.getCounter();
        expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
    }

    @Test
    @DisplayName(value = "Set counter test 2")
    @Disabled("Test off")
    @Order(3)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void setCounter2() {
        counterService.setCounter(0);
        int counterValue = counterService.getCounter();
        int expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.getCounter();
        counterService.setCounter(0);
        counterValue = counterService.getCounter();
        expectedValue = 1;
        Assertions.assertEquals(expectedValue, counterValue);
    }
}
```

### 5.3.2 Применение Mockito

> [[_оглавление_]](../README.md/#53-mockito)

#### 5.3.2.1 Создание моков

> [[_оглавление_]](../README.md/#53-mockito)

Моки можно создавать двумя способами:

- с использованием статических методов класса `Mockito` `mock()` или `spy()`:

```text
[имя_класса] [имя_переменной] = Mockito.mock([имя_класса].class);

[имя_класса] [имя_переменной] = Mockito.spy([объект].class);
```

- с использованием аннотаций `@Mock` или `@Spy`.

Примеры:

```java

@ExtendWith(MockitoExtension.class)
class MockTest {
    @Test
    public void whenNotUseMockAnnotation_thenCorrect() {
        List<String> mockList = Mockito.mock(ArrayList.class);
        //эти методы не будут ничего делать – это заглушки
        mockList.add("one");
        mockList.add("two");
    }
}
```

```java

@ExtendWith(MockitoExtension.class)
class MockTest {
    @Mock
    List<String> mockList;

    @Test
    public void whenNotUseMockAnnotation_thenCorrect() {
        //эти методы не будут ничего делать – это заглушки
        mockList.add("one");
        mockList.add("two");
    }
}
```

```java

@ExtendWith(MockitoExtension.class)
class SpyTest {
    @Test
    public void whenMockAnnotation() {
        List<String> mockList = Mockito.spy(new ArrayList<String>());
        //эти методы будут работать!
        mockList.add("one");
        mockList.add("two");
    }
}
```

```java

@ExtendWith(MockitoExtension.class)
class SpyTest {
    @Spy
    List<String> mockList = new ArrayList<String>();

    @Test
    public void whenMockAnnotation() {
        // эти методы будут работать!
        mockList.add("one");
        mockList.add("two");
    }
}
```

> Чтобы создать _mock_ для _final_-класса или _mock_-экземпляр _enum_ или переопределить поведение _final_-метода,
> достаточно создать в проекте файл _test/resources/mockito-extensions/org.mockito.plugins.MockMaker_ и вписать в него
> строчку: `mock-maker-inline`. После этого можно имитировать обычным способом _final_-классы и _enum_-ы, а также
> переопределять _final_-методы.

Разница между _mock_-объектом и _spy_-объектом в том, что _mock_-объект - это полностью эмулированный объект, методы
которого по умолчанию возвращают значения `0` для примитивов, `null` - для объектов (кроме коллекций и массивов) и
коллекции или массивы, наполненные значениями `0` или `null`, - для коллекций и массивов, соответственно, в то время как
_spy_-объект - это копия, полностью совпадающая с реально используемым объектом (поведение методов остаётся тем же),
поведение отдельных методов которой и возвращаемые значения можно переопределить.  
`@Mock` используется, если нужно:

- имитировать все методы класса;
- просто протестировать логику внутри метода без использования внешних зависимостей.

`@Spy` используется, если нужно:

- имитировать некоторые методы, а для оставшихся методов - сделать фактический вызов;
- запустить приложение "как есть" и просто заглушить определенные методы.

> В интеграционных тестах _spy_-объектами должны являться все сервисы, все остальные объекты должны быть
> _mock_-объектами.

#### 5.3.2.2 Внедрение моков

> [[_оглавление_]](../README.md/#53-mockito)

Моки можно внедрять двумя способами:

- созданием тестируемого объекта в методе-конструкторе перед каждым тестом;

```java
private CounterService counterService;

@BeforeEach
void setUp() {
    counterService = new CounterServiceImpl();
}
```

- с помощью аннотации `@InjectMocks`.

```java

@InjectMocks
private CounterServiceImpl counterService;
```

С помощью аннотации `@InjectMocks` создаётся экземпляр **_тестируемого_** класса, в который внедряются _mock_-объекты и
_spy_-объекты.

#### 5.3.2.3 Переопределение поведения моков

> [[_оглавление_]](../README.md/#53-mockito)

Моделирование поведения моков производится с помощью статического метода класса `Mockito` `when()`.

##### 5.3.2.3.1 when()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `when()` класса `Mockito` принимает на вход метод, поведение которого необходимо изменить.

Синтаксис метода выглядит следующим образом:

```text
Mockito.when([мок].[метод_мока()]);
Mockito.when([мок].[метод_мока([входное_значение_метода_мока])]);
```

Пример:

```text
Mockito.when(repositoryMock.add(any()));
```

##### 5.3.2.3.2 thenReturn()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `thenReturn()` класса `Mockito` возвращает результат работы метода, указанного в методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.when([мок].[метод_мока()]).thenReturn([желаемый_результат]);
Mockito.when([мок].[метод_мока([входное_значение_метода_мока])]).thenReturn([желаемый_результат]);
```

Пример:

```text
Mockito.when(repositoryMock.add(TEAM_NAME_1))
                .thenReturn(TEAM_NAME_1);
```

Данный метод принимает на вход желаемый результат, который возвращает при вызове метода мока, указанного в
методе `when()`.
> Моделируемый метод должен возвращать какое-либо значение.

##### 5.3.2.3.3 thenThrow()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `thenThrow()` класса `Mockito` выкидывает исключение в качестве результата работы метода, указанного в
методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.when([мок].[метод_мока()]).thenThrow([класс_исключения].class);
Mockito.when([мок].[метод_мока([входное_значение_метода_мока])]).thenThrow([класс_исключения].class);
```

Пример:

```text
Mockito.when(repositoryMock.add(any()))
                .thenThrow(TeamExistsException.class);
```

Данный метод принимает на вход класс исключения, которое выбрасывает при вызове метода мока, указанного в
методе `when()`.
> Моделируемый метод должен возвращать какое-либо значение.

##### 5.3.2.3.4 doReturn()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `doReturn()` класса `Mockito` возвращает объект (не обязательно совпадающий по типу с указанным в методе), который
является результатом работы метода, указанного в методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.doReturn([желаемый_результат]).when([мок].[метод_мока()]);
Mockito.doReturn([желаемый_результат]).when([мок].[метод_мока([входное_значение_метода_мока])]);
```

Пример:

```text
Mockito.doReturn(TEAM_NAME_1)
                .when(repositoryMock.add(TEAM_NAME_1));
```

Данный метод принимает на вход объект (не обязательно совпадающий по типу с указанным в методе), который возвращает при
вызове метода мока, указанного в методе `when()`.
> Моделируемый метод должен возвращать какое-либо значение.

##### 5.3.2.3.5 doThrow()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `doThrow()` класса `Mockito` выкидывает исключение в качестве результата работы метода, указанного в
методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.doThrow([класс_исключения].class).when([мок].[метод_мока()]);
Mockito.doThrow([класс_исключения].class).when([мок].[метод_мока([входное_значение_метода_мока])]);
```

Пример:

```text
Mockito.doThrow(TeamExistsException.class)
                .when(repositoryMock.add(TEAM_NAME_1));
```

Данный метод принимает на вход класс исключения, которое выбрасывает при вызове метода мока, указанного в
методе `when()`.
> Моделируемый метод должен быть `void`.

##### 5.3.2.3.6 doNothing()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `doNothing()` класса `Mockito` блокирует выполнение любых операций при вызове метода, указанного в
методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.doNothing().when([мок].[метод_мока()]);
Mockito.doNothing().when([мок].[метод_мока([входное_значение_метода_мока])]);
```

Пример:

```text
Mockito.doNothing()
                .when(repositoryMock.add(TEAM_NAME_1));
```

##### 5.3.2.3.7 doCallRealMethod()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `doCallRealMethod()` класса `Mockito` вызывает выполнение моделируемого метода с установленными параметрами (если
они имеются) при вызове метода, указанного в методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.doCallRealMethod().when([мок].[метод_мока()]);
Mockito.doCallRealMethod().when([мок].[метод_мока([входное_значение_метода_мока])]);
```

Пример:

```text
Mockito.doCallRealMethod()
                .when(repositoryMock.add(TEAM_NAME_1));
```

##### 5.3.2.3.8 thenCallRealMethod()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `thenCallRealMethod()` класса `Mockito` вызывает выполнение моделируемого метода с установленными параметрами
(если они имеются) при вызове метода, указанного в методе `when()`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.when([мок].[метод_мока()]).thenCallRealMethod();
Mockito.when([мок].[метод_мока([входное_значение_метода_мока])]).thenCallRealMethod();
```

Пример:

```text
Mockito.when(repositoryMock.add(TEAM_NAME_1))
                .thenCallRealMethod();
```

##### 5.3.2.3.9 lenient()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `lenient()` класса `Mockito` позволяет игнорировать возникающие при тестировании исключений
типа `StubbingException`.

Синтаксис метода выглядит следующим образом:

```text
Mockito.lenient().when(...).thenReturn(...);
```

Исключения _StubbingException_ выбрасываются в случаях обнаружения не используемых моков в тестовом коде, а также
дублирования тестового кода или обнаружения ненужного тестового кода.

#### 5.3.2.4 Ожидаемые параметры методов моков

> [[_оглавление_]](../README.md/#53-mockito)

Для методов моков можно привязать определённый результат к передаче определённого параметра с определённым значением.

##### 5.3.2.4.1 any(), anyInt(), anyBoolean(), anyChar(), anyByte(), anyShort(), anyLong(), anyFloat(), anyDouble()

> [[_оглавление_]](../README.md/#53-mockito)

Методы `any()` и его
производные `anyInt()`, `anyBoolean()`, `anyChar()`, `anyByte()`, `anyShort()`, `anyLong()`, `anyFloat()`,
`anyDouble()`, `anyList()`, `anySet()`, `anyMap()` класса `Mockito` позволяют возвращать один результат для всех
случаев, когда ожидаемый параметр метода относится к указанному типу.

Синтаксис метода выглядит следующим образом:

```text
when([мок].[метод_мока(any())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(any([класс_объекта].class))]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyInt())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyBoolean())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyChar())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyByte())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyShort())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyLong())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyFloat())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyDouble())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyList())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anySet())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(anyMap())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(any([класс_объекта].class), anyInt(), anyBoolean(), anyChar(), anyByte(), anyShort(), anyLong(), anyFloat(), anyDouble(), anyList(), anySet(), anyMap())]).thenReturn([желаемый_результат]);
```

##### 5.3.2.4.2 eq()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `eq()` класса `Mockito` позволяет возвращать результат для случая, когда ожидаемый параметр метода равен
указанному значению.

Синтаксис метода выглядит следующим образом:

```text
when([мок].[метод_мока(eq([значение]))]).thenReturn([желаемый_результат]);
```

##### 5.3.2.4.3 same()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `same()` класса `Mockito` позволяет возвращать результат для случая, когда ссылка на ожидаемый объект метода
совпадает с указанной ссылкой на объект.

Синтаксис метода выглядит следующим образом:

```text
when([мок].[метод_мока(same([значение]))]).thenReturn([желаемый_результат]);
```

##### 5.3.2.4.4 contains()

> [[_оглавление_]](../README.md/#53-mockito)

Метод `contains()` класса `Mockito` позволяет возвращать результат для случая, когда пришедшая строка содержит указанный
фрагмент.

Синтаксис метода выглядит следующим образом:

```text
when([мок].[метод_мока(contains([строчное_значение]))]).thenReturn([желаемый_результат]);
```

> Используется только для входных параметров методов типа `String`.

##### 5.3.2.4.5 endsWith() и startsWith()

> [[_оглавление_]](../README.md/#53-mockito)

Методы `endsWith()` и `startsWith()` класса `Mockito` позволяют возвращать результат для случаев, когда пришедшая строка
начинается или оканчивается указанным фрагментом, соответственно.

Синтаксис метода выглядит следующим образом:

```text
when([мок].[метод_мока(startsWith([строчное_значение]))]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(endsWith([строчное_значение]))]).thenReturn([желаемый_результат]);
```

> Используется только для входных параметров методов типа `String`.

##### 5.3.2.4.6 isNull() и isNotNull()

> [[_оглавление_]](../README.md/#53-mockito)

Методы `isNull()` и `isNotNull()` класса `Mockito` позволяют возвращать результат для случаев, когда пришедшее значение
равно или не равно `null`, соответственно.

Синтаксис метода выглядит следующим образом:

```text
when([мок].[метод_мока(isNull())]).thenReturn([желаемый_результат]);
when([мок].[метод_мока(isNotNull())]).thenReturn([желаемый_результат]);
```

> Используется только для входных параметров методов типа `Object`.

#### 5.3.2.5 Проверка вызова методов моков

> [[_оглавление_]](../README.md/#53-mockito)

Проверки не просто результата работы метода, а самого факта его вызова, происходят через построение логических цепочек
проверок с использованием метода `verify()`.

Метод `verify()` класса `Mockito` позволяют проверять вызовы методов моков.

Синтаксис метода выглядит следующим образом:

```text
verify([мок], [условие_проверки()]).[метод_мока()];
```

Данный метод в качестве параметра получает вызов метода мока и проверяет, что этот метод был вызван определенное
количество раз.

Условия проверки моков указываются в качестве второго аргумента метода `verify()`.  
Условия проверки моков с использованием метода `verify()`:

- `times([количество_раз])` - указывает, что конкретный вызов должен быть произведен определенное число раз;
- `only()` - указывает, что конкретный вызов должен быть один раз;
- `never()` - указывает, что конкретный вызов не должен быть произведён ни разу;
- `atLeast([количество_раз])` - указывает, что конкретный вызов должен быть произведен определенное число раз или
  больше;
- `atMost([количество_раз])` - указывает, что конкретный вызов должен быть произведен определенное число раз или меньше.

## 5.4 Тестирование web-приложений

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Тестирование _web_-приложений относится к типу интеграционного тестирования и может производиться двумя путями:

- с использованием _TestRestTemplate_;
- с использованием _WebMvcTest_.

### 5.4.1 Тестирование с помощью TestRestTemplate

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Тестирование приложений с использованием класса _TestRestTemplate_ основано на имитации реальных запросов пользователя в
контроллеры приложения. Вследствие чего перед началом проведения тестов необходимо:

1. подключить _in-memory-DB_, дабы не засорять основную базу данных информацией, необходимой только на время
   тестирования;
2. изменить конфигурацию порта, на котором должно запускаться приложение для проведения теста, с помощью атрибута
   _webEnvironment_ аннотации `@SpringBootTest`;
3. протестировать _API_ контроллера.

Подключение _H2-database_ в качестве _in-memory-DB_ для тестирования производится в следующем порядке:

- установить область видимости для основной базы данных _runtime_, для чего установить в файле:
    * _pom.xml_ изменить зависимость:
  ```xml
  <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<version>42.7.4</version>
			<scope>runtime</scope>
		</dependency>
  ```
    * _build.gradle_ изменения не требуются;
- подключить _JDBC_-провайдер для _H2-database_, для чего в фале:
    * _pom.xml_ добавить зависимость:
  ```xml
  <!-- https://mvnrepository.com/artifact/com.h2database/h2 -->
		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<version>2.3.232</version>
			<scope>test</scope>
		</dependency>
  ```
    * _build.gradle_ добавить зависимость:
  ```groovy
  // https://mvnrepository.com/artifact/com.h2database/h2
  testImplementation 'com.h2database:h2:2.3.232'
  ```
- создать (если отсутствует) файл _application-test.properties_ в директории _src/test/resources_;
- добавить в файл _application-test.properties_ настройки базы данных _H2-database_:
  ```properties
  # Application properties
  spring.application.name=Java conspectus RUS
  # Specific parameter for BookCoverService implementations
  books.covers.dir.path=src/test/resources/testImages/result
  # Spring Data JPA parameters for DB connection
  spring.datasource.driver-class-name=org.h2.Driver
  spring.datasource.url=jdbc:h2:mem:library
  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
  spring.jpa.properties.hibernate.globally_quoted_identifiers=true
  # Hibernate settings
  # Hibernate ddl auto (create, create-drop, validate, update)
  spring.jpa.hibernate.ddl-auto=create
  ```

Аннотация `@SpringBootTest` предоставляет следующие функции сверх обычного _Spring TestContext Framework_:

* использует _SpringBootContextLoader_ по умолчанию и _ContextLoader_, если конкретное
  значение `@ContextConfiguration(loader=...)` не определено;
* автоматически ищет `@SpringBootConfiguration`, когда не используется вложенная конфигурация `@Configuration` и явно не
  указаны классы;
* позволяет определять пользовательские свойства _Environment_ с помощью атрибута _properties_;
* позволяет определять аргументы приложения с помощью атрибута _args_;
* обеспечивает поддержку различных _webEnvironment_ режимов, включая возможность запуска полностью работающего
  web-сервера, прослушивающего определённый или случайный порт;
* регистрирует bean-компоненты _TestRestTemplate_ и/или _WebTestClient_ для использования в web-тестах, использующих
  полностью работающий web-сервер.

При создании теста стартера автоматически генерируется тестовый метод `contextLoads()`, который предназначен для
тестирования контекста приложения. В нём необходимо протестировать создание контроллеров приложения при запуске с
помощью _Spring Boot_.

Пример:

```java

@DisplayName(value = "Test of JavaConspectRusApplication")
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class JavaConspectRusApplicationTests {

    @Autowired
    private ReaderController readerController;
    @Autowired
    private BooksController booksController;

    @Test
    @DisplayName(value = "Context load test")
    @Order(1)
    void contextLoads() {
        Assertions.assertThat(readerController).isNotNull();
        Assertions.assertThat(booksController).isNotNull();
    }
}
```

Тестирование самих _API_ контроллеров (их методов), как правило, производится в тестовых классах этих контроллеров.

> Автоматическое создание тестового класса для тестируемого класса из _Intellij IDEA_ производится нажатием сочетания
> клавиш <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>.

Тестирование _API_ контроллеров с помощью _TestRestTemplate_ производится в следующем порядке:

- создание тестового класса контроллера и пометка его аннотацией`@SpringBootTest` с установкой значения атрибута
  _webEnvironment_ на случайный порт
  (например: `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`);
- указание _Spring_ конкретного _properties_-файла в качестве источника настроек для проведения тестов с помощью
  аннотации `@TestPropertySource`
  (например: `@TestPropertySource(locations = "classpath:application-test.properties")`);
- внедрение в созданном тестовом классе контроллера следующих значений:
    * значение локального порта запуска теста с помощью аннотации `@LocalServerPort`;
    * состояние инструментального класса _TestRestTemplate_ с помощью аннотации `@Autowired`;
    * создание нового объекта класса _ObjectMapper_ (необходим для проверки содержания _HTTP_-ответов);
- написание тестовых методов для методов контроллера в созданном тестовом классе.

> При тестировании _API_ контроллеров с помощью _TestRestTemplate_ необходимо учитывать:
> - сущности, используемые для тестов, должны располагаться в классе _Constants_ в директории _constants_ (например:
    _src/test/java/lorgar/avrelian/javaconspectrus/constants/Constants.java_);
> - при построении алгоритмов тестов необходимо сначала тестировать успешное выполнение, а только потом _HTTP_-ответы на
    ошибочные запросы;
> - при построении _HTTP_-запросов необходимо обращать внимание на то, как формируется адресная строка запроса;
> - при внесении/удалении данных в/из БД при проведении одного теста, они будут присутствовать/отсутствовать в ней при
    проведении следующего теста;
> - в _HTTP_-ответах не могут содержаться коллекции или ассоциативные массивы, там содержатся массивы объектов или пар
    "ключ-значение";
> - для тестирования статусов _HTTP_-ответов PUT-запросов и DELETE-запросов необходимо использовать метод `exchange()`,
    поскольку методы `put()` и `delete()` класса _TestRestTemplate_ являются _void_-методами.

> [[_Примеры использования_]](/conspect/example_9.md/#пример-1)

#### 5.4.1.1 getForObject()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `getForObject()` класса `TestRestTemplate` позволяет получить объект указанного типа в качестве результата
тестового GET-запроса.

Синтаксис метода выглядит следующим образом:

```java
public <T> T getForObject(String url, Class<T> responseType, Object... urlVariables);

public <T> T getForObject(String url, Class<T> responseType, Map<String, ?> urlVariables);

public <T> T getForObject(URI url, Class<T> responseType);
```

#### 5.4.1.2 getForEntity()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `getForEntity()` класса `TestRestTemplate` позволяет получить HTTP-ответ с объектом указанного типа в качестве
результата тестового GET-запроса.

Синтаксис метода выглядит следующим образом:

```java
public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Object... urlVariables);

public <T> ResponseEntity<T> getForEntity(String url, Class<T> responseType, Map<String, ?> urlVariables);

public <T> ResponseEntity<T> getForEntity(URI url, Class<T> responseType);
```

#### 5.4.1.3 postForObject()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `postForObject()` класса `TestRestTemplate` позволяет получить объект указанного типа в качестве результата
тестового POST-запроса.

Синтаксис метода выглядит следующим образом:

```java
public <T> T postForObject(String url, Object request, Class<T> responseType, Object... urlVariables);

public <T> T postForObject(String url, Object request, Class<T> responseType, Map<String, ?> urlVariables);

public <T> T postForObject(URI url, Object request, Class<T> responseType);
```

#### 5.4.1.4 postForEntity()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `postForEntity()` класса `TestRestTemplate` позволяет получить HTTP-ответ с объектом указанного типа в качестве
результата тестового POST-запроса.

Синтаксис метода выглядит следующим образом:

```java
public <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType, Object... urlVariables);

public <T> ResponseEntity<T> postForEntity(String url, Object request, Class<T> responseType, Map<String, ?> urlVariables);

public <T> ResponseEntity<T> postForEntity(URI url, Object request, Class<T> responseType);
```

#### 5.4.1.5 put()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `put()` класса `TestRestTemplate` позволяет отправить тестовый PUT-запрос.

Синтаксис метода выглядит следующим образом:

```java
public void put(String url, Object request, Object... urlVariables);

public void put(String url, Object request, Map<String, ?> urlVariables);

public void put(URI url, Object request);
```

Данный метод ничего не возвращает в качестве результата выполнения.

#### 5.4.1.6 patchForObject()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `patchForObject()` класса `TestRestTemplate` позволяет получить объект указанного типа в качестве результата
тестового PATCH-запроса.

Синтаксис метода выглядит следующим образом:

```java
public <T> T patchForObject(String url, Object request, Class<T> responseType, Object... uriVariables);

public <T> T patchForObject(String url, Object request, Class<T> responseType, Map<String, ?> uriVariables);

public <T> T patchForObject(URI url, Object request, Class<T> responseType);
```

#### 5.4.1.7 delete()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `delete()` класса `TestRestTemplate` позволяет отправить тестовый DELETE-запрос.

Синтаксис метода выглядит следующим образом:

```java
public void delete(String url, Object... urlVariables);

public void delete(String url, Map<String, ?> urlVariables);

public void delete(URI url);
```

Данный метод ничего не возвращает в качестве результата выполнения.

#### 5.4.1.8 exchange()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `exchange()` класса `TestRestTemplate` позволяет получить HTTP-ответ с объектом указанного типа в качестве
результата любых типов тестовых HTTP-запросов.

Синтаксис метода выглядит следующим образом:

```java
public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType, Object... urlVariables);

public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType, Map<String, ?> urlVariables);

public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity, Class<T> responseType);

public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType, Object... urlVariables);

public <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType, Map<String, ?> urlVariables);

public <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity, ParameterizedTypeReference<T> responseType);

public <T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, Class<T> responseType);

public <T> ResponseEntity<T> exchange(RequestEntity<?> requestEntity, ParameterizedTypeReference<T> responseType);
```

#### 5.4.1.9 withBasicAuth()

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Метод `withBasicAuth()` класса `TestRestTemplate` позволяет отправлять HTTP-запросы с заданными параметрами базовой
аутентификации.

Синтаксис метода выглядит следующим образом:

```java
public TestRestTemplate withBasicAuth(String username, String password);
```

Данный метод используется в приложениях, использующих настройки безопасности _Spring Security_.

### 5.4.2 Тестирование с помощью WebMvcTest

> [[_оглавление_]](../README.md/#54-тестирование-web-приложений)

Тестирование с помощью _WebMvcTest_ основано на взаимодействии не с реальными объектами, а с шаблонами, имеющими
заданное поведение.

Тестирование самих _API_ контроллеров (их методов) с помощью WebMvcTest, как правило, производится в одном классе,
находящемся на одном уровне со стартером приложения.

> Автоматическое создание тестового класса для тестируемого класса из _Intellij IDEA_ производится нажатием сочетания
> клавиш <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd>.

Тестирование _API_ контроллеров с помощью _WebMvcTest_ производится в следующем порядке:

- создание тестового класса контроллера и пометка его аннотацией `@WebMvcTest` (желательно при помощи атрибута
  _controllers_ для данной аннотации указать класс контроллера, который тестируется в данном тестовом классе);
- внедрить в тестовый класс следующие bean-компоненты:
    * при помощи аннотации `@Autowired` внедрить экземпляр класса _MockMvc_;
    * при помощи аннотации `@InjectMocks` внедрить экземпляр тестируемого контроллера;
    * при помощи аннотации `@SpyBean` внедрить все экземпляры сервисов, которые необходимы для работы тестируемого
      контроллера;
    * при помощи аннотации `@MockBean` внедрить все макеты репозиториев, которые необходимы для работы внедрённых
      сервисов, а также макеты других bean-компонентов, необходимых для тестирования контроллера;
- протестировать _API_ контроллера.

> В случае выброса исключений _UnsatisfiedDependencyException_ (ошибка создания bean-компонента) и
> _IllegalStateException_ (ошибка контекста приложения) необходимо указать _Spring_ путь и название пакета, в котором
> производить поиск нужных компонентов, с помощью аннотации `@ComponentScan`.  
> При тестировании отдельного контроллера это приводит к тому, что помимо обязательных макетов для тестирования данного
> контроллера будет необходимо ещё внедрить макеты других компонентов, необходимых для создания bean-компонентов
> классов, находящихся в указанном для _Spring_ пакете.
>
> Также в случае возникновения этих ошибок можно воспользоваться аннотацией `@TestConfiguration` и создать
> конфигурационный анонимный класс, в котором указать конкретные реализации интерфейсов при помощи аннотации `@Bean` с
> указанием названий этих bean-компонентов.

Тестирование _API_ контроллеров с помощью _WebMvcTest_ производится в следующем порядке:

- подготовительный этап - в каждом из тестовых методов сначала подготавливаются данные запроса и приводятся в форму,
  необходимую для отправки в качестве тела запроса;
- тестирование - проведение теста посредством использования методов `perform()` и `andExpect()` класса _WebMvcTest_ и
  подготовленных тестовых данных.

> [[_Пример использования 1_]](/conspect/example_9.md/#пример-2)  
> [[_Пример использования 2_]](/conspect/example_9.md/#пример-3)

