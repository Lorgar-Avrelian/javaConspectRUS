# 9 Работа с файлами

> [[_оглавление_]](../README.md/#9-работа-с-файлами)

Работа с фалами в Java основана на использовании потоков данных и обработке тех данных, которые содержатся в этих
потоках.

## 9.1 Потоки данных

> [[_оглавление_]](../README.md/#91-потоки-данных)

[**Поток данных**](/conspect/definitions.md/#п) - это упорядоченная последовательность данных, которой соответствует
определенный источник (_source_) (для потоков ввода) или получатель (_destination_) (для потоков вывода).  
В Java потоки ввода-вывода реализуются в пределах иерархии классов, Определенных в пакете `java.io`.

Классификация потоков данных:

- по характеру чтения:
    * _входные_ - для чтения файлов;
    * _выходные_ - для записи файлов;
- по типу данных:
    * _байтовые_ - данные передаются в виде байтов;
    * _символьные_ - данные передаются в виде символов;
- по типу буферизации:
    * _побитовые_ (_посимвольные_) - передача данных происходит по биту или символу;
    * _буферизированные_ - передача данных происходит пакетами битов или символов.

### 9.1.1 Классы для работы с потоками данных

> [[_оглавление_]](../README.md/#91-потоки-данных)

|                          |   **_Чтение байт_**    |    **_Запись байт_**    | **_Чтение символов_** | **_Запись символов_** |
|:------------------------:|:----------------------:|:-----------------------:|:---------------------:|:---------------------:|
|    **_Общий класс_**     |     _InputStream_      |     _OutputStream_      |       _Reader_        |       _Writer_        |
|  **_Работа с файлами_**  |   _FileInputStream_    |   _FileOutputStream_    |     _FileReader_      |     _FileWriter_      |
|  **_Буферизированные_**  | _BufferedInputStream_  | _BufferedOutputStream_  |   _BufferedReader_    |   _BufferedWriter_    |
| **_Работа с массивами_** | _ByteArrayInputStream_ | _ByteArrayOutputStream_ |   _CharArrayReader_   |   _CharArrayWriter_   |

При работе с файлами, фактически, понятие "входной поток" является синонимом понятия "исходный файл", а "выходной
поток" - "загруженный файл".

Классы _ByteArrayInputStream_ и _ByteArrayOutputStream_ используют байтовый массив в качестве источника данных.

Классы _FileInputStream_ и _FileOutputStream_ - абстрактный классы, предоставляющие интерфейс для классов-надстроек,
которые добавляют к существующим потокам полезные свойства.

Классы _BufferedInputStream_ и _BufferedOutputStream_ служат для организации более эффективного «буферизированного»
ввода/вывода данных. Буферизация ввода/вывода является удобным способом оптимизации производительности, который
позволяет заключить в оболочку любой поток класса _InputStream_.

#### 9.1.1.1 Абстрактный класс InputStream

> [[_оглавление_]](../README.md/#91-потоки-данных)

Абстрактный класс _InputStream_ является базовым для всех классов, управляющих байтовыми потоками ввода.  
Он имеет ряд реализованных методов по работе с файлами, реализуемых всеми потомками.

##### 9.1.1.1.1 available()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `available()` потомков абстрактного класса `InputStream` возвращают количество байтов, доступных для чтения в
потоке.

Синтаксис метода в классе `InputStream` выглядит следующим образом:

```java
public int available() throws IOException {
    return 0;
}
```

Данный метод возвращает количество доступных для чтения байт.

##### 9.1.1.1.2 close()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `close()` потомков абстрактного класса `InputStream` принудительно закрывают поток.

Синтаксис метода в классе `InputStream` выглядит следующим образом:

```java
public void close() throws IOException {
}
```

##### 9.1.1.1.3 read()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `read()` потомков абстрактного класса `InputStream` возвращают целочисленное представление следующего байта в
потоке.

Синтаксис метода в классе `InputStream` выглядит следующим образом:

- считывает следующий байт данных из входного потока:

```java
public abstract int read() throws IOException;
```

> Значение байта данных возвращается в целочисленном виде в диапазоне от 0 до 255.  
> Если ни один байт не доступен, поскольку достигнут конец потока, возвращается значение `-1`.  
> Этот метод блокируется до тех пор, пока не будут доступны входные данные, не будет обнаружен конец потока или не будет
> выдано исключение.

- считывает некоторое количество байт из входного потока и сохраняет их в буферном массиве `b`:

```java
public int read(byte[] b) throws IOException {
    return read(b, 0, b.length);
}
```

> Количество фактически прочитанных байт возвращается в виде целого числа.  
> Этот метод блокируется до тех пор, пока не будут доступны входные данные, обнаружен конец файла или не будет выдано
> исключение.  
> Если длина массива `b` равна нулю, то никакие байты не считываются и возвращается значение `0`; в противном случае
> происходит попытка считывания хотя бы одного байта. Если ни один байт не доступен, поскольку поток находится в конце
> файла, возвращается значение `-1`; в противном случае по крайней мере один байт считывается и сохраняется в `b`.

- считывает до `len` байт данных из входного потока в массив байт:

```java
public int read(byte[] b, int off, int len) throws IOException {
    Objects.checkFromIndexSize(off, len, b.length);
    if (len == 0) {
        return 0;
    }
    int c = read();
    if (c == -1) {
        return -1;
    }
    b[off] = (byte) c;
    int i = 1;
    try {
        for (; i < len; i++) {
            c = read();
            if (c == -1) {
                break;
            }
            b[off + i] = (byte) c;
        }
    } catch (IOException ee) {
    }
    return i;
}
```

> Выполняется попытка считывания до `len` байт, но может быть прочитано и меньшее количество. Фактически считанное
> количество байт возвращается в виде целого числа.  
> Этот метод блокируется до тех пор, пока не будут доступны входные данные, не будет обнаружен конец файла или не будет
> выдано исключение.  
> Если значение `len` равно нулю, то байты не считываются и возвращается значение `0`; в противном случае происходит
> попытка считывания хотя бы одного байта. Если ни один байт не доступен, поскольку поток находится в конце файла,
> возвращается значение `-1`; в противном случае по крайней мере один байт считывается и сохраняется в `b`.

Данный метод возвращает общее количество считанных байт или `-1`, если данных больше нет, так как достигнут конец
потока.

##### 9.1.1.1.4 skip()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `skip()` потомков абстрактного класса `InputStream` пропускают в потоке при чтении некоторое количество байт.

Синтаксис метода в классе `InputStream` выглядит следующим образом:

```java
public long skip(long n) throws IOException {
    long remaining = n;
    int nr;
    if (n <= 0) {
        return 0;
    }
    int size = (int) Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
    byte[] skipBuffer = new byte[size];
    while (remaining > 0) {
        nr = read(skipBuffer, 0, (int) Math.min(size, remaining));
        if (nr < 0) {
            break;
        }
        remaining -= nr;
    }
    return n - remaining;
}
```

Данный метод возвращает фактическое количество пропущенных байт, которое может быть равно нулю.

##### 9.1.1.1.5 transferTo()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `transferTo()` потомков абстрактного класса `InputStream` считывают все байты из входного потока и записывает их
в данный выходной поток в порядке следования.

Синтаксис метода в классе `InputStream` выглядит следующим образом:

```java
public long transferTo(OutputStream out) throws IOException {
    Objects.requireNonNull(out, "out");
    long transferred = 0;
    byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
    int read;
    while ((read = this.read(buffer, 0, DEFAULT_BUFFER_SIZE)) >= 0) {
        out.write(buffer, 0, read);
        if (transferred < Long.MAX_VALUE) {
            try {
                transferred = Math.addExact(transferred, read);
            } catch (ArithmeticException ignore) {
                transferred = Long.MAX_VALUE;
            }
        }
    }
    return transferred;
}
```

Данный метод возвращает количество переданных байт.

#### 9.1.1.2 Абстрактный класс OutputStream

> [[_оглавление_]](../README.md/#91-потоки-данных)

Абстрактный класс _OutputStream_ является базовым для всех классов, которые работают с бинарными потоками записи.  
Он имеет ряд реализованных методов по работе с файлами, реализуемых всеми потомками.

##### 9.1.1.2.1 close()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `close()` потомков абстрактного класса `OutputStream` принудительно закрывают поток.

Синтаксис метода в классе `OutputStream` выглядит следующим образом:

```java
public void close() throws IOException {
}
```

##### 9.1.1.2.2 flush()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `flush()` потомков абстрактного класса `OutputStream` очищают выходной поток и принудительно записывают все
буферизованные выходные байты.

Синтаксис метода в классе `OutputStream` выглядит следующим образом:

```java
public void flush() throws IOException {
}
```

Общий принцип функции _flush_ заключается в том, что ее вызов указывает на то, что, если какие-либо ранее записанные
байты были буферизованы реализацией выходного потока, такие байты должны быть немедленно записаны по назначению.

##### 9.1.1.2.3 write()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `write()` потомков абстрактного класса `OutputStream` записывают в выходной поток некоторое число байтов.

Синтаксис метода в классе `OutputStream` выглядит следующим образом:

- записывает указанный байт в этот выходной поток:

```java
public abstract void write(int b) throws IOException;
```

Общее условие записи заключается в том, что в выходной поток записывается один байт. Записываемый байт - это восемь
младших разрядов аргумента `b`. 24 старших разряда аргумента `b` игнорируются.

- записывает байты длины `b` из указанного массива байт в этот выходной поток:

```java
public void write(byte[] b) throws IOException {
    write(b, 0, b.length);
}
```

Общее условие для метода `write(b)` заключается в том, что он должен иметь точно такой же эффект, как и вызов
метод `write(b, 0, b. length)`.

- записывает `len` байтов из указанного массива байтов, начиная со смещения _off_, в этот выходной поток:

```java
public void write(byte[] b, int off, int len) throws IOException {
    Objects.checkFromIndexSize(off, len, b.length);
    // len == 0 condition implicitly handled by loop bounds
    for (int i = 0; i < len; i++) {
        write(b[off + i]);
    }
}
```

Общее условие для записи `(b, off, len)` заключается в том, что некоторые байты из массива `b` записываются в выходной
поток по порядку; элемент `b[off]` - это первый записанный байт, а `b[off+len-1]` - последний записанный байт в
результате этой операции.  
Если `b` равно `null`, то генерируется исключение _NullPointerException_.

#### 9.1.1.3 Абстрактный класс Reader

> [[_оглавление_]](../README.md/#91-потоки-данных)

Абстрактный класс _Reader_ предоставляет функционал для чтения текстовой информации.  
Он имеет ряд реализованных методов по работе с файлами, реализуемых всеми потомками.

##### 9.1.1.3.1 close()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `close()` потомков абстрактного класса `Reader` принудительно закрывают поток.

Синтаксис метода в классе `Reader` выглядит следующим образом:

```java
public abstract void close() throws IOException;
```

##### 9.1.1.3.2 read()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `read()` потомков абстрактного класса `Reader` возвращают целочисленное представление следующего символа в
потоке.

Синтаксис метода в классе `Reader` выглядит следующим образом:

- возвращает целочисленное представление следующего символа в потоке:

```java
public int read() throws IOException {
    char[] cb = new char[1];
    if (read(cb, 0, 1) == -1)
        return -1;
    else
        return cb[0];
}
```

- считывает в массив `cbuf` из потока символы, количество которых равно длине массива `cbuf`, и возвращает количество
  успешно считанных символов:

```java
public int read(char[] cbuf) throws IOException {
    return read(cbuf, 0, cbuf.length);
}
```

- считывает в объект _target_ из потока символы и возвращает количество успешно считанных символов:

```java
public int read(CharBuffer target) throws IOException {
    if (target.isReadOnly())
        throw new ReadOnlyBufferException();
    int nread;
    if (target.hasArray()) {
        char[] cbuf = target.array();
        int pos = target.position();
        int rem = Math.max(target.limit() - pos, 0);
        int off = target.arrayOffset() + pos;
        nread = this.read(cbuf, off, rem);
        if (nread > 0)
            target.position(pos + nread);
    } else {
        int len = target.remaining();
        char[] cbuf = new char[len];
        nread = read(cbuf, 0, len);
        if (nread > 0)
            target.put(cbuf, 0, nread);
    }
    return nread;
}
```

- считывает в массив _cbuf_, начиная со смещения `off`, из потока символы, количество которых равно `len`:

```java
public abstract int read(char[] cbuf, int off, int len) throws IOException;
```

Данный метод при достижении конца файла возвращает `-1`.

##### 9.1.1.3.3 skip()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `skip()` потомков абстрактного класса `Reader` пропускают некоторое количество символов.

Синтаксис метода в классе `Reader` выглядит следующим образом:

```java
public long skip(long n) throws IOException {
    if (n < 0L)
        throw new IllegalArgumentException("skip value is negative");
    Object lock = this.lock;
    if (lock instanceof InternalLock locker) {
        locker.lock();
        try {
            return implSkip(n);
        } finally {
            locker.unlock();
        }
    } else {
        synchronized (lock) {
            return implSkip(n);
        }
    }
}
```

Данный метод возвращает количество пропущенных символов.

##### 9.1.1.3.4 transferTo()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `transferTo()` потомков абстрактного класса `Reader` считывают все символы из этого потока и записывают их
в данный выходной поток в порядке следования.

Синтаксис метода в классе `Reader` выглядит следующим образом:

```java
public long transferTo(Writer out) throws IOException {
    Objects.requireNonNull(out, "out");
    long transferred = 0;
    char[] buffer = new char[TRANSFER_BUFFER_SIZE];
    int nRead;
    while ((nRead = read(buffer, 0, TRANSFER_BUFFER_SIZE)) >= 0) {
        out.write(buffer, 0, nRead);
        if (transferred < Long.MAX_VALUE) {
            try {
                transferred = Math.addExact(transferred, nRead);
            } catch (ArithmeticException ignore) {
                transferred = Long.MAX_VALUE;
            }
        }
    }
    return transferred;
}
```

Данный метод возвращает количество переданных символов.

#### 9.1.1.4 Абстрактный класс Writer

> [[_оглавление_]](../README.md/#91-потоки-данных)

Абстрактный класс _Writer_ определяет функционал для всех символьных потоков вывода.  
Он имеет ряд реализованных методов по работе с файлами, реализуемых всеми потомками.

##### 9.1.1.4.1 close()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `close()` потомков абстрактного класса `Writer` принудительно закрывают поток.

Синтаксис метода в классе `Writer` выглядит следующим образом:

```java
public abstract void close() throws IOException;
```

##### 9.1.1.4.2 append()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `append()` потомков абстрактного класса `Writer` добавляют в конец выходного потока символы.

Синтаксис метода в классе `Writer` выглядит следующим образом:

- добавляет в конец выходного потока символ `c`:

```java
public Writer append(char c) throws IOException {
    write(c);
    return this;
}
```

- добавляет в конец выходного потока набор символов `csq`:

```java
public Writer append(CharSequence csq) throws IOException {
    write(String.valueOf(csq));
    return this;
}
```

Данный метод возвращает объект типа _Writer_.

##### 9.1.1.4.3 flush()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `flush()` потомков абстрактного класса `Writer` очищают выходной поток.

Синтаксис метода в классе `Writer` выглядит следующим образом:

```java
public abstract void flush() throws IOException;
```

Если поток сохранил какие-либо символы из различных методов `write()` в буфере, то они немедленно запишутся в место
назначения. Затем, если это место назначения - другой поток символов или байтов, то он будет очищен. Таким образом, один
вызов `flush()` очистит все буферы в цепочке записывающих и выходных потоков.

##### 9.1.1.4.4 write()

> [[_оглавление_]](../README.md/#91-потоки-данных)

Методы `write()` потомков абстрактного класса `Writer` записывает в выходной поток символы.

Синтаксис метода в классе `Writer` выглядит следующим образом:

- записывает в поток один символ, который имеет целочисленное представление:

```java
public void write(int c) throws IOException {
    Object lock = this.lock;
    if (lock instanceof InternalLock locker) {
        locker.lock();
        try {
            implWrite(c);
        } finally {
            locker.unlock();
        }
    } else {
        synchronized (lock) {
            implWrite(c);
        }
    }
}
```

- записывает в поток массив символов:

```java
public void write(char[] cbuf) throws IOException {
    write(cbuf, 0, cbuf.length);
}
```

- записывает в поток только несколько символов из массива _cbuf_ (причём количество символов равно `len`, а отбор
  символов из массива начинается с индекса `off`):

```java
public abstract void write(char[] cbuf, int off, int len) throws IOException;
```

- записывает в поток строку:

```java
public void write(String str) throws IOException {
    write(str, 0, str.length());
}
```

- записывает в поток из строки некоторое количество символов (причём количество символов равно `len`, а отбор символов
  из массива начинается с индекса `off`):

```java
public void write(String str, int off, int len) throws IOException {
    Object lock = this.lock;
    if (lock instanceof InternalLock locker) {
        locker.lock();
        try {
            implWrite(str, off, len);
        } finally {
            locker.unlock();
        }
    } else {
        synchronized (lock) {
            implWrite(str, off, len);
        }
    }
}
```



