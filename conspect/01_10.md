## 1.10 Принципы написания кода

<a href="../README.md/#110-принципы-написания-кода">[_оглавление_]</a>

> [[_оглавление_]](../README.md/#110-принципы-написания-кода)

### 1.10.1 SOLID

> [[_оглавление_]](../README.md/#110-принципы-написания-кода)

[**SOLID**](/conspect/definitions.md/#s) - это принципы разработки программного обеспечения, предназначенные для
написания масштабируемого и поддерживаемого кода.

Принципы _SOLID_:

- _**S**ingle Responsibility Principle_ (Принцип единственной ответственности);

> **Делай модули меньше!**
>
> _Принцип гласит:_ **Никогда не должно быть больше одной причины изменить класс.**
>
> На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на
> обеспечение этой обязанности.  
> Такие классы всегда будет просто изменять, если это понадобится, потому что понятно, за что класс отвечает, а за что -
> нет. То есть можно будет вносить изменения и не бояться последствий - влияния на другие объекты. А еще подобный код
> гораздо проще тестировать, ведь тестами покрывается одна функциональность в изоляции от всех остальных.
>
> _Каждый класс должен иметь только одну зону ответственности._

- _**O**pen Closed Principle_ (Принцип открытости/закрытости);

> **Делай модули расширяемыми!**
>
> _Принцип гласит:_ **Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но
закрыты для изменения.**
>
> Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам
> класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения
> было достаточно расширить его и переопределить некоторые функции.  
> Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода.
>
> _Классы должны быть открыты для расширения, но закрыты для изменения._

- _**L**iskov’s Substitution Principle_ (Принцип подстановки Барбары Лисков);

> **Наследуйся правильно!**
>
> _Принцип гласит:_ **Объекты в программе можно заменить их наследниками без изменения свойств программы.**
>
> Это означает, что класс, разработанный путём расширения на основании базового класса, должен переопределять его методы
> так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет класс и
> использует
> его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.  
> Подклассы должны переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения
> клиента. То есть они не должны возвращать те типы или выбрасывать исключения, не предусмотренные родительским классом.
>
> _Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник),
при этом работа программы не должна измениться._

- _**I**nterface Segregation Principle_ (Принцип разделения интерфейса);

> **Дроби интерфейсы!**
>
> _Принцип гласит:_ **Клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.**
>
> Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и
> специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении
> метода интерфейса не должны меняться клиенты, которые этот метод не используют.  
> То есть интерфейс должен содержать только необходимые всем без исключения реализациям методы.
>
> _Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему
отношения._

- _**D**ependency Inversion Principle_ (Принцип инверсии зависимостей).

> **Используй интерфейсы!**
>
> _Принцип гласит:_ **Зависимости внутри системы строятся на основе абстракций.**
>
> Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с
> помощью абстракции.  
> Классическое применение этого принципа - _Spring framework_. В рамках _Spring framework_ все модули выполнены в виде
> отдельных компонентов, которые могут работать вместе. Они настолько автономны, что могут быть с такой же лёгкостью
> задействованы в других программных модулях помимо _Spring framework_.
>
> _Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций._

### 1.10.2 DRY

> [[_оглавление_]](../README.md/#110-принципы-написания-кода)

[**DRY (Don’t repeat yourself)**](/conspect/definitions.md/#d) - это принцип, который означает, что программист должен
избегать повторов в реализации кода и в логике работы, а вместо этого использовать то, что есть.

Соблюдение принципа достигается:

- дроблением проекта на более мелкие составляющие - классы;
- построением логики на базе представлений - интерфейсов;
- планированием построения логики - составлением логических блок-схем.

### 1.10.3 KISS

> [[_оглавление_]](../README.md/#110-принципы-написания-кода)

[**KISS (Keep it simple stupid)**](/conspect/definitions.md/#k) - это принцип, который означает, что простота кода
превыше всего.

Соблюдение принципа достигается:

- построением оптимальных алгоритмов;
- правильным применением паттернов проектирования.

### 1.10.4 YAGNI

> [[_оглавление_]](../README.md/#110-принципы-написания-кода)

[**YAGNI (You ain’t gonna need it)**](/conspect/definitions.md/#y) - это принцип, означающий, что не нужно писать код,
который может быть пригодится в будущем, а нужно писать код, который нужен сейчас.

Соблюдение принципа достигается:

- уменьшением сложности путём уменьшения уровня абстракции;
- разделением функционала и возможностей (features);
- учётом нефункциональных требований;
- определением затратных по времени задач.