# 3 Spring Framework

> [[_оглавление_]](../README.md/#3-spring-framework)

[**Фреймворк**](/conspect/definitions.md/#ф) - это программная платформа, определяющая структуру программной системы;
программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.  
Фреймворк является сопрограммой, которая работает одновременно с Java-приложением и предоставляет пустые «звенья»,
которые необходимо написать, встраивая их в общую схему работы фреймворка. В определенный момент фреймворк вызовет эти
звенья сам.

Фреймворк по своей структуре похож на библиотеку: он состоит из пакетов, каждый из которых состоит из классов, имеющих
определённые методы. От библиотеки его отличает то, что момент создания и порядок использования объектов и методов
библиотеки задаются программистом при написании кода, а в случае использования фреймворка - момент создания и порядок
использования объектов и методов определяет сам фреймворк. Как правило, классы и методы, написанные программистом,
должны имплементировать какие-либо интерфейсы фреймворка или наследовать какие-либо классы из него, таким образом
получая часть уже написанной (и заложенной во фреймворк) функциональности.

> При написании приложения с использованием библиотек всю логику работы приложения определяет программист. При написании
> приложения с использованием фреймворка программист настраивает логику, заложенную во фреймворк и определённую в нём, и
> пишет отдельные модули для этой самой логики.

Основная идея, которая лежит в базовом модуле _Spring Context_, заключается в реализации архитектурных шаблонов **IoC (
Inversion of Control)** и **DI (Dependency injection)**.

_IoC_ — инверсия контроля. Этот принцип подразумевает, что мы передаем некой сущности ответственность за создание
объектов и контроль над ними, то есть хранение.  
В случае _Spring_ мы размечаем классы с помощью определенных флагов, а уже сам _Spring_ создает (по этим флагам) объекты
и кладет их в свой контекст, который представляет собой коллекцию объектов.

_DI_ — инъекция зависимостей. Данный принцип подразумевает, что мы не хотим в нашем классе заниматься созданием
инфраструктурных объектов.  
Мы хотим просто получить его «из воздуха» и работать с ними, а логику по созданию и подаче их в наш класс доверим
_Spring_, который и проведет подачу зависимостей из своего контекста в конструктор нашего класса.

_Spring_ состоит из множества узконаправленных модулей.

![8.jpg](/pictures/8.jpg)

> [**Ссылка**](https://start.spring.io/) на _Spring Initializr_ для создания проекта через браузер.

_Spring Framework_ предоставляет комплексную модель программирования и конфигурации для современных корпоративных
приложений на основе Java — на любой платформе развертывания. Ключевым элементом _Spring_ является инфраструктурная
поддержка на уровне приложения: _Spring_ фокусируется на «проводке» корпоративных приложений, чтобы команды могли
сосредоточиться на бизнес-логике уровня приложения без ненужных привязок к конкретным средам развертывания.

> [**Ссылка**](https://spring.io/projects/spring-framework#overview) на официальную справочную документацию по _Spring
Framework_.

Основные функции, заложенные в _Spring Framework_:

- основные технологии: внедрение зависимостей, события, ресурсы, i18n, проверка, привязка данных, преобразование типов,
  SpEL, AOP;
- тестирование: mock-объекты, фреймворк TestContext, Spring MVC Test, WebTestClient;
- доступ к данным: транзакции, поддержка DAO, JDBC, ORM, Marshalling XML;
- вэб-фреймворки Spring MVC и Spring WebFlux;
- интеграция: удалённое взаимодействие, JMS, JCA, JMX, email, задачи, планирование, кэширование и наблюдаемость;
- языки: Kotlin, Groovy, динамические языки.

## 3.1 Основные технологии

> [[_оглавление_]](../README.md/#31-основные-технологии)

### 3.1.1 Inversion of Control

> [[_оглавление_]](../README.md/#31-основные-технологии)

Главной технологией _Spring Framework_ является контейнер _Inversion of Control (IoC)_.  
[**Inversion of Control (Инверсия управления)**](/conspect/definitions.md/#i) - это абстрактный принцип, согласно
которого каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на
детали конкретной реализации других компонентов.  
Одной из реализаций этого принципа является _Dependency injection (DI)_.  
[**Dependency injection (Внедрение зависимостей)**](/conspect/definitions.md/#d) - это специализированная форма
[_IoC_](/conspect/definitions.md/#i), в которой объекты определяют свои зависимости только через аргументы конструктора,
аргументы фабричного метода или свойства, которые устанавливаются для экземпляра объекта после его создания или возврата
из фабричного метода.  
[**Зависимость**](/conspect/definitions.md/#з) - это другой объект, с которым работает данный объект или который
используется при его работе.  
[**Контейнер IoC**](/conspect/definitions.md/#к) - это программа, которая внедряет зависимости при создании
компонента.  
Процесс по сути является обратным (отсюда и название — _Inversion of Control_) самому компоненту, контролирующему
создание экземпляра или определяющему зависимости экземпляра с помощью прямого построения классов или механизма, такого
как шаблон _Service Locator_ (скрывает зависимости данного класса).

Основой контейнера _IoC Spring Framework_ являются:

- пакет `org.springframework.beans` (Spring Beans);
- пакет `org.springframework.context` (Spring Context).

#### 3.1.1.1 Интерфейс BeanFactory

> [[_оглавление_]](../README.md/#31-основные-технологии)

Интерфейс _BeanFactory_ - это корневой интерфейс для доступа к контейнеру bean-компонентов _Spring_.

[**Бин (bean)**](/conspect/definitions.md/#b) - это объект, который управляется _Spring_ и существует внутри его _DI_
-контейнера.  
Любое приложение _Spring_ - это набор бинов, связанных вместе через _DI_-контейнер.

Этот интерфейс реализуется объектами, которые содержат ряд определений bean-компонентов, каждое из которых однозначно
идентифицируется строковым именем типа `String`. В зависимости от определения bean-компонента фабрика вернет либо
независимый экземпляр содержащегося объекта (шаблон _Prototype_), либо один общий экземпляр (альтернатива шаблону
_Singleton_, в котором экземпляр является singleton в области действия фабрики). Какой тип экземпляра будет возвращен,
зависит от конфигурации фабрики bean-компонентов.  
_BeanFactory_ является центральным реестром компонентов приложения и централизует настройку его компонентов.

_BeanFactory_ загружает определения bean-компонентов, хранящиеся в источнике конфигурации и использует
пакет `org.springframework.beans` для настройки bean-компонентов. Реализация может просто возвращать объекты Java,
которые она создает по мере необходимости непосредственно в Java-коде. Рекомендуется, чтобы реализации поддерживали
ссылки между компонентами (_Dependency Injection_).

Реализации интерфейса _BeanFactory_ переопределяют реализации бинов родительской фабрики, имеющих такое же имя. В
случае, если в текущем экземпляре реализации бин с нужным именем не найден, то будет осуществлён поиск в родительской
реализации, и если будет найден, то применён он.

Реализации _BeanFactory_ должны поддерживать стандартные интерфейсы жизненного цикла бинов, насколько это возможно.

Полный перечень методов инициализации бина в их стандартном порядке:

- BeanNameAware `setBeanName()`;
- BeanClassLoaderAware `setBeanClassLoader()`;
- BeanFactoryAware `setBeanFactory()`;
- EnvironmentAware `setEnvironment()`;
- EmbeddedValueResolverAware `setEmbeddedValueResolver()`;
- ResourceLoaderAware `setResourceLoader()` (применимо только при запуске в контексте приложения);
- ApplicationEventPublisherAware `setApplicationEventPublisher()` (применимо только при запуске в контексте приложения);
- MessageSourceAware `setMessageSource()` (применимо только при запуске в контексте приложения);
- ApplicationContextAware `setApplicationContext()` (применимо только при запуске в контексте приложения);
- ServletContextAware `setServletContext()` (применимо только при запуске в контексте приложения);
- `postProcessBeforeInitialization` методы BeanPostProcessors;
- InitializingBean `afterPropertiesSet()`;
- пользовательское определение метода инициализации;
- `postProcessAfterInitialization` методы BeanPostProcessors.

При завершении работы _BeanFactory_ применяются следующие методы жизненного цикла бина:

- `postProcessBeforeDestruction` методы DestructionAwareBeanPostProcessors;
- DisposableBean `destroy()`;
- пользовательское определение метода уничтожения.

#### 3.1.1.2 Интерфейс ApplicationContext

> [[_оглавление_]](../README.md/#31-основные-технологии)

Центральный интерфейс для предоставления конфигурации приложения. Он доступен только для чтения, пока приложение
запущено, но может быть перезагружен, если реализация поддерживает это.

_ApplicationContext_ представляет собой само приложение _Spring_. Так же контекст предоставляет возможности реагировать
на различные события, которые происходят внутри приложения, управлять жизненным циклом бинов.

_ApplicationContext_ обеспечивает:

- методы _BeanFactory_ для доступа к компонентам приложения (унаследовано от ListableBeanFactory);
- возможность загрузки файловых ресурсов в общем виде (унаследовано от интерфейса ResourceLoader);
- возможность публиковать события для зарегистрированных слушателей (унаследовано от
  ApplicationEventPublisherинтерфейса);
- возможность разрешать сообщения, поддерживающие интернационализацию (унаследовано от MessageSourceинтерфейса);
- наследование от родительского контекста.

Определения в дочернем контексте всегда будут иметь приоритет. Это означает, например, что один родительский контекст
может использоваться всем web-приложением, в то время как каждый сервлет имеет свой собственный дочерний контекст,
который независим от контекста любого другого сервлета.

