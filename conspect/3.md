# 3 Spring Framework

> [[_оглавление_]](../README.md/#3-spring-framework)

[**Фреймворк**](/conspect/definitions.md/#ф) - это программная платформа, определяющая структуру программной системы;
программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.  
Фреймворк является сопрограммой, которая работает одновременно с Java-приложением и предоставляет пустые «звенья»,
которые необходимо написать, встраивая их в общую схему работы фреймворка. В определенный момент фреймворк вызовет эти
звенья сам.

Фреймворк по своей структуре похож на библиотеку: он состоит из пакетов, каждый из которых состоит из классов, имеющих
определённые методы. От библиотеки его отличает то, что момент создания и порядок использования объектов и методов
библиотеки задаются программистом при написании кода, а в случае использования фреймворка - момент создания и порядок
использования объектов и методов определяет сам фреймворк. Как правило, классы и методы, написанные программистом,
должны имплементировать какие-либо интерфейсы фреймворка или наследовать какие-либо классы из него, таким образом
получая часть уже написанной (и заложенной во фреймворк) функциональности.

> При написании приложения с использованием библиотек всю логику работы приложения определяет программист. При написании
> приложения с использованием фреймворка программист настраивает логику, заложенную во фреймворк и определённую в нём, и
> пишет отдельные модули для этой самой логики.

Основная идея, которая лежит в базовом модуле _Spring Context_, заключается в реализации архитектурных шаблонов **IoC (
Inversion of Control)** и **DI (Dependency injection)**.

_IoC_ — инверсия контроля. Этот принцип подразумевает, что мы передаем некой сущности ответственность за создание
объектов и контроль над ними, то есть хранение.  
В случае _Spring_ мы размечаем классы с помощью определенных флагов, а уже сам _Spring_ создает (по этим флагам) объекты
и кладет их в свой контекст, который представляет собой коллекцию объектов.

_DI_ — инъекция зависимостей. Данный принцип подразумевает, что мы не хотим в нашем классе заниматься созданием
инфраструктурных объектов.  
Мы хотим просто получить его «из воздуха» и работать с ними, а логику по созданию и подаче их в наш класс доверим
_Spring_, который и проведет подачу зависимостей из своего контекста в конструктор нашего класса.

_Spring_ состоит из множества узконаправленных модулей.

![8.jpg](/pictures/8.jpg)

> [**Ссылка**](https://start.spring.io/) на _Spring Initializr_ для создания проекта через браузер.

_Spring Framework_ предоставляет комплексную модель программирования и конфигурации для современных корпоративных
приложений на основе Java — на любой платформе развертывания. Ключевым элементом _Spring_ является инфраструктурная
поддержка на уровне приложения: _Spring_ фокусируется на «проводке» корпоративных приложений, чтобы команды могли
сосредоточиться на бизнес-логике уровня приложения без ненужных привязок к конкретным средам развертывания.

> [**Ссылка**](https://spring.io/projects/spring-framework#overview) на официальную справочную документацию по _Spring
Framework_.

Основные функции, заложенные в _Spring Framework_:

- основные технологии: внедрение зависимостей, события, ресурсы, i18n, проверка, привязка данных, преобразование типов,
  SpEL, AOP;
- тестирование: mock-объекты, фреймворк TestContext, Spring MVC Test, WebTestClient;
- доступ к данным: транзакции, поддержка DAO, JDBC, ORM, Marshalling XML;
- вэб-фреймворки Spring MVC и Spring WebFlux;
- интеграция: удалённое взаимодействие, JMS, JCA, JMX, email, задачи, планирование, кэширование и наблюдаемость;
- языки: Kotlin, Groovy, динамические языки.

## 3.1 Основные технологии

> [[_оглавление_]](../README.md/#31-основные-технологии)

### 3.1.1 Inversion of Control

> [[_оглавление_]](../README.md/#31-основные-технологии)

Главной технологией _Spring Framework_ является контейнер _Inversion of Control (IoC)_.  
[**Inversion of Control (Инверсия управления)**](/conspect/definitions.md/#i) - это абстрактный принцип, согласно
которого каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на
детали конкретной реализации других компонентов.  
Одной из реализаций этого принципа является _Dependency injection (DI)_.  
[**Dependency injection (Внедрение зависимостей)**](/conspect/definitions.md/#d) - это специализированная форма
[_IoC_](/conspect/definitions.md/#i), в которой объекты определяют свои зависимости только через аргументы конструктора,
аргументы фабричного метода или свойства, которые устанавливаются для экземпляра объекта после его создания или возврата
из фабричного метода.  
[**Зависимость**](/conspect/definitions.md/#з) - это другой объект, с которым работает данный объект или который
используется при его работе.  
[**Контейнер IoC**](/conspect/definitions.md/#к) - это программа, которая внедряет зависимости при создании
компонента.  
Процесс по сути является обратным (отсюда и название — _Inversion of Control_) самому компоненту, контролирующему
создание экземпляра или определяющему зависимости экземпляра с помощью прямого построения классов или механизма, такого
как шаблон _Service Locator_ (скрывает зависимости данного класса).

Основой контейнера _IoC Spring Framework_ являются:

- пакет `org.springframework.beans` (Spring Beans);
- пакет `org.springframework.context` (Spring Context).

#### 3.1.1.1 Интерфейс BeanFactory

> [[_оглавление_]](../README.md/#31-основные-технологии)

Интерфейс _BeanFactory_ - это корневой интерфейс для доступа к контейнеру bean-компонентов _Spring_.

[**Бин (bean)**](/conspect/definitions.md/#b) - это объект, который создается, собирается и управляется контейнером
_Spring IoC_.  
Любое приложение _Spring_ - это набор бинов, связанных вместе через _DI_-контейнер.  
Bean-компоненты и зависимости между ними отражаются в метаданных конфигурации, используемых контейнером _Spring IoC_.

Этот интерфейс реализуется объектами, которые содержат ряд определений bean-компонентов, каждое из которых однозначно
идентифицируется строковым именем типа `String`. В зависимости от определения bean-компонента фабрика вернет либо
независимый экземпляр содержащегося объекта (шаблон _Prototype_), либо один общий экземпляр (альтернатива шаблону
_Singleton_, в котором экземпляр является singleton в области действия фабрики). Какой тип экземпляра будет возвращен,
зависит от конфигурации фабрики bean-компонентов.  
_BeanFactory_ является центральным реестром компонентов приложения и централизует настройку его компонентов.

_BeanFactory_ загружает определения bean-компонентов, хранящиеся в источнике конфигурации и использует
пакет `org.springframework.beans` для настройки bean-компонентов. Реализация может просто возвращать объекты Java,
которые она создает по мере необходимости непосредственно в Java-коде. Рекомендуется, чтобы реализации поддерживали
ссылки между компонентами (_Dependency Injection_).

Реализации интерфейса _BeanFactory_ переопределяют реализации бинов родительской фабрики, имеющих такое же имя. В
случае, если в текущем экземпляре реализации бин с нужным именем не найден, то будет осуществлён поиск в родительской
реализации, и если будет найден, то применён он.

Реализации _BeanFactory_ должны поддерживать стандартные интерфейсы жизненного цикла бинов, насколько это возможно.

Полный перечень методов инициализации бина в их стандартном порядке:

- BeanNameAware `setBeanName()`;
- BeanClassLoaderAware `setBeanClassLoader()`;
- BeanFactoryAware `setBeanFactory()`;
- EnvironmentAware `setEnvironment()`;
- EmbeddedValueResolverAware `setEmbeddedValueResolver()`;
- ResourceLoaderAware `setResourceLoader()` (применимо только при запуске в контексте приложения);
- ApplicationEventPublisherAware `setApplicationEventPublisher()` (применимо только при запуске в контексте приложения);
- MessageSourceAware `setMessageSource()` (применимо только при запуске в контексте приложения);
- ApplicationContextAware `setApplicationContext()` (применимо только при запуске в контексте приложения);
- ServletContextAware `setServletContext()` (применимо только при запуске в контексте приложения);
- `postProcessBeforeInitialization` методы BeanPostProcessors;
- InitializingBean `afterPropertiesSet()`;
- пользовательское определение метода инициализации;
- `postProcessAfterInitialization` методы BeanPostProcessors.

При завершении работы _BeanFactory_ применяются следующие методы жизненного цикла бина:

- `postProcessBeforeDestruction` методы DestructionAwareBeanPostProcessors;
- DisposableBean `destroy()`;
- пользовательское определение метода уничтожения.

#### 3.1.1.2 Интерфейс ApplicationContext

> [[_оглавление_]](../README.md/#31-основные-технологии)

Интерфейс _ApplicationContext_ представляет контейнер _Spring IoC_ и отвечает за создание экземпляров, настройку и
сборку компонентов.  
Контейнер получает инструкции по компонентам для создания экземпляров, настройки и сборки, считывая метаданные
конфигурации. Метаданные конфигурации могут быть представлены в виде аннотированных классов компонентов, классов
конфигурации с фабричными методами или внешних XML-файлов или скриптов _Groovy_.

Несколько реализаций интерфейса _ApplicationContext_ являются частью ядра _Spring_. В автономных приложениях обычно
создают экземпляр _AnnotationConfigApplicationContext_ или _ClassPathXmlApplicationContext_.

![9.png](/pictures/9.png)

Классы приложения объединяются с метаданными конфигурации, так что после создания _ApplicationContext_ и инициализации
имеется полностью настроенная и исполняемая система или приложение.

Контейнер _Spring IoC_ потребляет форму метаданных конфигурации. Эти метаданные конфигурации представляют то, как
разработчик приложения, сообщаете контейнеру _Spring_ о необходимости создания экземпляров, настройки и сборки
компонентов в приложении.  
Сам контейнер _Spring IoC_ полностью независим от формата, в котором эти метаданные конфигурации фактически записаны.  
В Java для конфигурации приложения, как правило, используют аннотации `@Configuration`, `@Bean`, `@Import`
и `@DependsOn`.

Конфигурация _Spring_ состоит из одного или нескольких определений bean-компонентов, которыми должен управлять контейнер
_Spring IoC_. В Java обычно использует @Bean-аннотированные методы внутри @Configuration-класса, каждый из которых
соответствует одному заданию bean-компонента.

Например:

```java

@Configuration
class PaymentsServiceConfiguration {

    @Bean
    public PaymentProvider paymentProvider() {
        return new PayPalPaymentProvider();
    }

    @Bean
    public PaymentService paymentService(PaymentProvider paymentProvider) {
        return new PaymentService(paymentProvider);
    }

}
```

Эти определения bean-компонентов соответствуют фактическим объектам, которые входят в состав приложения.  
Обычно задаются следующие объекты:

- объекты уровня сервиса;
- объекты уровня сохранения (репозитории или объекты доступа к данным (DAO));
- объекты представления (web-контроллеры);
- объекты инфраструктуры (JPA EntityManagerFactory, очереди JMS и т.д.).

Как правило, никто не настраивает мелкие объекты домена в контейнере, поскольку обычно ответственность за создание и
загрузку объектов домена лежит на репозиториях и бизнес-логике.

