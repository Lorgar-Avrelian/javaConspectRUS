# 4 REST

> [[_оглавление_]](../README.md/#4-rest)

[**REST (Representational State Transfer)**](/conspect/definitions.md/#r) - это передача состояния представления;
архитектурный стиль взаимодействия (обмена данными) компонентов распределенной системы в компьютерной сети.

Данный архитектурный стиль представляет собой согласованный набор ограничений, учитываемых при проектировании
распределенной системы. Эти ограничения называют принципами _REST_ и их всего 6 штук.

[**_RESTful_-приложение**](/conspect/definitions.md/#r) - это приложение, построенное с учётом принципов _REST_.

Преимущества, которые дает _REST_:

- надёжность (не нужно сохранять информацию о состоянии клиента, которая может быть утеряна);
- производительность (за счёт использования кэша);
- масштабируемость;
- прозрачность системы взаимодействия;
- простота интерфейсов;
- портативность компонентов;
- лёгкость внесения изменений;
- способность эволюционировать, приспосабливаясь к новым требованиям.

## 4.1 Протоколы

> [[_оглавление_]](../README.md/#41-протоколы)

[**Протокол передачи данных**](/conspect/definitions.md/#п) - это общепринятое соглашение, благодаря которому
разработчики разных сервисов отправляют информацию в едином виде.

### 4.1.1 HTTP и HTTPS

> [[_оглавление_]](../README.md/#41-протоколы)

[**HTTP (HyperText Transfer Protocol)**](/conspect/definitions.md/#h) - это протокол передачи гипертекста; протокол
передачи данных прикладного уровня для распределённых, объединённых, гипермедийных информационных систем, в котором вся
информация передаётся в текстовом виде.

Структура _HTTP_:

- стартовая строка (_Starting line_) - определяет служебные данные;
- заголовки (_Headers_) - описание параметров сообщения;
- тело сообщения (_Body_) - данные сообщения (отделяются от заголовков пустой строкой).

Пример:

```http request
GET / HTTP/1.1
Host: javarush.com
User-Agent: firefox/5.0 (Linux; Debian 5.0.8; en-US; rv:1.8.1.7)
```

В данном примере:

- в стартовой строке указаны:
    * _GET_ - метод запроса;
    * _/_ - путь запроса (_path_);
    * _HTTP/1.1_ - версия протокола передачи данных;
- в заголовке указаны:
    * _Host_ - хост, которому адресован запрос;
    * _User-Agent_ - клиент (web-браузер), который отправляет запрос;
- тело сообщения отсутствует.

> В HTTP-запросе обязательны только стартовая строка и заголовок _Host_.

#### 4.1.1.1 HTTP-запрос

> [[_оглавление_]](../README.md/#41-протоколы)

Методы _HTTP_-запроса:

| **Название** | **Назначение**                                                                                                                                                                                                                                                                                                                                                                                        |
|:------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    `GET`     | Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (_Query String_) в составе _URL_ (например `?param=value`).                                                                                                                                                                                                                           |
|    `HEAD`    | Обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Данный метод при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении _GET_-запроса к тому же ресурсу. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой. |
|    `POST`    | Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, _PDF_-документы и другие типы данных в двоичном виде. Обычно метод `POST` используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.                                                                        |
|    `PUT`     | (Тело ответа отсутствует) Используется для создания (размещения) новых ресурсов на сервере. Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности.                                                                                                                                                                                 |
|   `DELETE`   | Позволяет удалить существующие ресурсы на сервере. Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (_Denial of Service_, _DoS_) из-за удаления критически важных файлов сервера.                                                                                                                                                   |
|  `CONNECT`   | Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.                                                                                                                                                                                                                                            |
|  `OPTIONS`   | Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере _HTTP_-методов.                                                                                                                                                                                                                                                                             |
|   `TRACE`    | Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.                                                                                                                                                                                                                                                                  |
|   `PATCH`    | (Тело ответа обязательно) Позволяет внести частичные изменения в указанный ресурс по указанному расположению.                                                                                                                                                                                                                                                                                         |

Получение доступа к ресурсам по _HTTP_-протоколу осуществляется с помощью указателя [_URL_](/conspect/04.md/#4113-url).

Версии протокола _HTTP_:

- HTTP/0.9;
- HTTP/1.0;
- HTTP/1.1;
- HTTP/2 (HTTP/2.0);
- HTTP/3.

_HTTP_-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(`:`) в качестве разделителя.
Название заголовка не учитывает регистр, то есть между `Host` и `host`, с точки зрения _HTTP_, нет никакой разницы.  
_HTTP_-заголовки можно разделить на 4 категории:

- _General Headers_ («Основные заголовки») - могут включаться в любое сообщение клиента и сервера;
- _Request Headers_ («Заголовки запроса») - используются только в запросах клиента;
- _Response Headers_ («Заголовки ответа») - только для ответов от сервера;
- _Entity Headers_ («Заголовки сущности») - сопровождают каждую сущность сообщения.

> [[Ссылка]](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP)
> на список заголовков _HTTP_.

Самые частые заголовки _HTTP_-запроса:

|  **Название**   | **Назначение**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|:---------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|     `Host`      | Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и _IP_-адреса. На одном _HTTP_-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.                                                                                                                                                                                                                                                                                                                    |
|  `User-Agent`   | Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.                                                                                                                                                                                                                                                                                                                                          |
|     `Refer`     | Используется для указания того, откуда поступил текущий запрос. То есть указывается _URI_ ресурса, с которого был произведён переход.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|    `Accept`     | Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (`,`). А для указания того, что клиент принимает любые типы, используется следующая последовательность — `*/*`.                                                                                                                                                                                                                                                                                                                                                                              |
|    `Cookie`     | Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате `cookie=value`. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (`;`), который  используется как разделитель. |
| `Authorization` | Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.                                                                                                                                                                        |

Не у каждого _HTTP_-метода предполагается наличие тела. Методам вроде `GET`, `HEAD`, `DELETE` и `OPTIONS` обычно не
требуется тело. Некоторые виды запросов могут отправлять данные на сервер в теле запроса: самый распространенный из
таких методов — `POST`.

#### 4.1.1.2 HTTP-ответ

> [[_оглавление_]](../README.md/#41-протоколы)

После получения запроса, сервер его обрабатывает и отправляет ответ клиенту.

Пример:

```http request
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 98

<html>
  <head>
    <title>An Example Page</title>
  </head>
  <body>
    <p>Hello World</p>
  </body>
</html>
```

Стартовая строка _HTTP_-ответа называется строкой статуса (_Status line_).

_Status line_ содержит:

![21.png](/pictures/21.png)

- версию протокола;
- код состояния;
- пояснение к коду состояния.

> [[Ссылка]](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
> на коды состояний и их расшифровки для _HTTP_-ответов.

Категории кодов состояний _HTTP_-ответов:

| **Категория** | **Классификация** | **Описание**                                                                                                                                                                                                |
|:-------------:|:-----------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|     `1xx`     |  Информационные   | Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.                                                                                                 |
|     `2xx`     |       Успех       | Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.                                                                                                              |
|     `3xx`     |  Перенаправление  | Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.                                                                                                                |
|     `4xx`     |  Ошибка клиента   | Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа. |
|     `5xx`     |  Ошибка сервера   | Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.                                                                                                                         |

Заголовки ответа (_Response Headers_) используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела.
Они существуют в том же формате, что и остальные заголовки, а именно «Имя-Значение» с двоеточием (`:`) в качестве
разделителя.

Наиболее часто встречаемые в ответах заголовки:

|  **Категория**   |                 **Пример**                  | **Описание**                                                                                                                      |
|:----------------:|:-------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------|
|      Server      |               `Server: ngnix`               | Содержит информацию о сервере, который обработал запрос.                                                                          |
|    Set-Cookie    |        `Set-Cookie:PHPSSID=bf42938f`        | Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов. |
| WWW-Authenticate | `WWW-Authenticate: BASIC realm=»localhost»` | Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.                                 |

> [[Ссылка]](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP)
> на список заголовков _HTTP_.

Последней частью ответа является его тело. Несмотря на то, что у большинства ответов тело присутствует, оно не является
обязательным. Например, у кодов `201 Created` или `204 No Content` тело отсутствует, так как достаточную информацию для
ответа на запрос они передают в заголовке.

#### 4.1.1.3 URL

> [[_оглавление_]](../README.md/#41-протоколы)

[**URL (Uniform Resource Locator)**](/conspect/definitions.md/#u) - это строка, которая позволяет указать запрашиваемый
ресурс и еще ряд параметров.

[**URI (Uniform Resource Identifier)**](/conspect/definitions.md/#u) - это унифицированный (единообразный) идентификатор
ресурса; символьная строка, позволяющая идентифицировать какой-либо ресурс: документ, изображение, файл, службу, ящик
электронной почты и т.д.

![20.png](/pictures/20.png)

При вводе _URL_ в виде букв алфавита, браузер отправляет запрос к _DNS_-серверу. _DNS_ используется для получения
_IP_-адреса по _URL_. В дальнейшем при обращении к данному ресурсу браузер автоматически заменяет доменное имя на _IP_
-адрес сервера.    
[**DNS (Domain Name System)**](/conspect/definitions.md/#d) - это система доменных имен, представляющая из себя сервер,
на котором хранятся _IP_-адреса серверов, соответствующие их доменному имени.
[**IP-адрес (Internet Protocol)**](/conspect/definitions.md/#i) - это уникальный числовой идентификатор устройства в
компьютерной сети.

Структура _URL_:

```text
<схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<URL‐путь>][?<параметры>][#<якорь>]
```

- схема - схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол;
- логин - имя пользователя, используемое для доступа к ресурсу;
- пароль - пароль указанного пользователя;
- хост - полностью прописанное доменное имя хоста в системе _DNS_ или _IP_-адрес хоста в форме четырёх групп десятичных
  чисел, разделённых точками; числа — целые в интервале от 0 до 255;
- порт - порт хоста для подключения;
- URL-путь - уточняющая информация о месте нахождения ресурса; зависит от протокола;
- параметры - строка запроса с передаваемыми на сервер (методом `GET`) параметрами (начинается со знака вопроса (`?`),
  разделитель параметров - амперсанд (`&`));
  пример: `?параметр_1=значение_1&параметр_2=значение_2&параметр3=значение_3`;
- якорь - идентификатор «якоря» с предшествующим символом решётка (`#`); якорем может быть указан заголовок внутри
  документа или атрибут _id_ элемента, по такой ссылке браузер откроет страницу и переместит окно к указанному элементу.

Общепринятые схемы (протоколы) _URL_ включают:

- _ftp_ - протокол передачи файлов _FTP_;
- _http_ - протокол передачи гипертекста _HTTP_;
- _rtmp_ - проприетарный протокол потоковой передачи данных _Real Time Messaging Protocol_, в основном используется для
  передачи потокового видео и аудио с веб-камер через Интернет;
- _rtsp_ - потоковый протокол реального времени;
- _https_ - специальная реализация протокола _HTTP_, использующая шифрование (как правило, _SSL_ или _TLS_);
- _gopher_ - протокол _Gopher_;
- _mailto_ - адрес электронной почты;
- _news_ - новости _Usenet_;
- _nntp_ - новости _Usenet_ через протокол _NNTP_;
- _irc_ - протокол _IRC_;
- _smb_ - протокол _SMB_/_CIFS_;
- _prospero_ - служба каталогов _Prospero Directory Service_;
- _telnet_ - ссылка на интерактивную сессию _Telnet_;
- _wais_ - база данных системы _WAIS_;
- _xmpp_ - протокол _XMPP_ (часть _Jabber_);
- _file_ - имя локального файла;
- _data_ - непосредственные данные (`Data: URL`);
- _tel_ - звонок по указанному телефону.

#### 4.1.1.4 HTTPS

> [[_оглавление_]](../README.md/#41-протоколы)

_HTTP_ является расширяемым протоколом, который предоставляет огромное количество возможностей, а также поддерживает
передачу всевозможных типов файлов. Однако, вне зависимости от версии, у него есть один существенный недостаток, который
можно заметить если перехватить отправленный _HTTP_-запрос: данные передаются в открытом виде.  
_HTTP_ сам по себе не предоставляет никаких средств шифрования.

[**HTTPS (HyperText Transfer Protocol Secure)**](/conspect/definitions.md/#h) - это расширение протокола _HTTP_ для
поддержки шифрования в целях повышения безопасности.

Данные в протоколе _HTTPS_ передаются поверх криптографических протоколов _TLS_ или устаревшего _SSL_. В отличие от
_HTTP_ с _TCP_-портом `80`, для _HTTPS_ по умолчанию используется _TCP_-порт `443`.

Протоколы _TLS (Transport Layer Security)_ и _SSL (Secure Socket Layer)_ - криптографические. Это значит, что они
позволяют шифровать данные, что передаются между браузером и сервером. Расшифровать эти данные могут только сервер и
браузер, для всех остальных это будет набор нечитаемых символов.

## 4.2 Форматы

> [[_оглавление_]](../README.md/#42-форматы)

_RESTful_-приложения позволяют обмениваться текстовой информацией в специальных форматах, а так же загружать или
выгружать файлы с сервера на или с клиентской стороны.

Основными языками разметки для текстовых сообщений являются:

- [XML](/conspect/04.md/#421-xml);
- [JSON](/conspect/04.md/#422-json);
- [YAML](/conspect/04.md/#423-yaml).

### 4.2.1 XML

> [[_оглавление_]](../README.md/#42-форматы)

[**XML (eXtensible Markup Language)**](/conspect/definitions.md/#x) - это расширяемый язык разметки, имеющий словарь
тегов и их атрибутов, а также набор правил.

Формат _XML_ - это формат, ориентированный на текст. Он базируется на _Unicode_ - стандарте кодирования символов,
который включает в себя знаки почти всех письменных языков мира. Изначально этот формат придумали для более удобного
хранения и передачи данных.

Основные преимущества формата _XML_:

- доступность;
- совместимость (благодаря тому, что XML хранит все данные в текстовом формате, их удобно передавать - дополнительная
  конвертация не нужна);
- универсальность (с его помощью можно структурировать, трансформировать и запрашивать данные);
- гибкость (устойчивость к редактированию).

_XML_ - это не исполняемый код, а _язык описания данных_.

Для описания данных в _XML_ используются теги, которые задают структуру и описывают, чем являются данные.

Структура любого _XML_-документа подчиняется набору определений и документации - **_Infoset_**. Каждый документ содержит
обязательные элементы и атрибуты, инструкцию обработки, комментарии, ссылки, пространства имён и многое другое.

Теги в документах распознаются легко, поскольку заключены в угловые скобки. Они всегда расставляются парами:

- `<первый>` - открывающий, ставится перед элементом, который необходимо разметить;
- `</второй>` - закрывающий, ставится после элемента.

Они показывают, где начинается и где заканчивается описание каждого элемента в файле. Текст внутри угловых скобок -
**_название тега_**, которое отвечает за то, к чему относится данный фрагмент.

Пример:

```xml

<message>
    Hello World
</message>
```

Кроме этого, одни теги можно вкладывать в другие теги.

Пример:

```xml

<message>
    <warning>
        Обратите внимание!
    </warning>
</message>
```

Такое свойство называется **_вложенностью_**. При этом вложенные теги могут иметь свои вложенности. Все вместе они
представляют **_дерево тегов_**.

Также для любого тега можно прописать атрибуты - дополнительную важную информацию.

Пример:

```xml

<xsd:element name="PLAYER">
    <xsd:complexType>
        <xsd:sequence>
            <xsd:element name="TEAM" type="xsd:string"/>
            <xsd:element name="TRAINER" type="xsd:string"/>
            <xsd:element name="RESULT" type="xsd:positiveInteger"/>
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>
```

По такому шаблону можно добавить нужную информацию, которая расширит или, наоборот, конкретизирует описание данных.

Самой первой строкой в файл добавляют информацию о кодировке и версии _XML_. Она называется **_prolog_** и выглядит вот
так:

```xml
<?xml version="3.0" encoding="UTF-8"?>
```

### 4.2.2 JSON

> [[_оглавление_]](../README.md/#42-форматы)

[**JSON (JavaScript Object Notation)**](/conspect/definitions.md/#j) - это текстовый формат обмена данными, основанный
на _JavaScript_.

_JSON_ используется в _REST API_.

В качестве значений в _JSON_ могут быть использованы:

- _JSON_-объект;
- массив;
- число (целое или вещественное);
- литералы `true` (логическое значение «истина»), `false` (логическое значение «ложь») и `null`;
- строка.

[**_JSON_-объект**](/conspect/definitions.md/#j) - это неупорядоченное множество пар `ключ:значение`, заключённое в
фигурные скобки (`{ }`).  
**_Ключ_** — это название параметра, который передаётся серверу. Он служит маркером для принимающей запрос системы.

Пример:

```json
{
  "query": "Виктор Иванов",
  "count": 7,
  "parts": [
    "NAME",
    "SURNAME"
  ]
}
```

Синтаксис описания данных в формате _JSON_:

- пары `ключ:значение` разделены запятыми и могут располагаться в любом последовательности (после последней пары запятая
  не нужна);
- строки берутся в кавычки (`" "`), а числа - нет;
- внутри _JSON_-объекта может быть не только строка или число, это может быть и другой объект (внутри которого может
  находиться ещё один объект - любое количество уровней вложенности);
- для объектов, массивов, чисел, булевых значений (`true` / `false`) — если это **НЕ** строка, кавычки не нужны (но в
  любом случае это будет значение какого-то ключа);
- переносы строк делать необязательно;
- ключ - ВСЕГДА строка;
- массивы заключаются в квадратные скобки (`[ ]`), внутри которых значения элементов массивов перечисляются через
  запятую в порядке увеличения их индексов.

### 4.2.3 YAML

> [[_оглавление_]](../README.md/#42-форматы)

[**YAML (Yet Another Markup Language)**](/conspect/definitions.md/#y) - это дружественный формат сериализации данных,
концептуально близкий к языкам разметки, но ориентированный на удобство ввода-вывода типичных структур данных многих
языков программирования.

Язык похож на _XML_ и _JSON_, но использует более минималистичный синтаксис при сохранении аналогичных возможностей.
_YAML_ обычно применяют для создания конфигурационных файлов.

Характеристики _YAML_:

- понятный человеку код;
- минималистичный синтаксис;
- заточен под работу с данными;
- встроенный стиль, похожий на _JSON_ (_YAML_ является его надмножеством);
- поддерживает комментарии;
- поддерживает строки без кавычек;
- считается «чище», чем _JSON_;
- дополнительные возможности (расширяемые типы данных, относительные якоря и маппинг типов с сохранением порядка
  ключей).

Особенности _YAML_:

- поддержка документов - можно объединить несколько YAML-документов в один YAML-файл для облегчения организации файлов и
  парсинга данных (данные разделяются тремя дефисами (`---`)):

```yaml
---
player: playerOne
action: attack (miss)
---
player: playerTwo
action: attack (hit)
---
```

- поддержка комментариев - _YAML_ позволяет добавлять комментарии после символа #:

```yaml
key: #Это однострочный комментарий
  - value line 5
  #Это
  #многострочный комментарий
  - value line 13
```

- легко читаемый синтаксис - в синтаксисе _YAML_-файлов используется система отступов (необходимо использовать
  пробелы, а не табуляцию, чтобы избежать путаницы):

```yaml
#YAML
Imaro:
author: Charles R. Saunders
language: English
publication-year: 1981
pages: 224
```

```json
{
  "Imaro": {
    "author": "Charles R. Saunders",
    "language": "English",
    "publication-year": "1981",
    "pages": 224
  }
}
```

- явная и неявная типизация - _YAML_ предлагает как автоопределение типов, так и возможность явно указать тип данных
  (чтобы использовать конкретный тип, нужно написать `!![тип]` перед значением):

```yaml
# Это значение преобразуется в int:
is-an-int: !!int 14.10
# Превращает любое значение в строку:
is-a-str: !!str 67.43
# Значение должно быть boolean:
is-a-bool: !!bool yes
```

- отсутствие исполняемых файлов.

Синтаксис описания данных в формате _YAML_:

- данные в _YAML_-файле хранятся в виде пары `ключ:значение`, где **_ключ_** - это имя пары, а **_значение_** -
  связанные данные;
- для скаляров (одно значение, которому соответствует имя) _YAML_ поддерживает стандартные типы: `int`
  и `float`, `boolean`, `string` и `null`;
- скаляры могут быть представлены в разных видах: шестнадцатеричном, восьмеричном или экспоненциальном, - также
  существуют специальные типы для математических сущностей, такие как: бесконечность и `NAN`;

```yaml
integer: 25
hex: 0x12d4 #равно 4820
octal: 023332 #равно 9946
float: 25.0
exponent: 12.3015e+05 #равно 1230150.0
boolean: Yes
string: "25"
infinity: .inf # преобразуется в бесконечность
neginf: -.Inf #преобразуется в минус бесконечность
not: .NAN #Not a Number
null: ~
```

- для описания строк не нужны кавычки, для описания отдельных строк можно использовать знак вертикального
  разделения (`|`), а параграфов - знак больше (`>`);

```yaml
str: Hello World
data: |
  Это
  Отдельные
  Строки
data: >
  Это 
  один параграф
  текста
```

- для описания списков или массивов в _YAML_ можно использовать либо отступы, либо квадратные скобки;

```yaml
shopping:
  - milk
  - eggs
  - juice
```

```yaml
shopping: [ milk, eggs, juice ]
```

- для описания вложенных объектов в _YAML_ используются словари (коллекции пар `ключ:значение`, которые хранятся под
  одним ключом), которые позволяют разделить данные на логические категории.

```yaml
Employees:
  - dan:
      name: Dan D. Veloper
      job: Developer
      team: DevOps
  - dora:
      name: Dora D. Veloper
      job: Project Manager
      team: Web Subscriptions
```

## 4.3 Принципы REST

> [[_оглавление_]](../README.md/#43-принципы-rest)

_REST_ определяет, как компоненты распределенной системы должны взаимодействовать друг с другом. В общем случае это
происходит посредством запросов-ответов.  
[**Клиент**](/conspect/definitions.md/#к) - это компонент, который отправляет запрос.  
[**Сервер**](/conspect/definitions.md/#с) - это компонент, который обрабатывает запрос и отправляет клиенту ответ.

Принципы _REST_:

1. Приведение архитектуры к модели клиент-сервер;

> В основе данного ограничения лежит разграничение потребностей. Необходимо отделять потребности клиентского интерфейса
> от потребностей сервера, хранящего данные. Данное ограничение повышает переносимость клиентского кода на другие
> платформы, а упрощение серверной части улучшает масштабируемость системы. Само разграничение на “клиент” и “сервер”
> позволяет им развиваться независимо друг от друга.

2. Отсутствие состояния;

> Архитектура _REST_ требует соблюдения следующего условия. В период между запросами серверу не нужно хранить информацию
> о состоянии клиента и наоборот. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю
> необходимую информацию для выполнения запроса. Таким образом и сервер, и клиент могут "понимать" любое принятое
> сообщение, не опираясь при этом на предыдущие сообщения.

3. Кэширование;

> Клиенты могут выполнять кэширование ответов сервера. У сервера, в свою очередь, должно быть явное или неявное
> обозначение как кэшируемых или некэшируемых, чтобы клиенты в ответ на последующие запросы не получали устаревшие или
> неверные данные.

4. Единообразие интерфейса;

> К фундаментальным требованиям _REST_-архитектуры относится и унифицированный, единообразный интерфейс. Клиент должен
> всегда понимать, в каком формате и на какие адреса ему нужно слать запрос, а сервер, в свою очередь, также должен
> понимать, в каком формате ему следует отвечать на запросы клиента. Этот единый формат клиент-серверного
> взаимодействия,
> который описывает, что, куда, в каком виде и как отсылать и является унифицированным интерфейсом.

5. Слои;

> Под слоями подразумевается иерархическая структура сетей. Иногда клиент может общаться напрямую с сервером, а иногда -
> просто с промежуточным узлом. Применение промежуточных серверов способно повысить масштабируемость за счёт
> балансировки
> нагрузки и распределённого кэширования.

6. Код по требованию (необязательное ограничение).

> Данное ограничение подразумевает, что клиент может расширять свою функциональность, за счет загрузки кода с сервера в
> виде апплетов или сценариев.

## 4.4 Клиент-серверное взаимодействие

> [[_оглавление_]](../README.md/#44-клиент-серверное-взаимодействие)

[**Ресурс**](/conspect/definitions.md/#р) - это данные, которые получают или изменяют клиенты посредством запросов.  
Основа клиент-серверного взаимодействия - манипуляция над ресурсами.

В _REST_ ресурсом может быть что угодно: абстракция некоторой сущности (например, пользователь, заказ, товар), что-то
конкретное (например, файл-картинка, видео, анимация, _PDF_-файл).

Клиенты отправляют запросы на эндпоинты, или же конечные точки (_End point_) по протоколу
[_HTTP_](/conspect/04.md/#411-http-и-https).  
[**End point**](/conspect/definitions.md/#e) - это _URI_ (или путь - _path_) до [ресурса](/conspect/definitions.md/#р).

> У каждого конкретного ресурса должен быть уникальный URI.

В _REST_ у каждого ресурса есть свой _ID_. Часто бывает так, что _ID_ ресурса в _REST_ совпадает с _ID_ записи в базе
данных, в которой хранится информация о данном ресурсе.

_URI_ в _REST_ принято начинать с множественной формы существительного, описывающего некоторый ресурс.

Например:

- `/clients` - _URI_ всех имеющихся клиентов;
- `/clients/23` - _URI_ конкретного клиента, а именно клиента с ID=23;
- `/clients/4` - _URI_ конкретного клиента, а именно клиента с ID=4;
- `/clients/4/orders` - _URI_ всех заказов клиента №4;
- `/clients/1/orders/12` - _URI_ заказа №12 клиента №1;
- `/clients/1/orders/12/items` - _URI_ списка всех товаров в заказе №12 сделанного клиентом №1.

Применительно к _REST_ клиенты часто могут слать в запросе к серверу заголовок `Accept`. Он нужен, чтобы дать серверу
понять, в каком формате клиент ожидает получить от него ответ. Различные варианты форматов представлены в так называемом
списке _MIME_-типов.

[**MIME (Multipurpose Internet Mail Extensions)**](/conspect/definitions.md/#m) - это многоцелевые расширения
интернет-почты; спецификация для кодирования информации и форматирования сообщений таким образом, чтобы их можно было
пересылать по интернету.

Каждый _MIME_-тип состоит из двух частей, разделяемых слэшем (`/`): из типа и подтипа.

Примеры _MIME_-типов для разных видов файлов:

- _text_ - `text/plain`, `text/css`, `text/html`;
- _image_ - `image/png`, `image/jpeg`, `image/gif`;
- _audio_ - `audio/wav`, `audio/mpeg`;
- _video_ - `video/mp4`, `video/ogg`;
- _application_ - `application/json`, `application/pdf`, `application/xml`, `application/octet-stream`.

В _REST_ для передачи тела запроса чаще всего используют форматы _XML_ или _JSON_.

Например:

```json
{
  "id": 1,
  "name": "War and Peace",
  "publishingYear": 1867,
  "author": {
    "id": 1,
    "firstName": "Lev",
    "lastName": "Tolstoy"
  }
}
```

```xml

<Book>
    <id>1</id>
    <name>War and Peace</name>
    <publishingYear>1867</publishingYear>
    <author>
        <id>1</id>
        <firstName>Lev</firstName>
        <lastName>Tolstoy</lastName>
    </author>
</Book>
```

В _REST_ после получения запроса и его обработки сервер отвечает клиенту по тому же протоколу
[_HTTP_](/conspect/04.md/#411-http-и-https).

> _REST_-архитектура в Java соблюдается за счёт реализации [_CRUD_-операций](/conspect/definitions.md/#c) на уровне
> контроллеров и сервисов.