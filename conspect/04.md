# 4 REST

> [[_оглавление_]](../README.md/#4-rest)

[**REST (Representational State Transfer)**](/conspect/definitions.md/#r) - это передача состояния представления;
архитектурный стиль взаимодействия (обмена данными) компонентов распределенной системы в компьютерной сети.

Данный архитектурный стиль представляет собой согласованный набор ограничений, учитываемых при проектировании
распределенной системы. Эти ограничения называют принципами _REST_ и их всего 6 штук.

[**_RESTful_-приложение**](/conspect/definitions.md/#r) - это приложение, построенное с учётом принципов _REST_.

Преимущества, которые дает _REST_:

- надёжность (не нужно сохранять информацию о состоянии клиента, которая может быть утеряна);
- производительность (за счёт использования кэша);
- масштабируемость;
- прозрачность системы взаимодействия;
- простота интерфейсов;
- портативность компонентов;
- лёгкость внесения изменений;
- способность эволюционировать, приспосабливаясь к новым требованиям.

## 4.1 Протоколы

> [[_оглавление_]](../README.md/#41-протоколы)

[**Протокол передачи данных**](/conspect/definitions.md/#п) - это общепринятое соглашение, благодаря которому
разработчики разных сервисов отправляют информацию в едином виде.

### 4.1.1 HTTP и HTTPS

> [[_оглавление_]](../README.md/#41-протоколы)

[**HTTP (HyperText Transfer Protocol)**](/conspect/definitions.md/#h) - это протокол передачи гипертекста; протокол
передачи данных прикладного уровня для распределённых, объединённых, гипермедийных информационных систем, в котором вся
информация передаётся в текстовом виде.

Структура _HTTP_:

- стартовая строка (_Starting line_) - определяет служебные данные;
- заголовки (_Headers_) - описание параметров сообщения;
- тело сообщения (_Body_) - данные сообщения (отделяются от заголовков пустой строкой).

Пример:

```http request
GET / HTTP/1.1
Host: javarush.com
User-Agent: firefox/5.0 (Linux; Debian 5.0.8; en-US; rv:1.8.1.7)
```

В данном примере:

- в стартовой строке указаны:
    * _GET_ - метод запроса;
    * _/_ - путь запроса (_path_);
    * _HTTP/1.1_ - версия протокола передачи данных;
- в заголовке указаны:
    * _Host_ - хост, которому адресован запрос;
    * _User-Agent_ - клиент (web-браузер), который отправляет запрос;
- тело сообщения отсутствует.

> В HTTP-запросе обязательны только стартовая строка и заголовок _Host_.

#### 4.1.1.1 HTTP-запрос

> [[_оглавление_]](../README.md/#41-протоколы)

Методы _HTTP_-запроса:

| **Название** | **Назначение**                                                                                                                                                                                                                                                                                                                                                                                        |
|:------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|    `GET`     | Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (_Query String_) в составе _URL_ (например `?param=value`).                                                                                                                                                                                                                           |
|    `HEAD`    | Обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Данный метод при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении _GET_-запроса к тому же ресурсу. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой. |
|    `POST`    | Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, _PDF_-документы и другие типы данных в двоичном виде. Обычно метод `POST` используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.                                                                        |
|    `PUT`     | (Тело ответа отсутствует) Используется для создания (размещения) новых ресурсов на сервере. Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности.                                                                                                                                                                                 |
|   `DELETE`   | Позволяет удалить существующие ресурсы на сервере. Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (_Denial of Service_, _DoS_) из-за удаления критически важных файлов сервера.                                                                                                                                                   |
|  `CONNECT`   | Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.                                                                                                                                                                                                                                            |
|  `OPTIONS`   | Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере _HTTP_-методов.                                                                                                                                                                                                                                                                             |
|   `TRACE`    | Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.                                                                                                                                                                                                                                                                  |
|   `PATCH`    | (Тело ответа обязательно) Позволяет внести частичные изменения в указанный ресурс по указанному расположению.                                                                                                                                                                                                                                                                                         |

Получение доступа к ресурсам по _HTTP_-протоколу осуществляется с помощью указателя [_URL_](/conspect/04.md/#4113-url).

Версии протокола _HTTP_:

- HTTP/0.9;
- HTTP/1.0;
- HTTP/1.1;
- HTTP/2 (HTTP/2.0);
- HTTP/3.

_HTTP_-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(`:`) в качестве разделителя.
Название заголовка не учитывает регистр, то есть между `Host` и `host`, с точки зрения _HTTP_, нет никакой разницы.  
_HTTP_-заголовки можно разделить на 4 категории:

- _General Headers_ («Основные заголовки») - могут включаться в любое сообщение клиента и сервера;
- _Request Headers_ («Заголовки запроса») - используются только в запросах клиента;
- _Response Headers_ («Заголовки ответа») - только для ответов от сервера;
- _Entity Headers_ («Заголовки сущности») - сопровождают каждую сущность сообщения.

> [[Ссылка]](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP)
> на список заголовков _HTTP_.

Самые частые заголовки _HTTP_-запроса:

|  **Название**   | **Назначение**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
|:---------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|     `Host`      | Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и _IP_-адреса. На одном _HTTP_-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.                                                                                                                                                                                                                                                                                                                    |
|  `User-Agent`   | Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.                                                                                                                                                                                                                                                                                                                                          |
|     `Refer`     | Используется для указания того, откуда поступил текущий запрос. То есть указывается _URI_ ресурса, с которого был произведён переход.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|    `Accept`     | Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (`,`). А для указания того, что клиент принимает любые типы, используется следующая последовательность — `*/*`.                                                                                                                                                                                                                                                                                                                                                                              |
|    `Cookie`     | Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате `cookie=value`. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (`;`), который  используется как разделитель. |
| `Authorization` | Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.                                                                                                                                                                        |

Не у каждого _HTTP_-метода предполагается наличие тела. Методам вроде `GET`, `HEAD`, `DELETE` и `OPTIONS` обычно не
требуется тело. Некоторые виды запросов могут отправлять данные на сервер в теле запроса: самый распространенный из
таких методов — `POST`.

#### 4.1.1.2 HTTP-ответ

> [[_оглавление_]](../README.md/#41-протоколы)

После получения запроса, сервер его обрабатывает и отправляет ответ клиенту.

Пример:

```http request
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 98

<html>
  <head>
    <title>An Example Page</title>
  </head>
  <body>
    <p>Hello World</p>
  </body>
</html>
```

Стартовая строка _HTTP_-ответа называется строкой статуса (_Status line_).

_Status line_ содержит:

![21.png](/pictures/21.png)

- версию протокола;
- код состояния;
- пояснение к коду состояния.

> [[Ссылка]](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP)
> на коды состояний и их расшифровки для _HTTP_-ответов.

Категории кодов состояний _HTTP_-ответов:

| **Категория** | **Классификация** | **Описание**                                                                                                                                                                                                |
|:-------------:|:-----------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|     `1xx`     |  Информационные   | Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.                                                                                                 |
|     `2xx`     |       Успех       | Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.                                                                                                              |
|     `3xx`     |  Перенаправление  | Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.                                                                                                                |
|     `4xx`     |  Ошибка клиента   | Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа. |
|     `5xx`     |  Ошибка сервера   | Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.                                                                                                                         |

Заголовки ответа (_Response Headers_) используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела.
Они существуют в том же формате, что и остальные заголовки, а именно «Имя-Значение» с двоеточием (`:`) в качестве
разделителя.

Наиболее часто встречаемые в ответах заголовки:

|  **Категория**   |                 **Пример**                  | **Описание**                                                                                                                      |
|:----------------:|:-------------------------------------------:|:----------------------------------------------------------------------------------------------------------------------------------|
|      Server      |               `Server: ngnix`               | Содержит информацию о сервере, который обработал запрос.                                                                          |
|    Set-Cookie    |        `Set-Cookie:PHPSSID=bf42938f`        | Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов. |
| WWW-Authenticate | `WWW-Authenticate: BASIC realm=»localhost»` | Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.                                 |

> [[Ссылка]](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP)
> на список заголовков _HTTP_.

Последней частью ответа является его тело. Несмотря на то, что у большинства ответов тело присутствует, оно не является
обязательным. Например, у кодов `201 Created` или `204 No Content` тело отсутствует, так как достаточную информацию для
ответа на запрос они передают в заголовке.

#### 4.1.1.3 URL

> [[_оглавление_]](../README.md/#41-протоколы)

[**URL (Uniform Resource Locator)**](/conspect/definitions.md/#u) - это строка, которая позволяет указать запрашиваемый
ресурс и еще ряд параметров.

[**URI (Uniform Resource Identifier)**](/conspect/definitions.md/#u) - это унифицированный (единообразный) идентификатор
ресурса; символьная строка, позволяющая идентифицировать какой-либо ресурс: документ, изображение, файл, службу, ящик
электронной почты и т.д.

![20.png](/pictures/20.png)

При вводе _URL_ в виде букв алфавита, браузер отправляет запрос к _DNS_-серверу. _DNS_ используется для получения
_IP_-адреса по _URL_. В дальнейшем при обращении к данному ресурсу браузер автоматически заменяет доменное имя на _IP_
-адрес сервера.    
[**DNS (Domain Name System)**](/conspect/definitions.md/#d) - это система доменных имен, представляющая из себя сервер,
на котором хранятся _IP_-адреса серверов, соответствующие их доменному имени.
[**IP-адрес (Internet Protocol)**](/conspect/definitions.md/#i) - это уникальный числовой идентификатор устройства в
компьютерной сети.

Структура _URL_:

```text
<схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<URL‐путь>][?<параметры>][#<якорь>]
```

- схема - схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол;
- логин - имя пользователя, используемое для доступа к ресурсу;
- пароль - пароль указанного пользователя;
- хост - полностью прописанное доменное имя хоста в системе _DNS_ или _IP_-адрес хоста в форме четырёх групп десятичных
  чисел, разделённых точками; числа — целые в интервале от 0 до 255;
- порт - порт хоста для подключения;
- URL-путь - уточняющая информация о месте нахождения ресурса; зависит от протокола;
- параметры - строка запроса с передаваемыми на сервер (методом `GET`) параметрами (начинается со знака вопроса (`?`),
  разделитель параметров - амперсанд (`&`));
  пример: `?параметр_1=значение_1&параметр_2=значение_2&параметр3=значение_3`;
- якорь - идентификатор «якоря» с предшествующим символом решётка (`#`); якорем может быть указан заголовок внутри
  документа или атрибут _id_ элемента, по такой ссылке браузер откроет страницу и переместит окно к указанному элементу.

Общепринятые схемы (протоколы) _URL_ включают:

- _ftp_ - протокол передачи файлов _FTP_;
- _http_ - протокол передачи гипертекста _HTTP_;
- _rtmp_ - проприетарный протокол потоковой передачи данных _Real Time Messaging Protocol_, в основном используется для
  передачи потокового видео и аудио с веб-камер через Интернет;
- _rtsp_ - потоковый протокол реального времени;
- _https_ - специальная реализация протокола _HTTP_, использующая шифрование (как правило, _SSL_ или _TLS_);
- _gopher_ - протокол _Gopher_;
- _mailto_ - адрес электронной почты;
- _news_ - новости _Usenet_;
- _nntp_ - новости _Usenet_ через протокол _NNTP_;
- _irc_ - протокол _IRC_;
- _smb_ - протокол _SMB_/_CIFS_;
- _prospero_ - служба каталогов _Prospero Directory Service_;
- _telnet_ - ссылка на интерактивную сессию _Telnet_;
- _wais_ - база данных системы _WAIS_;
- _xmpp_ - протокол _XMPP_ (часть _Jabber_);
- _file_ - имя локального файла;
- _data_ - непосредственные данные (`Data: URL`);
- _tel_ - звонок по указанному телефону.

#### 4.1.1.4 HTTPS

> [[_оглавление_]](../README.md/#41-протоколы)

_HTTP_ является расширяемым протоколом, который предоставляет огромное количество возможностей, а также поддерживает
передачу всевозможных типов файлов. Однако, вне зависимости от версии, у него есть один существенный недостаток, который
можно заметить если перехватить отправленный _HTTP_-запрос: данные передаются в открытом виде.  
_HTTP_ сам по себе не предоставляет никаких средств шифрования.

[**HTTPS (HyperText Transfer Protocol Secure)**](/conspect/definitions.md/#h) - это расширение протокола _HTTP_ для
поддержки шифрования в целях повышения безопасности.

Данные в протоколе _HTTPS_ передаются поверх криптографических протоколов _TLS_ или устаревшего _SSL_. В отличие от
_HTTP_ с _TCP_-портом `80`, для _HTTPS_ по умолчанию используется _TCP_-порт `443`.

Протоколы _TLS (Transport Layer Security)_ и _SSL (Secure Socket Layer)_ - криптографические. Это значит, что они
позволяют шифровать данные, что передаются между браузером и сервером. Расшифровать эти данные могут только сервер и
браузер, для всех остальных это будет набор нечитаемых символов.

## 4.2 Форматы

> [[_оглавление_]](../README.md/#42-форматы)

_RESTful_-приложения позволяют обмениваться текстовой информацией в специальных форматах, а так же загружать или
выгружать файлы с сервера на или с клиентской стороны.

Основными языками разметки для текстовых сообщений являются:

- [XML](/conspect/04.md/#421-xml);
- [JSON](/conspect/04.md/#422-json);
- [YAML](/conspect/04.md/#423-yaml).

### 4.2.1 XML

> [[_оглавление_]](../README.md/#42-форматы)

[**XML (eXtensible Markup Language)**](/conspect/definitions.md/#x) - это расширяемый язык разметки, имеющий словарь
тегов и их атрибутов, а также набор правил.

Формат _XML_ - это формат, ориентированный на текст. Он базируется на _Unicode_ - стандарте кодирования символов,
который включает в себя знаки почти всех письменных языков мира. Изначально этот формат придумали для более удобного
хранения и передачи данных.

Основные преимущества формата _XML_:

- доступность;
- совместимость (благодаря тому, что XML хранит все данные в текстовом формате, их удобно передавать - дополнительная
  конвертация не нужна);
- универсальность (с его помощью можно структурировать, трансформировать и запрашивать данные);
- гибкость (устойчивость к редактированию).

_XML_ - это не исполняемый код, а _язык описания данных_.

Для описания данных в _XML_ используются теги, которые задают структуру и описывают, чем являются данные.

Структура любого _XML_-документа подчиняется набору определений и документации - **_Infoset_**. Каждый документ содержит
обязательные элементы и атрибуты, инструкцию обработки, комментарии, ссылки, пространства имён и многое другое.

Теги в документах распознаются легко, поскольку заключены в угловые скобки. Они всегда расставляются парами:

- `<первый>` - открывающий, ставится перед элементом, который необходимо разметить;
- `</второй>` - закрывающий, ставится после элемента.

Они показывают, где начинается и где заканчивается описание каждого элемента в файле. Текст внутри угловых скобок -
**_название тега_**, которое отвечает за то, к чему относится данный фрагмент.

Пример:

```xml

<message>
    Hello World
</message>
```

Кроме этого, одни теги можно вкладывать в другие теги.

Пример:

```xml

<message>
    <warning>
        Обратите внимание!
    </warning>
</message>
```

Такое свойство называется **_вложенностью_**. При этом вложенные теги могут иметь свои вложенности. Все вместе они
представляют **_дерево тегов_**.

Также для любого тега можно прописать атрибуты - дополнительную важную информацию.

Пример:

```xml

<xsd:element name="PLAYER">
    <xsd:complexType>
        <xsd:sequence>
            <xsd:element name="TEAM" type="xsd:string"/>
            <xsd:element name="TRAINER" type="xsd:string"/>
            <xsd:element name="RESULT" type="xsd:positiveInteger"/>
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>
```

По такому шаблону можно добавить нужную информацию, которая расширит или, наоборот, конкретизирует описание данных.

Самой первой строкой в файл добавляют информацию о кодировке и версии _XML_. Она называется **_prolog_** и выглядит вот
так:

```xml
<?xml version="3.0" encoding="UTF-8"?>
```

### 4.2.2 JSON

> [[_оглавление_]](../README.md/#42-форматы)

[**JSON (JavaScript Object Notation)**](/conspect/definitions.md/#j) - это текстовый формат обмена данными, основанный
на _JavaScript_.

_JSON_ используется в _REST API_.

В качестве значений в _JSON_ могут быть использованы:

- _JSON_-объект;
- массив;
- число (целое или вещественное);
- литералы `true` (логическое значение «истина»), `false` (логическое значение «ложь») и `null`;
- строка.

[**_JSON_-объект**](/conspect/definitions.md/#j) - это неупорядоченное множество пар `ключ:значение`, заключённое в
фигурные скобки (`{ }`).  
**_Ключ_** — это название параметра, который передаётся серверу. Он служит маркером для принимающей запрос системы.

Пример:

```json
{
  "query": "Виктор Иванов",
  "count": 7,
  "parts": [
    "NAME",
    "SURNAME"
  ]
}
```

Синтаксис описания данных в формате _JSON_:

- пары `ключ:значение` разделены запятыми и могут располагаться в любом последовательности (после последней пары запятая
  не нужна);
- строки берутся в кавычки (`" "`), а числа - нет;
- внутри _JSON_-объекта может быть не только строка или число, это может быть и другой объект (внутри которого может
  находиться ещё один объект - любое количество уровней вложенности);
- для объектов, массивов, чисел, булевых значений (`true` / `false`) — если это **НЕ** строка, кавычки не нужны (но в
  любом случае это будет значение какого-то ключа);
- переносы строк делать необязательно;
- ключ - ВСЕГДА строка;
- массивы заключаются в квадратные скобки (`[ ]`), внутри которых значения элементов массивов перечисляются через
  запятую в порядке увеличения их индексов.

### 4.2.3 YAML

> [[_оглавление_]](../README.md/#42-форматы)

[**YAML (Yet Another Markup Language)**](/conspect/definitions.md/#y) - это дружественный формат сериализации данных,
концептуально близкий к языкам разметки, но ориентированный на удобство ввода-вывода типичных структур данных многих
языков программирования.

Язык похож на _XML_ и _JSON_, но использует более минималистичный синтаксис при сохранении аналогичных возможностей.
_YAML_ обычно применяют для создания конфигурационных файлов.

Характеристики _YAML_:

- понятный человеку код;
- минималистичный синтаксис;
- заточен под работу с данными;
- встроенный стиль, похожий на _JSON_ (_YAML_ является его надмножеством);
- поддерживает комментарии;
- поддерживает строки без кавычек;
- считается «чище», чем _JSON_;
- дополнительные возможности (расширяемые типы данных, относительные якоря и маппинг типов с сохранением порядка
  ключей).

Особенности _YAML_:

- поддержка документов - можно объединить несколько YAML-документов в один YAML-файл для облегчения организации файлов и
  парсинга данных (данные разделяются тремя дефисами (`---`)):

```yaml
---
player: playerOne
action: attack (miss)
---
player: playerTwo
action: attack (hit)
---
```

- поддержка комментариев - _YAML_ позволяет добавлять комментарии после символа #:

```yaml
key: #Это однострочный комментарий
  - value line 5
  #Это
  #многострочный комментарий
  - value line 13
```

- легко читаемый синтаксис - в синтаксисе _YAML_-файлов используется система отступов (необходимо использовать
  пробелы, а не табуляцию, чтобы избежать путаницы):

```yaml
#YAML
Imaro:
author: Charles R. Saunders
language: English
publication-year: 1981
pages: 224
```

```json
{
  "Imaro": {
    "author": "Charles R. Saunders",
    "language": "English",
    "publication-year": "1981",
    "pages": 224
  }
}
```

- явная и неявная типизация - _YAML_ предлагает как автоопределение типов, так и возможность явно указать тип данных
  (чтобы использовать конкретный тип, нужно написать `!![тип]` перед значением):

```yaml
# Это значение преобразуется в int:
is-an-int: !!int 14.10
# Превращает любое значение в строку:
is-a-str: !!str 67.43
# Значение должно быть boolean:
is-a-bool: !!bool yes
```

- отсутствие исполняемых файлов.

Синтаксис описания данных в формате _YAML_:

- данные в _YAML_-файле хранятся в виде пары `ключ:значение`, где **_ключ_** - это имя пары, а **_значение_** -
  связанные данные;
- для скаляров (одно значение, которому соответствует имя) _YAML_ поддерживает стандартные типы: `int`
  и `float`, `boolean`, `string` и `null`;
- скаляры могут быть представлены в разных видах: шестнадцатеричном, восьмеричном или экспоненциальном, - также
  существуют специальные типы для математических сущностей, такие как: бесконечность и `NAN`;

```yaml
integer: 25
hex: 0x12d4 #равно 4820
octal: 023332 #равно 9946
float: 25.0
exponent: 12.3015e+05 #равно 1230150.0
boolean: Yes
string: "25"
infinity: .inf # преобразуется в бесконечность
neginf: -.Inf #преобразуется в минус бесконечность
not: .NAN #Not a Number
null: ~
```

- для описания строк не нужны кавычки, для описания отдельных строк можно использовать знак вертикального
  разделения (`|`), а параграфов - знак больше (`>`);

```yaml
str: Hello World
data: |
  Это
  Отдельные
  Строки
data: >
  Это 
  один параграф
  текста
```

- для описания списков или массивов в _YAML_ можно использовать либо отступы, либо квадратные скобки;

```yaml
shopping:
  - milk
  - eggs
  - juice
```

```yaml
shopping: [ milk, eggs, juice ]
```

- для описания вложенных объектов в _YAML_ используются словари (коллекции пар `ключ:значение`, которые хранятся под
  одним ключом), которые позволяют разделить данные на логические категории.

```yaml
Employees:
  - dan:
      name: Dan D. Veloper
      job: Developer
      team: DevOps
  - dora:
      name: Dora D. Veloper
      job: Project Manager
      team: Web Subscriptions
```

## 4.3 Принципы REST

> [[_оглавление_]](../README.md/#43-принципы-rest)

_REST_ определяет, как компоненты распределенной системы должны взаимодействовать друг с другом. В общем случае это
происходит посредством запросов-ответов.  
[**Клиент**](/conspect/definitions.md/#к) - это компонент, который отправляет запрос.  
[**Сервер**](/conspect/definitions.md/#с) - это компонент, который обрабатывает запрос и отправляет клиенту ответ.

Принципы _REST_:

1. Приведение архитектуры к модели клиент-сервер;

> В основе данного ограничения лежит разграничение потребностей. Необходимо отделять потребности клиентского интерфейса
> от потребностей сервера, хранящего данные. Данное ограничение повышает переносимость клиентского кода на другие
> платформы, а упрощение серверной части улучшает масштабируемость системы. Само разграничение на “клиент” и “сервер”
> позволяет им развиваться независимо друг от друга.

2. Отсутствие состояния;

> Архитектура _REST_ требует соблюдения следующего условия. В период между запросами серверу не нужно хранить информацию
> о состоянии клиента и наоборот. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю
> необходимую информацию для выполнения запроса. Таким образом и сервер, и клиент могут "понимать" любое принятое
> сообщение, не опираясь при этом на предыдущие сообщения.

3. Кэширование;

> Клиенты могут выполнять кэширование ответов сервера. У сервера, в свою очередь, должно быть явное или неявное
> обозначение как кэшируемых или некэшируемых, чтобы клиенты в ответ на последующие запросы не получали устаревшие или
> неверные данные.

4. Единообразие интерфейса;

> К фундаментальным требованиям _REST_-архитектуры относится и унифицированный, единообразный интерфейс. Клиент должен
> всегда понимать, в каком формате и на какие адреса ему нужно слать запрос, а сервер, в свою очередь, также должен
> понимать, в каком формате ему следует отвечать на запросы клиента. Этот единый формат клиент-серверного
> взаимодействия,
> который описывает, что, куда, в каком виде и как отсылать и является унифицированным интерфейсом.

5. Слои;

> Под слоями подразумевается иерархическая структура сетей. Иногда клиент может общаться напрямую с сервером, а иногда -
> просто с промежуточным узлом. Применение промежуточных серверов способно повысить масштабируемость за счёт
> балансировки
> нагрузки и распределённого кэширования.

6. Код по требованию (необязательное ограничение).

> Данное ограничение подразумевает, что клиент может расширять свою функциональность, за счет загрузки кода с сервера в
> виде апплетов или сценариев.

## 4.4 Клиент-серверное взаимодействие

> [[_оглавление_]](../README.md/#44-клиент-серверное-взаимодействие)

[**Ресурс**](/conspect/definitions.md/#р) - это данные, которые получают или изменяют клиенты посредством запросов.  
Основа клиент-серверного взаимодействия - манипуляция над ресурсами.

В _REST_ ресурсом может быть что угодно: абстракция некоторой сущности (например, пользователь, заказ, товар), что-то
конкретное (например, файл-картинка, видео, анимация, _PDF_-файл).

Клиенты отправляют запросы на эндпоинты, или же конечные точки (_End point_) по протоколу
[_HTTP_](/conspect/04.md/#411-http-и-https).  
[**End point**](/conspect/definitions.md/#e) - это _URI_ (или путь - _path_) до [ресурса](/conspect/definitions.md/#р).

> У каждого конкретного ресурса должен быть уникальный URI.

В _REST_ у каждого ресурса есть свой _ID_. Часто бывает так, что _ID_ ресурса в _REST_ совпадает с _ID_ записи в базе
данных, в которой хранится информация о данном ресурсе.

_URI_ в _REST_ принято начинать с множественной формы существительного, описывающего некоторый ресурс.

Например:

- `/clients` - _URI_ всех имеющихся клиентов;
- `/clients/23` - _URI_ конкретного клиента, а именно клиента с ID=23;
- `/clients/4` - _URI_ конкретного клиента, а именно клиента с ID=4;
- `/clients/4/orders` - _URI_ всех заказов клиента №4;
- `/clients/1/orders/12` - _URI_ заказа №12 клиента №1;
- `/clients/1/orders/12/items` - _URI_ списка всех товаров в заказе №12 сделанного клиентом №1.

Применительно к _REST_ клиенты часто могут слать в запросе к серверу заголовок `Accept`. Он нужен, чтобы дать серверу
понять, в каком формате клиент ожидает получить от него ответ. Различные варианты форматов представлены в так называемом
списке _MIME_-типов.

[**MIME (Multipurpose Internet Mail Extensions)**](/conspect/definitions.md/#m) - это многоцелевые расширения
интернет-почты; спецификация для кодирования информации и форматирования сообщений таким образом, чтобы их можно было
пересылать по интернету.

Каждый _MIME_-тип состоит из двух частей, разделяемых слэшем (`/`): из типа и подтипа.

Примеры _MIME_-типов для разных видов файлов:

- _text_ - `text/plain`, `text/css`, `text/html`;
- _image_ - `image/png`, `image/jpeg`, `image/gif`;
- _audio_ - `audio/wav`, `audio/mpeg`;
- _video_ - `video/mp4`, `video/ogg`;
- _application_ - `application/json`, `application/pdf`, `application/xml`, `application/octet-stream`.

В _REST_ для передачи тела запроса чаще всего используют форматы _XML_ или _JSON_.

Например:

```json
{
  "id": 1,
  "name": "War and Peace",
  "publishingYear": 1867,
  "author": {
    "id": 1,
    "firstName": "Lev",
    "lastName": "Tolstoy"
  }
}
```

```xml

<Book>
    <id>1</id>
    <name>War and Peace</name>
    <publishingYear>1867</publishingYear>
    <author>
        <id>1</id>
        <firstName>Lev</firstName>
        <lastName>Tolstoy</lastName>
    </author>
</Book>
```

В _REST_ после получения запроса и его обработки сервер отвечает клиенту по тому же протоколу
[_HTTP_](/conspect/04.md/#411-http-и-https).

> _REST_-архитектура в Java соблюдается за счёт реализации [_CRUD_-операций](/conspect/definitions.md/#c) на уровне
> контроллеров и сервисов.

### 4.1.2 SOAP

> [[_оглавление_]](../README.md/#41-протоколы)

[**SOAP (Simple Object Access Protocol)**](/conspect/definitions.md/#s) - это простой протокол доступа к объектам;
основанный на XML протокол передачи сообщений, для обмена информацией между компьютерами.

Ключевые аспекты _SOAP_:

- это протокол обмена данными, предназначенный для связи в интернете;
- обеспечивает передачу данных для веб-сервисов;
- может расширять _HTTP_ для обмена _XML_-сообщениями;
- может быть использован для вещания сообщений;
- позволяет клиентским приложениям легко подключаться к удалённым сервисам и вызывать удалённые методы;
- может передавать целые документы, либо вызывать удалённые процедуры;
- с помощью _XML_-конфигурации определяет как и когда передавать информацию;
- не зависит ни от платформы, ни от языка программирования.

Данный протокол используется в самых различных системах обмена сообщениями и может передаватья с помоью множества
протоклов передачи данных. Изначально _SOAP_ ориентирован на вызов удалённых процедур с помощью _HTTP_.

#### 4.1.2.1 Структура сообщения

> [[_оглавление_]](../README.md/#41-протоколы)

Сообщение _SOAP_ - это простой _XML_-документ, который состоит из следующих элементов:

- _Envelope_ - обязательный элемент, который определяет начало и конец сообщения;
- _Header_ - опциональный элемент который может включать в себя любый опциональные (не обязательные) аттрибуты
  сообщения;
- _Body_ - обязательный элемент, который влючает в себя данные _XML_, определяющие сообщение, которые должно быть
  отправлено;
- _Fault_ - опциональный элемент, который предоставляет информацию об ошибках, которые возникают в процессе обработки
  сообщения.

Пример:

```xml
<?xml version="1.0"?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2001/12/soap-envelope"
                   SOAP-ENV:encodingStyle="http://www.w3.org/2001/12/soap-encoding"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.w3.org/2001/12/soap-envelope ">

    <SOAP-ENV:Header>
        ...
        ...
    </SOAP-ENV:Header>

    <SOAP-ENV:Body>
        ...
        ...
        <SOAP-ENV:Fault>
            ...
            ...
        </SOAP-ENV:Fault>
        ...
    </SOAP-ENV:Body>

</SOAP_ENV:Envelope>
```

##### 4.1.2.1.1 Envelope

> [[_оглавление_]](../README.md/#41-протоколы)

Элемент _SOAP_ сообщения _ENVELOPE_ определяет начало и конец сообщения.  
Именно благодаря этому элементу, клиент, принимающий сообщение знает, когда сообщение полностью получено (с помощью
этого элемента мы можем узнать когда сообщение получено и готово к обработке).

При работе с _SOAP_ важно учитывать следующие моменты:

- элемент _Enveloper_ является обязательной частью _SOAP_-сообщения;
- внутри каждого элемента _Envelope_ должен быть один элемент _Body_;
- элемент _Envelope_ определяется с помощью пространства имён _ENV_ и элемента _Enveloper_;
- опциональная кодировка _SOAP_ также определяется с помощью пространства имён и опционального элемента `encodingStyle`,
  который также может определить стиль кодировку отличную от _SOAP_;
- процессор _v1.1-compliant_ генерирует ошибку в случае получения сообщения, которое содержит пространство имён
  _envelope v1.2_;
- процессор _v1.2-compliant_ генерирует ошибку _VersionMismatch_ в случае получения сообщения, которое не содержит
  пространство имён _envelope v1.2_.

Пример _SOAP_ сообщения _v.1.2_:

```xml
<?xml version="1.0"?>

<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2001/12/soap-envelope"
                   SOAP-ENV:encodingStyle=" http://www.w3.org/2001/12/soap-encoding">
    Это простое SOAP сообщение.
</SOAP-ENV:Envelope>
```

Пример _SOAP_ сообщения с использованием метода _HTTP_ `POST`:

```http request
POST /OrderEntry HTTP/1.1
Host: www.proselyte.net
Content-Type: application/soap;  charset="utf-8"
Content-Length: nn
<?xml version="1.0"?>

<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2001/12/soap-envelope" SOAP-ENV:encodingStyle=" http://www.w3.org/2001/12/soap-encoding">
   Простое SOAP сообщение.
</SOAP-ENV:Envelope>
```

Данный пример демонстрирует использование _SOAP_ сообщения внутри метода _HTTP_ `POST`, который отправляет сообщение на
сервер. Оно показывает пространство имён для `envelope` для определения _schema_ и кодировки. Ссылка `OrderEntry` внутри
хедера _HTTP_ – это имя программы, которая будет вызвана на сайте _proselyte.net_.

##### 4.1.2.1.2 Header

> [[_оглавление_]](../README.md/#41-протоколы)

Элемент _Header_ даёт возможность определять дополнительные свойства приложения. Например, можно использовать его для
определения сигнатуры сервисов защищённых паролем.

При работе с _SOAP_ стоит учитывать следующие моменты:

- элемент _Header_ является не обязательным;
- этот элемент используется для добавления новых возможностей и функциональности;
- элемент _Header_ можно использовать несколько раз в файле;
- _Header_ является первым к прочтению файлом внутри элемента `envelope`.

Аттрибуты элемента _Header_:

- _Actor_;

> Протокол _SOAP_ определяет расположение сообщения, как список сервисов _SOAP_. Каждый из этих промежуточных сервисов
> может выполнять определённую работу, а затем передавать сообщение следующему сервису по цепочке. С помощью аттрибута
_Actor_, клиент может определить получателя элемента `header`.

- _MustUnderstand_.

> Этот аттрибут показывает, является ли элемент обязательным или опциональным (`true` – обязательный, `false` – нет).
> Если элемент обязательный, то получатель уведомляется об этом и обрабатывает элемент `header` соответственно указанной
> семантике, либо возвращает ошибку.

Пример:

```xml
<?xml version="1.0"?>

<SOAP-ENV:Envelope xmlns:SOAP-ENV=" http://www.w3.org/2001/12/soap-envelope"
                   SOAP-ENV:encodingStyle=" http://www.w3.org/2001/12/soap-encoding">

    <SOAP-ENV:Header>
        <t:Transaction xmlns:t="http://proselyte.net/tutorials/" SOAP-ENV:mustUnderstand="true">4</t:Transaction>
    </SOAP-ENV:Header>
</SOAP-ENV:Envelope>
```

##### 4.1.2.1.3 Body

> [[_оглавление_]](../README.md/#41-протоколы)

Элемент _SOAP_ сообщения _Body_ является обязательным и содержит предназначенные для передачи _XML_-данные, определяемые
приложением. Этот элемент должен быть помещён внутри элемента _Envelope_ и следовать после элемента _Header_, который
может быть определён в _SOAP_-сообщении.

Элемент _Body_ содержит обязательную информацию, которая предназначена для конечного получателя _SOAP_-сообщения.

Пример:

```xml
<?xml version="1.0"?>

<SOAP-ENV:Envelope>
    <SOAP-ENV:Body>
        <m:GetEducation xmlns:m="http://www.proselyte.net/Education">
            <m:Item>Tutorials</m:Item>
        </m:GetEducation>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope>
```

В примере выше происходит запрос множества _Tutorials_. Элементы `GetEducation` и `Tutorials`, являются элементами,
определёнными приложением, то есть не являются частью стандарта _SOAP_.

Пример ответа:

```xml
<?xml version="1.0"?>

<SOAP-ENV:Envelope>

    <SOAP-ENV:Body>
        <m:GetEducationResponse xmlns:m="http://www.proselyte.net/Education">
            <m:Education>Education</m:Education>
        </m:GetEducationResponse>
    </SOAP-ENV:Body>

</SOAP-ENV:Envelope>
```

Сервис _Education_ может быть реализован на сервере приложения.

Обычно, в приложении также определяется схема, содержащая семантику, которая связана с элементами запроса и ответа.

##### 4.1.2.1.4 Fault

> [[_оглавление_]](../README.md/#41-протоколы)

Элемент _SOAP_-сообщения _Fault_ обрабатывается в случае какой-либо ошибки. Ошибка возвращается отправителю сообщения.

При работе с ошибками в _SOAP_ стоит иметь в виду следующее:

- сообщение _SOAP_ может хранить только один блок `fault`;
- для связывания с _HTTP_, привязаны к статусам от `200` до `299`;
- элемент `fault` не является обязательным для _SOAP_ сообщения;
- коды ошибок _SOAP_ сообщения привязаны к статусам от `500` до `599`.

Под-элементы _Fault_:

- `<faultCode>` - текстовый код, который указывает на тип ошибки;
- `<faultString>` - текстовое сообщение с объяснением ошибки;
- `<faultActor>` - текстовое сообщение, которое указывает, что именно является причиной ошибки (крайне полезно, когда
  _SOAP_-сообщение проходит через несколько элементов (_nodes_) и клиенту необходимо узнать, в каком именно из этих
  узлов произошла ошибка; узел, который не является конечным получателем должен включать в себя элемент `faultActor`);
- `<detail>` - этот элемент используется для хранения специального сообщения об ошибке, которое характерно для
  конкретного приложения (может включать под-элементы `detail entries`).

Коды ошибок _SOAP_ (должны использоваться в элементе `faultCode` для описания ошибки):

- `SOAP-ENV:MustUnderstand` - промежуточный под-элемент элемента _Header_ с аттрибутом `mustUnderstand`, который
  установлен на `1` не был понят;
- `SOAP-ENV:VersionMismatch` - находит неверное пространство имён в элементе _Envelope_;
- `SOAP-ENV:Server` - проблема произошла на сервере, из-за чего сообщение не может быть передано;
- `SOAP-ENV:Client` - сообщение было некорректно сформировано, либо содержало некорректную информацию.

Пример:

```xml
<?xml version='1.0' encoding='UTF-8'?>

<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
                   xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" xmlns:xsd="http://www.w3.org/1999/XMLSchema">
    <SOAP-ENV:Body>
        <SOAP-ENV:Fault>
            <faultcode xsi:type="xsd:string">SOAP-ENV:Client</faultcode>

            <faultstring xsi:type="xsd:string">
                Failed to locate method (ValidateUser) in class (getUser) at
                /usr/local/ActivePerl-4.6/lib/site_perl/4.6.0/SOAP/Lite.pm line 355.
            </faultstring>
        </SOAP-ENV:Fault>
    </SOAP-ENV:Body>

</SOAP-ENV:Envelope>
```

В данном примере клиент отправил запрос с помощью метода _ValidateUser_, но сервис не поддерживает данный метод.

#### 4.1.2.2 Кодировка

> [[_оглавление_]](../README.md/#41-протоколы)

_SOAP_ содержит встроенный набор правил для кодирования различных типов данных, что позволяет _SOAP_-сообщению указывать
такие типы данных, целочисленные, с плавающей точкой и т.д.

Для понимания кодирования в _SOAP_ стоит отметить следующие моменты:

- типы данных _SOAP_ разделены на две категории: скалярные (содержат только одно значение) и составные типы (содержат
  несколько значений и в свою очередь, разделяются на массивы и структуры);
- стиль кодировки задаётся через аттрибут `SOAP-ENV:encodingStyle`;
- для использования кодировки _SOAP 1.1_ используется значение `http://schemas.xmlsoap.org/soap/encoding/`;
- для использования кодировки _SOAP 1.2_ используется значение `https://www.w3.org/2001/12/soap-encoding`;
- крайняя спецификация _SOAP_ включает все встроенные типы, определённые схемой _XML_, а также, поддерживает собственное
  соглашение для определения нестандартизированных схемой _XML_ конструкций, таких как ссылки и массивы.

Список основных скалярных типов _SOAP_

|       **Тип**        |                      **Пример(-ы)**                       |
|:--------------------:|:---------------------------------------------------------:|
|       `string`       |                `Confirm this is electric`                 |
|      `boolean`       |                 `true`, `false`, `1`, `0`                 |
|       `float`        | `-INF`, `-1E4`, `-0`, `0`, `12.78E-2`, `12`, `INF`, `NaN` |
|       `double`       | `-INF`, `-1E4`, `-0`, `0`, `12.78E-2`, `12`, `INF`, `NaN` |
|      `decimal`       |             `-1.23`, `0`, `123.4`, `1000.00`              |
|       `binary`       |                         `100010`                          |
|      `integer`       |            `-126789`, `-1`, `0`, `1`, `126789`            |
| `nonPositiveInteger` |                   `-126789`, `-1`, `0`                    |
|  `negativeInteger`   |                      `-126789`, `-1`                      |
|        `long`        |                  `-1`, `12678967543233`                   |
|        `int`         |                     `-1`, `126789675`                     |
|       `short`        |                       `-1`, `12678`                       |
|        `byte`        |                        `-1`, `126`                        |
| `nonNegativeInteger` |                    `0`, `1`, `126789`                     |
|  `positiveInteger`   |                       `1`, `126789`                       |
|    `unsignedLong`    |                   `0`, `12678967543233`                   |
|    `unsignedInt`     |                     `0`, `1267896754`                     |
|   `unsignedShort`    |                       `0`, `12678`                        |
|    `unsignedByte`    |                        `0`, `126`                         |
|        `date`        |                   `1999-05-31`, `--05`                    |
|        `time`        |           `13:20:00.000`, `13:20:00.000-05:00`            |

Пример:

```xml
<?xml version='1.0' encoding='UTF-8'?>

<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2001/12/soap-envelope"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">

    <SOAP-ENV:Body>
        <ns1:getProuductIdResponse xmlns:ns1="urn:market:productService"
                                   SOAP-ENV:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

            <return xsi:type="xsd:int">1000</return>

        </ns1:getProductIdResponse>
    </SOAP-ENV:Body>

</SOAP-ENV:Envelope>
```

Массивы в _SOAP_ имеют определённый набор правил, которые требуют, чтобы указывался тип данных и размер массива.  
_SOAP_ также поддерживает многомерные массивы, но не все реализации _SOAP_ поддерживают их.

Структуры состоят из нескольких значений, но при этом, каждый элемент имеет уникальный элемент доступа.

Пример:

```xml
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2001/12/soap-envelope"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">

    <SOAP-ENV:Body>
        <ns1:getProductIdListResponse xmlns:ns1="urn:market:productIdService"
                                      SOAP-ENV:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

            <return xmlns:ns2="http://www.w3.org/2001/09/soap-encoding" xsi:type="ns2:Array"
                    ns2:arrayType="xsd:double[2]">
                <item xsi:type="xsd:int">1000</item>
                <item xsi:type="xsd:double">1001</item>
            </return>

        </ns1:getProductIdListResponse>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope> 
```

```xml
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2001/12/soap-envelope"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">

    <SOAP-ENV:Body>
        <ns1:getProductResponse xmlns:ns1="urn:productmarket:productservice"
                                SOAP-ENV:encodingStyle="http://www.w3.org/2001/12/soap-encoding">

            <return xmlns:ns2="urn:productmarket" xsi:type="ns2:product">
                <name xsi:type="xsd:string">Milk</name>
                <price xsi:type="xsd:double">15.60</price>

                <description xsi:type="xsd:string">
                    Very good milk
                </description>
                <ID xsi:type="xsd:string">12345</ID>
            </return>

        </ns1:getProductResponse>
    </SOAP-ENV:Body>
</SOAP-ENV:Envelope>
```

#### 4.1.2.3 Передача

> [[_оглавление_]](../README.md/#41-протоколы)

_SOAP_ не привязан ни к одному из протоколов передачи данных. Сообщение _SOAP_ может быть передано с помощью таких
проколов, как _FTP_, _SMTP_ и т.д.

Чаще всего, запросы _SOAP_ отправляются с помощью _HTTP_-запроса, а ответ _SOAP_ приходит внутри _HTTP_-ответа. Так как
_SOAP_-запрос может быть передан с помощью метода _HTTP_ `GET`, спецификация включает описание только для _HTTP_ `GET`.

В дополнение к этому, и запрос и ответ _HTTP_ требуют установки их типа контента на `text/html`.

Спецификация _SOAP_ требует, чтобы клиент передавал `SOAPAction Header`, но конкретное значение этого элемента зависит
от реализации _SOAP_-сервера.

Например, для получения доступа к сервису _SomeService_, который находится на хостинге _SuperHost_, нам необходимо
указать следующий элемент `header`:

```text
urn:superHostSomeService#SuperService
```

Даже если сервер не требует `SOAPAction header`, клиент должен указать пустую строку, либо значение `null`:

```text
SOAPAction: ""
SOAPAction:
```

Пример запроса, отправленного с помощью _HTTP_ на сервер _SuperHost_ к сервису _SomeService_:

```http request
POST /perl/soaplite.cgi HTTP/1.0
Host: services.superhost.com
Content-Type: text/xml; charset=utf-8
Content-Length: 600
SOAPAction: "urn:superHostSomeService#SuperService"

<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" xmlns:xsd="http://www.w3.org/1999/XMLSchema">

   <SOAP-ENV:Body>
	
      <ns1:SuperService xmlns:ns1="urn:superHostSuperService" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
         <translationmode xsi:type="xsd:string">en_ru</translationmode>
         <sourcedata xsi:type="xsd:string">Hi, Super Host</sourcedata>
      </ns1:SuperService>
		
   </SOAP-ENV:Body>
	
</SOAP-ENV:Envelope>
```

Пример ответа, отправленного с помощью _HTTP_ на сервер _SuperHost_ к сервису _SomeService_:

```http request
HTTP/1.1 200 OK
Date: Mon, 16 May 2016 19:06:57 GMT
Server: Apache/1.3.14 (Unix) tomcat/1.0 PHP/4.0.1pl2
SOAPServer: SOAP::Lite/Perl/0.50
Cache-Control: s-maxage=60, proxy-revalidate
Content-Length: 601
Content-Type: text/xml

<?xml version="1.0" encoding="UTF-8"?>
<SOAP-ENV:Envelope xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/1999/XMLSchema">
   <SOAP-ENV:Body>
	
      <namesp1:SuperServiseResponse xmlns:namesp1="urn:superHostSuperService">
      <return xsi:type="xsd:string">Привет, СуперХост</return>
      </namesp1:SuperServiceResponse>
		
   </SOAP-ENV:Body>
	
</SOAP-ENV:Envelope>
```

Ответ _SOAP_, отправленный с помощью _HTTP_ должен иметь такой же код статуса _HTTP_.
