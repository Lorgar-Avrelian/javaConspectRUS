# 2 Java Core

> [[_оглавление_]](../README.md/#2-java-core)

## 2.1 Память в Java

> [[_оглавление_]](../README.md/#21-память-в-java)

Все данные <u>_вне зависимости от используемого языка программирования_</u> хранятся в виде структур данных.  
[**Структура данных**](/conspect/definitions.md/#с) - это программная единица, позволяющая хранить и обрабатывать
множество однотипных и/или логически связанных данных в вычислительной технике.  
Структур данных существует огромное множество. Самыми популярными из них являются:

- связный список;
- ассоциативный массив;
- стек;
- очередь.

> Более подробное рассмотрение [структур данных](/conspect/02_07.md/#272-структура-данных) смотреть в
> разделе [[2.7 Алгоритмы]](/conspect/02_07.md/#27-алгоритмы).

[**Связный список**](/conspect/definitions.md/#с) - это базовая динамическая структура данных в информатике, состоящая
из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или
предыдущий узел списка.  
В Java структура данных связный список реализован в классе `Linkedlist`.

[**Ассоциативный массив**](/conspect/definitions.md/#а) - это абстрактный тип данных (интерфейс к хранилищу данных),
позволяющий хранить пары вида «ключ-значение» и поддерживающий операции добавления пары, а также поиска и удаления
пары по ключу.  
В Java структура данных ассоциативный массив реализован в классе `Map`.

[**Стек (Stack)**](/conspect/definitions.md/#с) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов и удаление существующих производится с одного конца, называемого
**вершиной стека**.  
В стеке реализован принцип _LIFO_.  
[**LIFO (last-in, first-out)**](/conspect/definitions.md/#l) - это принцип, при котором первым удаляется элемент,
который был помещен туда последним («последним вошел - первым вышел»).

![1.jpeg](/pictures/1.jpeg)

В Java структура данных ассоциативный массив реализован в классе `java.util.Stack`.

[**Очередь (Queue)**](/conspect/definitions.md/#q) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов производится в конец, называемый **хвостом очереди**, а удаление
существующих производится с другого конца, называемого **головой очереди**.  
В очереди реализован принцип _FIFO_.  
[**FIFO (first-in, first-out)**](/conspect/definitions.md/#f) - это принцип, при котором первым удаляется элемент,
который был помещен туда первым («первым вошел - первым вышел»).

![2.png](/pictures/2.png)

В Java структура данных очередь представлена не классом, а интерфейсом - `Queue`.  
Но вместе с тем, очередь в Java - это интерфейс, у которого есть очень много реализаций. Самым распространённым из
используемых субинтерфейсов, реализующих интерфейс `Queue`, является интерфейс `Deque` (двусторонняя очередь).  
Двусторонняя очередь `Deque` расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и
конец очереди) и забирать элементы с обоих краев очереди.

![3.png](/pictures/3.png)

Структуры данных в Java, как и в других объектно-ориентированных языках, хранят примитивы и объекты.  
[Примитивы](/conspect/01_01.md/#112-типизация-переменных) содержат в себе одно значение и не более, за счёт этого они
имеют заранее известный фиксированный размер, интервал допустимых значений и работать с ними быстро и легко.  
[Объекты](/conspect/01_09.md/#191-объекты) могут хранить в себе как какие-то данные (в виде полей), так и методы по
работе с ними. Java не может заранее знать размер объекта, ведь объекты созданных типов могут создаваться и во время
исполнения программы. Потому была придумана система ссылок.

> Ссылка на объект всегда весит 64 бита (для 64-битных систем, которых сейчас абсолютное большинство).

Каждая ссылка ведёт на область в памяти, где лежит объект.

То есть, переменные примитивных типов хранят в себе само значение, а переменные ссылочных типов хранят в себе ссылку на
область памяти, в которой хранится значение объекта.

> Всё в Java передается по значению.  
> В том числе значения переменных в методы. При попадании в метод сущность копирует то, что хранится в ней, свое
> значение. А для объектов значение переменной - это ссылка на объект.

Все объекты имеют значение по умолчанию `null`, которое представляет собой пустоту.  
Примитивы не могут иметь значение `null`, только объекты.  
`null` не является реализацией объекта, потому любая попытка запросить у пустой переменной (`null`) какие-то данные или
вызвать её методы приведет к выбросу исключения (_NullPointerException_ или _NPE_).

### 2.1.1 Стек (Stack)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Стек (Stack)**](/conspect/definitions.md/#s) - это массив, который состоит из ячеек, имеет определённый размер
(количество ячеек) и предоставляет быстрый доступ к своим элементам, так как структурирован и обращение к актуальной
ячейке происходит за константное время.
Этот массив хранит сущности, которые называются _Frame_. Каждый раз, когда вызывается новый метод, в стеке создается
новый фрейм. Как только метод заканчивает выполнение, фрейм удаляется из стека.  
Следовательно, первым фреймом в стеке создается фрейм метода `main`, а затем, когда метод `main` вызывает какой-то
метод, в стеке создается фрейм этого метода и существует до тех пор, пока Java не закончит выполнять код внутри этого
метода.

Примитивы, так как они хранят в себе значение, помещаются во фрейм полностью.  
В случае с объектами во фрейм помещаются только ссылки на объекты, а сами объекты хранятся в куче (_Heap_).

В тот момент, когда память стека заканчивается (количество элементов вышло за границы допустимых для Java-приложения),
приложение будет завершено ошибкой _StackOverflowError_.

> Так как Java позволяет нам писать многопоточные приложения, которые могут вызывать методы параллельно друг другу,
> каждый поток имеет свой собственный стек.  
> Так main-поток имеет в качестве первого фрейма метод `main()`.  
> Другие потоки в качестве первого фрейма имеют тот метод, который был первый выполнен. Обычно это метод `start()`.

### 2.1.2 Куча (Heap)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Куча (Heap)**](/conspect/definitions.md/#h) - это место в памяти, где хранятся объекты.  
Когда создаётся объект через ключевое слово `new`, в куче выделяется место для хранения этого самого объекта.

Куча, в отличие от стека, сама очищать себя не может, потому этим занимается специальная сопрограмма, которая называется
«сборщик мусора» (_garbage collector_), а сам процесс, как ни странно, называется «сборка мусора» (_garbage
collection_).  
Этот процесс анализирует объекты на актуальность и, если приходит к выводу, что объект больше не нужен, удаляет его.  
При переполнении кучи приложение выбрасывает ошибку _OutOfMemoryError_ и завершает работу.

Куча делится на несколько частей. Они созданы для оптимизации сборки мусора:

- два поколения:
    - старое (_Old Generation_);
    - новое (_New Generation_);
- метапространство (_Metaspace_).

![4.png](/pictures/4.png)

Все объекты создаются в новом поколении, и в тот момент, когда эти объекты «переживают» несколько сборок мусора, они
переводятся в старое поколение.  
Метапространство (ранее до 8-й версии Java называлось _Permanent Generation_) хранит в себе метаинформацию о классах, на
основе которых создаются объекты в куче, и статические данные приложения.

### 2.1.3 Сборка мусора (Garbage Collection)

> [[_оглавление_]](../README.md/#21-память-в-java)

[**Сборщик мусора (Garbage Collection)**](/conspect/definitions.md/#g) - это инструмент, который находит все объекты в
коде, недоступные для программиста, и удаляет их.  
В программировании часто используются два подхода для реализации сборки мусора:

- подсчёт ссылок;
- трассировка.

Подсчет ссылок подразумевает, что на каждом объекте есть условный счётчик ссылок. Когда на объект создается новая
ссылка, счётчик увеличивается. Когда ссылка отрабатывает свою задачу и перестаёт быть актуальной, счётчик уменьшается.
При достижении нуля объект помечается мусором и удаляется.

Трассировка встречается чаще, и её идея построена на том, что в определённый момент мы начинаем идти по коду и искать,
какие объекты ещё являются достижимыми в коде дальше. То есть в какой-то момент времени в дальнейшем приложение
обратится к нашему объекту. Эти объекты остаются «жить».

Сборка мусора представляет собой процесс, когда Java анализирует кучу на предмет «мёртвых» объектов и удаляет их.  
Именно трассировка и используется в Java. Хотя этот подход и является более сложным и ресурсоёмким, он обеспечивает
большую надёжность.  
Процесс трассировки делится на два этапа:

- Mark (маркировка) - сборщик мусора отмечает недостижимые объекты в качестве мусора;
- Sweep (уборка) - объекты, отмеченные мусором на прошлой стадии, удаляются, освобождая место в куче.

В Java существует несколько реализаций сборщиков мусора.  
Какой из них запускать, выбирает разработчик с помощью специального флага при запуске приложения.

#### 2.1.3.1 Serial GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данный сборщик мусора является классической и самой простой реализацией. _Serial GC_ использует один поток и отлично
подходит для работы в приложениях на клиентской стороне (пользовательские ПК), где нет жестких требований к минимизации
остановок приложения и ресурсы ограничены.

#### 2.1.3.2 Parallel GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Отличается от _Serial GC_ использованием нескольких потоков, но также останавливает приложение в ходе сборки мусора.  
Является выбором по умолчанию во многих JVM.

#### 2.1.3.3 CMS (Concurrent Mark Sweep) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация делит ресурсы с приложением, замедляя его работу, но позволяет минимизировать остановки приложения во
время сборки мусора.  
В 9-й версии Java был помечен устаревшим и в 14-й полностью удален.

#### 2.1.3.4 G1 (Garbage First) GC

> [[_оглавление_]](../README.md/#21-память-в-java)

Данная реализация пришла на смену _CMS_. Отличия в том, что данный сборщик мусора делит кучу на равные части и маркирует
их на предмет общей «жизнеспособности». На фазе сборки мусора в первую очередь очищаются наиболее заполненные области,
освобождая максимальный объем памяти.

### 2.1.4 Жизненный цикл приложения

> [[_оглавление_]](../README.md/#21-память-в-java)

В основе программирования на Java лежат три основные технологии:

- _JVM_ отвечает за исполнение Java-программ;
- _JRE_ создаёт и запускает _JVM_;
- _JDK_ позволяет разработчикам создавать программы, которые могут выполняться и запускаться посредством _JVM_ и _JRE_.

Различие между _JDK_ и _JRE_ заключается в том, что _JDK_ представляет собой пакет инструментов для разработки
программного обеспечения, тогда как _JRE_ представляет собой пакет инструментов для запуска Java-кода.  
То есть, жизненный цикл приложения начинается с написания кода с использованием _JDK_.

#### 2.1.4.1 JDK, JRE, JVM

> [[_оглавление_]](../README.md/#21-память-в-java)

[**JDK (Java Development Kit)**](/conspect/definitions.md/#j) - это набор инструментов для разработки на языке Java.

В ходе разработки программист вынужден многократно производить запуск приложения. За запуск приложения отвечает _JRE_.

[**JRE (Java Runtime Environment)**](/conspect/definitions.md/#j) - это набор инструментов для запуска программы на
языке Java.  
_JRE_ может использоваться, как отдельный компонент для простого запуска Java-программ, либо быть частью _JDK_. _JDK_
требуется _JRE_, потому что запуск программ является неотъемлемой частью их разработки.

![62.png](../pictures/62.png)

Далее происходит сборка проекта.  
В этот момент **IDEA** подтягивает все указанные вами зависимости, затем производит процесс компиляции вашего кода.  
На этом моменте компилятор Java производит анализ кода, оптимизирует его и транслирует из того кода на английском языке,
что вы пишете в файлах Java, в байт-код, который уже достаточно тяжело читать человеку, и сохраняет его в файлы формата
_class_.  
Если компилятор находит ошибку в коде (например, вы где-то пропустили), компиляция останавливается, и вы видите много
красного текста в вашей консоли.
Обычно там указывается текст ошибки и строка файла, где эта ошибка была найдена.
**IDEA** подсвечивает эту строку синим, делая её ссылкой, по нажатию на которую можно перейти в то место, где была
ошибка.
В тот момент, когда все необходимые файлы формата _class_ сформированы, а формируются они в таком соотношении: 1
Java-файл преобразуется в 1 class-файл - **JVM** получает возможность запустить ваш код.

[**JVM (Java Virtual Machine)**](/conspect/definitions.md/#j) в упрощенном представлении является программой, которая
читает этот самый байт-код и транслирует его в машинные инструкции, которые уже понимает процессор.  
Именно за счёт **JVM** у приложений на Java появилась одна из киллер-фич, а именно: мультиплатформенность. Компилятор
может быть один, его задача - сформировать на основе Java-кода байт-код и записать его в _class_-файлы.  
Ответственность за запуск приложения ложится на JVM, которые уникальны для каждого типа систем (_Windows_, _Linux_,
_Android_, _iOS_, умный дом), ведь их архитектура отличается.  
Если вы хотите, чтобы ваш код выполнялся на абсолютно новой системе, вам необходимо написать реализацию **JVM** под эту
новую систему (будь это умная лампочка, кофеварка или холодильник), и Java-приложения будут запускаться на этой системе.

Если суммировать, то **JVM** отвечает за запуск вашего приложения. Она управляет памятью, управляет (просит операционную
систему) созданием потоков для многопоточных приложений, осуществляет сборку мусора и так далее.

Так как передавать сотни и сотни class-файлов было бы накладным и неудобным, их принято объединять в архивы в формате
_jar_, где в конфигурации прописан класс с методом `main`, который запускает приложение.  
Этот архив тоже запускается с помощью **JVM**.

#### 2.1.4.2 Основные настройки JVM

> [[_оглавление_]](../README.md/#21-память-в-java)

Для настройки параметров запуска приложения можно задавать параметры _JVM_.

|                               **Параметр**                               | **Значение**                                                                                                                                                  |                                                                                                **Примечание**                                                                                                |
|:------------------------------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|             <pre lang="shell"> -Xms<heap size>[unit] </pre>              | устанавливает минимальный размер кучи для _JVM_                                                                                                               |                                            Пример:<br> <pre lang="shell"> -Xms256m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ                                             |
|             <pre lang="shell"> -Xmx<heap size>[unit] </pre>              | устанавливает максимальный размер кучи для _JVM_                                                                                                              |                                             Пример:<br> <pre lang="shell"> -Xmx5G </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ                                              |
|             <pre lang="shell"> -Xss<stack size>[unit] </pre>             | устанавливает размер стека потоков для внутреннего использования каждого потока                                                                               |                                             Пример:<br> <pre lang="shell"> -Xss16m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ                                             |
|  <pre lang="shell"> -XX:MaxMetaspaceSize=<metaspace size>[unit] </pre>   | устанавливает размер _Metaspace_                                                                                                                              | Пример:<br> <pre lang="shell"> -XX:MaxMetaspaceSize=16m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ, в зависимости от платформы устанавливается в диапазоне от 12 до 20 МБ |
|         <pre lang="shell"> -XX:NewSize=<young size>[unit] </pre>         | устанавливает минимальный размер пространства _Young Generation_                                                                                              |                          Пример:<br> <pre lang="shell"> -XX:NewSize=1310m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ, по умолчанию равен 1310 МБ                          |
|       <pre lang="shell"> -XX:MaxNewSize=<young size>[unit] </pre>        | устанавливает максимальный размер пространства _Young Generation_                                                                                             |                        Пример:<br> <pre lang="shell"> -XX:MaxNewSize=2620m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ, по умолчанию не установлен                         |
|         <pre lang="shell"> -XX:PermSize=<perm size>[unit] </pre>         | устанавливает минимальный размер пространства _Permanent Generation_                                                                                          |                                        Пример:<br> <pre lang="shell"> -XX:PermSize=256m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ                                        |
|       <pre lang="shell"> -XX:MaxPermSize=<perm size>[unit] </pre>        | устанавливает максимальный размер пространства _Permanent Generation_                                                                                         |                                      Пример:<br> <pre lang="shell"> -XX:MaxPermSize=256m </pre><br>где единицами измерения являются `G` для ГБ,`m` для МБ и `k` для кБ                                       |
|           <pre lang="shell"> -XX:SurvivorRatio=<ratio> </pre>            | устанавливает соотношение пространства _Edem_ и пространства _Survivor_                                                                                       |                                                                         Пример:<br> <pre lang="shell"> -XX:SurvivorRatio=128 </pre>                                                                          |
|    <pre lang="shell"> -XX:MaxTenuringThreshold=<survivor age> </pre>     | устанавливает максимальный возраст объектов в пространстве _Survivor_                                                                                         |                                                                       Пример:<br> <pre lang="shell"> -XX:MaxTenuringThreshold=0 </pre>                                                                       |
|            <pre lang="shell"> -XX:+UseThreadPriorities </pre>            | указывает _JVM_ использовать собственные приоритеты потоков                                                                                                   |                                                                        Пример:<br> <pre lang="shell"> -XX:+UseThreadPriorities </pre>                                                                        |
|             <pre lang="shell"> -XX:+UseCompressedOops </pre>             | указывает _JVM_ использовать сжатые указатели объектов для сокращения использования памяти                                                                    |                                                                         Пример:<br> <pre lang="shell"> -XX:+UseCompressedOops </pre>                                                                         |
|                <pre lang="shell"> -XX:+UseSerialGC </pre>                | указывает _JVM_ использовать _Serial GC_ в качестве сборщика мусора                                                                                           |                                                                            Пример:<br> <pre lang="shell"> -XX:+UseSerialGC </pre>                                                                            |
|                  <pre lang="shell"> -XX:+UseG1GC </pre>                  | указывает _JVM_ использовать _G1 GC_ в качестве сборщика мусора                                                                                               |                                                                              Пример:<br> <pre lang="shell"> -XX:+UseG1GC </pre>                                                                              |
|                  <pre lang="shell"> -XX:+UseZGC </pre>                   | указывает _JVM_ использовать _Z-GC_ в качестве сборщика мусора                                                                                                |                                                                              Пример:<br> <pre lang="shell"> -XX:+UseZGC </pre>                                                                               |
|               <pre lang="shell"> -XX:+UseParallelGC </pre>               | указывает _JVM_ использовать _Parallel GC_ в качестве сборщика мусора                                                                                         |                                                                           Пример:<br> <pre lang="shell"> -XX:+UseParallelGC </pre>                                                                           |
|                <pre lang="shell"> -XX:+USeParNewGC </pre>                | указывает _JVM_ использовать _CMS_ в качестве сборщика мусора                                                                                                 |                                                                            Пример:<br> <pre lang="shell"> -XX:+USeParNewGC </pre>                                                                            |
|              <pre lang="shell"> -XX:+PrintGCDetails </pre>               | указывает _JVM_ распечатать подробные журналы сборки мусора, чтобы помочь с оптимизацией сборки мусора                                                        |                                                                          Пример:<br> <pre lang="shell"> -XX:+PrintGCDetails </pre>                                                                           |
|           <pre lang="shell"> -XX:+UseGCLogFileRotation </pre>            | указывает _JVM_ использовать политику обновления журнала работы _GC_                                                                                          |                                                                       Пример:<br> <pre lang="shell"> -XX:+UseGCLogFileRotation </pre>                                                                        |
|  <pre lang="shell"> -XX:NumberOfGCLogFiles=<number of log files> </pre>  | указывает _JVM_ количество _log_-файлов журнала работы _GC_                                                                                                   |                                                                       Пример:<br> <pre lang="shell"> -XX:NumberOfGCLogFiles=10 </pre>                                                                        |
|      <pre lang="shell"> -XX:GCLogFileSize=<file size>[unit] </pre>       | указывает _JVM_ размер _log_-файлов журнала работы _GC_                                                                                                       |                                                                         Пример:<br> <pre lang="shell"> -XX:GCLogFileSize=50m </pre>                                                                          |
|            <pre lang="shell"> -Xloggc:<path to gc.log> </pre>            | указывает _JVM_ путь для _log_-файлов журнала работы _GC_                                                                                                     |                                                                          Пример:<br> <pre lang="shell"> -Xloggc:/logs/gc.log </pre>                                                                          |
|             <pre lang="shell"> -XX:+PrintGCTimeStamps </pre>             | указывает _JVM_ печатать временные метки в журнале работы _GC_                                                                                                |                                                                         Пример:<br> <pre lang="shell"> -XX:+PrintGCTimeStamps </pre>                                                                         |
|             <pre lang="shell"> -XX:+PrintGCDateStamps </pre>             | указывает _JVM_ печатать временные метки в журнале работы _GC_                                                                                                |                                                                         Пример:<br> <pre lang="shell"> -XX:+PrintGCDateStamps </pre>                                                                         |
|        <pre lang="shell"> -XX:+HeapDumpOnOutOfMemoryError </pre>         | сообщает _JVM_ о необходимости создания файла дампа кучи при возникновении ошибки _OutOfMemoryError_                                                          |                                                                    Пример:<br> <pre lang="shell"> -XX:+HeapDumpOnOutOfMemoryError </pre>                                                                     |
|   <pre lang="shell"> -XX:HeapDumpPath=<path to heap dump file> </pre>    | предоставляет _JVM_ пользовательский путь для записи содержимого кучи во время дампа кучи                                                                     |                                                                  Пример:<br> <pre lang="shell"> -XX:HeapDumpPath=./dump/<pid>.hprof </pre>                                                                   |
| <pre lang="shell"> -XX:OnOutOfMemoryError="<cmd args>;<cmd args>" </pre> | сообщает _JVM_ какие команды должны быть выполнены в случае возникновении ошибки _OutOfMemoryError_                                                           |                                                                  Пример:<br> <pre lang="shell"> -XX:OnOutOfMemoryError="shutdown -r" </pre>                                                                  |
|            <pre lang="shell"> -XX:+UseGCOverheadLimit </pre>             | сообщает _JVM_, что необходимо ограничить долю времени виртуальной машины, затрачиваемого на сборку мусора, прежде чем будет выдана ошибка _OutOfMemoryError_ |                                                                        Пример:<br> <pre lang="shell"> -XX:+UseGCOverheadLimit </pre>                                                                         |
|                   <pre lang="shell"> -d<OS bit> </pre>                   | устанавливает для _JVM_ разрядность используемого пакета                                                                                                      |                                    Пример:<br> <pre lang="shell"> -d64 </pre><br>в среде ОС, где установлены как 32-, так и 64-разрядные пакеты (выбираются по умолчанию)                                    |
|         <pre lang="shell"> -XX:+PrintFlagsFinal -version </pre>          | выводит на экран все текущие настроенные флаги и параметры, установленные на _JVM_                                                                            |                                                                     Пример:<br> <pre lang="shell"> -XX:+PrintFlagsFinal -version </pre>                                                                      |

Пример использования:

```shell
java -jar MyApp -XX:MaxPermSize=128m  -XX:MaxNewSize=256m -Xms768m -Xmx768m -XX:SurvivorRatio=128 -XX:MaxTenuringThreshold=0
```

### 2.1.5 Типы ссылок на объекты

> [[_оглавление_]](../README.md/#21-память-в-java)

Все _java_-разработчики, рано или поздно, встречаются с пресловутой ошибкой `OutOfMemoryError` (нехватка памяти).
Начиная с версии 1.2, в _Java_ появился пакет `java.lang.ref.*` с классами _SoftReference_, _WeakReference_ и
_PhantomReference_, которые помогают в регулировании используемой памяти.

В Java существует четыре типа ссылок:

- сильная ссылка (_Strong Reference_) - прямая ссылка на объект, которая препятствует его удалению из памяти до тех
  пор, пока не останется ссылок на данный объект из других объектов, он не станет равным `null`, или не произошёл выход
  за пределы области видимости, в которой данный объект существует;

```java
public static void main(String[] args) {
    Object object = new Object(); // создание сильной ссылки на объект
    object = null;                // зануление объекта
    System.gc();                  // обращение к сборщику мусора, который может очистить память и удалить объект
}
```

- мягкая ссылка (_Soft Reference_) - ссылка, которая препятствует удалению объекта до тех пор, пока памяти достаточно,
  но в случае её нехватки, ссылка на объект и сам объект будут удалены;

```java
import java.lang.ref.SoftReference;
import java.util.ArrayList;

public static void main(String[] args) {
    SoftReference<Object> softReference = new SoftReference<>(new Object()); // создание мягкой ссылки на объект
    Object object = softReference.get();                                     // получение объекта по мягкой ссылке (при этом
    //                                                                       // создаётся сильная ссылка, чего при применении
    //                                                                       // как раз делать не надо)
    if (object == null) {                                                    // ВНИМАНИЕ! проверка, не удалён ли объект при
        object = new Object();                                               // предыдущей сборке мусора 
    }
    List<Integer> list = new ArrayList<>();                                  // имитация заполнения памяти
    for (int i = 0; i < 1_000_000; i++) {
        list.add(i);
    }
    System.gc();                                                             // обращение к сборщику мусора, который может очистить 
    //                                                                       // память и удалить объект
}
```

- слабая ссылка (_Weak Reference_) - ссылка, которая не препятствует удалению объекта при сборке мусора: объект будет
  удалён из памяти при следующем же запуске сборщика мусора;

```java
import java.lang.ref.WeakReference;

public static void main(String[] args) {
    WeakReference<Object> weakReference = new WeakReference<>(new Object()); // создание слабой ссылки на объект
    Object object = weakReference.get();                                     // получение объекта по мягкой ссылке (при этом
    //                                                                       // создаётся сильная ссылка, чего при применении
    //                                                                       // как раз делать не надо)
    if (object == null) {                                                    // ВНИМАНИЕ! проверка, не удалён ли объект при
        object = new Object();                                               // предыдущей сборке мусора 
    }
    System.gc();                                                             // обращение к сборщику мусора, который может очистить 
    //                                                                       // память и удалить объект
}
```

> Слабые ссылки часто используются в `WeakHashMap`, данные значений для этого ассоциативного массива очищаются из памяти
> сразу после удаления их ключа.
>
> ```java
> Map<Object, WeakReference<Object>> map = new WeakHashMap<>();
> ```

- фантомная ссылка (_Phantom Reference_) - ссылка на удалённый объект (после удаления объекта ссылка на него помещается
  в очередь, без которой создать фантомную ссылку невозможно).

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

public static void main(String[] args) {
    Object object = new Object();                                                               // создание сильной ссылки на объект
    ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();                             // создание очереди для ссылок на удалённые объекты,
    //                                                                                          // которая заполняется только ПОСЛЕ их очистки
    PhantomReference<Object> phantomReference = new PhantomReference<>(object, referenceQueue); // создание фантомной ссылки на удалённый объект (в момент
    //                                                                                          // создания ссылки объект помечается сборщиком мусора 
    //                                                                                          // на удаление, и будет очищен в любом случае)
}
```
