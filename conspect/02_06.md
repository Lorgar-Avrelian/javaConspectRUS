## 2.6 Java Collections Framework

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Коллекция (Collection)**](/conspect/definitions.md/#к) - это объект, который хранит в себе набор других однотипных
объектов, а также позволяет получить к ним доступ с помощью своих методов.

![16.png](/pictures/16.png)

Все коллекции наследуются от интерфейса _Iterable_, позволяющего проходить по всем значениям коллекций, которые
используют этот интерфейс (итерироваться).  
Интерфейс _Iterable_ наследует интерфейс _Collection_, который в свою очередь наследуют уже более узкие структуры:
списки (_List_), множества (_Set_) и очереди (_Queue_).

Особняком стоит интерфейс _Map_.  
[**Map**](/conspect/definitions.md/#m) - это структура хранения данных в формате «ключ-значение».

Отличия коллекций от массивов:

- коллекции могут хранить свои данные в массиве (_ArrayList_) или связывать объекты друг с другом, создавая определённый
  порядок (_LinkedList_), а могут и наоборот - не иметь порядка внутри и напоминать что-то вроде «кучи» или «мешанины»
  из объектов (_HashSet_);
- коллекции сами следят за количеством заполненных ячеек или связанных объектов и сами расширяются;
- коллекции имеют свои методы, которые можно использовать, переопределять и наследовать.

Так как коллекции являются полноценными объектами, в них переопределён метод `toString()`.  
Итерироваться по коллекциям можно с помощью [циклов](/conspect/1.md/#13-циклы).

За тип данных, которые находятся в коллекции, отвечает механизм дженериков.

### 2.6.1 Класс Collections

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Класс _Collections_ представляет собой аналог класса _Arrays_ в отношении массивов. В нём собраны различные статические
методы, позволяющие выполнять шаблонные операции над коллекциями.

#### 2.6.1.1 fill()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `fill()` класса `Collections` заполняет коллекцию одинаковыми значениями.  
Синтаксис метода выглядит следующим образом:

```java 
Collections.fill([имя_коллекции], [значение]);
```

Первым параметром передаётся имя коллекции, а вторым – значение, которым её надо заполнить.  
Данный метод заполнит коллекцию значениями по размеру коллекции.

#### 2.6.1.2 max()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `max()` класса `Collections` применяется для нахождения максимального значения в коллекции.  
Синтаксис метода выглядит следующим образом:

```java 
Collections.max([имя_коллекции]);
```

Данный метод возвращает из коллекции максимальное значение из тех, которые она содержит, того типа, которым коллекция
проинициализирована.

#### 2.6.1.3 min()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `min()` класса `Collections` применяется для нахождения минимального значения в коллекции.  
Синтаксис метода выглядит следующим образом:

```java 
Collections.min([имя_коллекции]);
```

Данный метод возвращает из коллекции минимальное значение из тех, которые она содержит, того типа, которым коллекция
проинициализирована.

#### 2.6.1.4 copy()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `copy()` класса `Collections` применяется для копирования значений из одной коллекции в другую.  
Синтаксис метода выглядит следующим образом:

```java 
Collections.copy([имя_коллекции-источника], [имя_коллекции-назначения]);
```

Данный метод копирует содержимое одной коллекции в другую.

#### 2.6.1.5 binarySearch()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `binarySearch()` класса `Collections` применяется для [бинарного поиска](/conspect/02_07.md/#2735-бинарный-поиск)
элемента по значению.  
Синтаксис метода выглядит следующим образом:

```java 
Collections.binarySearch([имя_коллекции], [искомое_значение]);
```

Данный метод возвращает индекс искомого элемента.

### 2.6.2 Дженерики (Параметрический полиморфизм)

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Дженерики (Обобщения)**](/conspect/definitions.md/#д) - это функциональность Java, позволяющая создавать
универсальный код, который может быть использован для разных типов данных, и уточнять этот тип тогда, когда нужно.  
Дженерики используются для создания обобщенных классов, интерфейсов и методов, которые могут работать с различными
типами данных.  
Параметризованные типы проясняют, с каким типом данных будет работать класс или метод.

Чтобы объявить дженерик, нужно создать параметризованный класс, для чего обобщённый тип необходимо поместить в
diamond-скобки (`< >`).

[**Параметризованный класс**](/conspect/definitions.md/#п) - это класс, который может быть создан с помощью параметра
типа. Вместо конкретного типа данных параметризованный класс использует обобщенный тип, который определяется во время
создания экземпляра класса.

> В качестве параметра в дженериках нельзя указывать примитивы. Это ограничение обусловлено тем, что разработчиками
> языка Java в дженериках не были реализованы автоупаковка и автораспаковка (боксинг и анбоксинг).

Параметризованные классы используются для упрощения кода в ситуациях, когда методы класса могут применяться для работы с
переменными различных типов.

Пример использования - создание класса-хранилища для значений разных типов:

- модель:

```java
package javaCore.models;

import java.util.Objects;

public class VariableContainer<T extends Object> {
    private T value;

    public VariableContainer(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        VariableContainer<?> that = (VariableContainer<?>) o;
        return Objects.equals(value, that.value);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(value);
    }

    @Override
    public String toString() {
        return "VariableContainer{" +
                "value=" + value +
                '}';
    }
}
```

- применение:

```java
private static void genericExample() {
    List<VariableContainer> values = new ArrayList<>();
    VariableContainer<Byte> var1 = new VariableContainer((byte) 1);
    VariableContainer<Short> var2 = new VariableContainer((short) 1_000);
    VariableContainer<Integer> var3 = new VariableContainer(1_000_000);
    VariableContainer<Long> var4 = new VariableContainer(1_000_000_000_000L);
    VariableContainer<Float> var5 = new VariableContainer(2_000_000.0f);
    VariableContainer<Double> var6 = new VariableContainer(2_000_000_000_000.0);
    VariableContainer<Character> var7 = new VariableContainer('A');
    VariableContainer<Boolean> var8 = new VariableContainer(true);
    VariableContainer<String> var9 = new VariableContainer("String");
    values.add(var1);
    values.add(var2);
    values.add(var3);
    values.add(var4);
    values.add(var5);
    values.add(var6);
    values.add(var7);
    values.add(var8);
    values.add(var9);
    for (int i = 0; i < values.size(); i++) {
        switch (values.get(i).getValue().getClass().getSimpleName()) {
            case ("Byte"):
                System.out.println("Byte value is " + values.get(i).getValue());
                break;
            case ("Short"):
                System.out.println("Short value is " + values.get(i).getValue());
                break;
            case ("Integer"):
                System.out.println("Integer value is " + values.get(i).getValue());
                break;
            case ("Long"):
                System.out.println("Long value is " + values.get(i).getValue());
                break;
            case ("Float"):
                System.out.println("Float value is " + values.get(i).getValue());
                break;
            case ("Double"):
                System.out.println("Double value is " + values.get(i).getValue());
                break;
            case ("Character"):
                System.out.println("Character value is " + values.get(i).getValue());
                break;
            case ("Boolean"):
                System.out.println("Boolean value is " + values.get(i).getValue());
                break;
            case ("String"):
                System.out.println("String value is " + values.get(i).getValue());
                break;
            default:
                System.out.println("Unknown value type " + values.get(i).getValue().getClass());
        }
    }
}
```

В Java можно создавать **ограниченные типы (bounded type)**, которые нужны, чтобы предотвратить ошибки времени
выполнения, связанные с использованием неправильных типов. Ограниченные типы позволяют указать, какие типы могут быть
использованы в качестве параметров для обобщенных классов или методов, а какие - нет.  
Параметр типа можно ограничить классом-предком. В этом случае нужно использовать ключевое слово `extends`.

Например:

```java
class NullBox<Т extends Number>
// В данном случае класс Printer сможет использовать только классы,
// наследующиеся от PrintedMaterial или сам класс PrintedMaterial.
```

Можно также комбинировать типы ограничений. В этом случае ограничители нужно перечислять через
разделитель-амперсанд (`&`).

> В ограничителях нужно указать тип класса, а после него - интерфейсы.

Например:

```java
class Printer<T extends Number & Serializable> {
// Можно использовать в качестве параметра типа класс PrintedMaterial
// или его наследников, а также объекты, реализующие интерфейс Printable.
}
```

### 2.6.3 Список (List)

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Список (List)**](/conspect/definitions.md/#l) - это последовательность элементов в определенном порядке.  
Его реализует интерфейс `List` пакета `java.util`.

Особенности списков:

- могут иметь повторяющиеся элементы;
- могут содержать элементы `null`;
- в списке могут быть элементы разных дочерних типов или элементы, реализующие один интерфейс;
- всегда сохраняют порядок вставки и предоставляют доступ к элементам по индексу;
- к элементам списка можно получить доступ, используя индексы, начиная с `0`.

Интерфейс `List` реализуют классы `ArrayList`, `LinkedList`, `Vector` и `Stack` (который наследуется от `Vector`).

#### 2.6.3.1 ArrayList

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**ArrayList**](/conspect/definitions.md/#a) - это список, аналогичный массиву.

При создании объекта `ArrayList` создается массив. По умолчанию размер такого списка равен 10 и он заполнен
элементами `0`, `0.0`, `false` или `null`.  
Каждый раз, когда свободные ячейки заканчиваются, коллекция создает новый массив длиной чуть больше предыдущего.

На длину нового массива действует два фактора:

- количество минимально необходимых ячеек;
- фактор роста (обычно увеличение должно происходить не меньше чем в полтора раза).

Элементы из старого массива копируются в новый массив в том же порядке.

##### 2.6.3.1.1 add()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `add()` класса `ArrayList` применяется для добавления значений в список.  
Синтаксис метода выглядит следующим образом:

`list.add([значение]);`
`list.add([индекс_ячейки], [значение]);`

Данный метод по умолчанию добавляет значение в конец списка, а при указании индекса - в ячейку с указанным индексом (при
этом все другие значения в списке сдвигаются на единицу).

Например:

```java
private static void listExample() {
    List<Integer> arrayList = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    arrayList.add(11);
    System.out.println(arrayList);
    arrayList.add(5, 0);
    System.out.println(arrayList);
}
```

##### 2.6.3.1.2 get()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `get()` класса `ArrayList` применяется для получения значения с указанным индексом из списка.  
Синтаксис метода выглядит следующим образом:

`[тип_значения] variable = list.get([индекс_значения]);`

Данный метод возвращает значение, содержащееся в списке по указанному индексу, само значение из списка при этом не
удаляется.  
В случае, если значение по указанному индексу в списке не найдено, будет выброшена ошибка _IndexOutOfBoundsException_.

##### 2.6.3.1.3 set()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `set()` класса `ArrayList` применяется для изменения значения по указанному индексу в списке.  
Синтаксис метода выглядит следующим образом:

`list.set([индекс_значения], [новое_значение]);`

Данный метод перезаписывает значение в ячейке по указанному индексу.  
В случае, если значение по указанному индексу в списке не найдено, будет выброшена ошибка _IndexOutOfBoundsException_.

##### 2.6.3.1.4 size()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `size()` класса `ArrayList` применяется для получения значения длины списка.  
Синтаксис метода выглядит следующим образом:

```java
int size = list.size();
```

Данный метод возвращает значение длины списка типа `int`.

##### 2.6.3.1.5 contains()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `contains()` класса `ArrayList` применяется для определения наличия указанного значения.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = list.contains([значение]);
```

Данный метод возвращает `true`, если значение найдено, и `false` - если нет.

##### 2.6.3.1.6 remove()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `remove()` класса `ArrayList` применяется для удаления из списка значения с указанным индексом (по умолчанию) или
равного указанному.  
Синтаксис метода выглядит следующим образом:

```java
list.remove([индекс_элемента]);
```

Данный метод удаляет из списка значение с указанным индексом или равное указанному (при этом все другие значения в
списке сдвигаются на единицу).  
В случае, если значение по указанному индексу в списке не найдено, будет выброшена ошибка _IndexOutOfBoundsException_.

##### 2.6.3.1.7 clear()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `clear()` класса `ArrayList` применяется для удаления из списка всех значений.  
Синтаксис метода выглядит следующим образом:

```java
list.clear();
```

Данный метод удаляет из списка все значения (в результате размер списка становится равным нулю).

##### 2.6.3.1.8 addAll()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `addAll()` класса `ArrayList` применяется для добавления всех значений из коллекции в текущий список.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = list.addAll([копируемая_коллекция]);
```

Данный метод добавляет в список все значения, содержащиеся и в порядке в копируемой коллекции. При этом в случае
успешного копирования метод возвращает `true`, иначе - `false`.

##### 2.6.3.1.9 indexOf()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `indexOf()` класса `ArrayList` применяется для поиска индекса первого вхождения элемента в списке.  
Синтаксис метода выглядит следующим образом:

```java
int i = list.indexOf([значение]);
```

Данный метод возвращает индекс первого совпадающего с указанным значения. Если элемента не существует в списке, метод
вернет `-1`.

##### 2.6.3.1.10 isEmpty()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `isEmpty()` класса `ArrayList` применяется для определения наличия в списке не нулевых элементов.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = list.isEmpty();
```

Данный метод возвращает `true`, если в списке содержится хотя бы один элемент, значение которого не равно `null`,
иначе - `false`.

##### 2.6.3.1.11 sort()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `sort()` класса `ArrayList` применяется для сортировки элементов списка по заданному правилу, передаваемому в
компараторе.  
Синтаксис метода выглядит следующим образом:

```java
list.sort([компаратор]);
```

Данный метод осуществляет сортировку элементов списка, не изменяя его размера.

Например:

```java
private static void listExample() {
    List<Integer> arrayList = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    arrayList.sort(Comparator.reverseOrder());
    System.out.println(arrayList);
}
```

##### 2.6.3.1.12 toArray()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `toArray()` класса `ArrayList` применяется для преобразования списка в массив объектов.  
Синтаксис метода выглядит следующим образом:

```java
Object[] o = list.toArray([объявление_массива]);
```

Данный метод возвращает массив объектов того же размера и типа, которыми проинициализирован список.

Например:

```java
private static void listExample() {
    List<Integer> arrayList = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    Integer[] intArray = arrayList.toArray(new Integer[arrayList.size()]);
    System.out.println(Arrays.toString(intArray));
}
```

#### 2.6.3.2 LinkedList

> [[_оглавление_]](../README.md/#26-java-collections-framework)

В основе _LinkedList_ лежит объект `Node`. Он имеет поля, которые соответствуют следующему элементу, предыдущему
элементу и значению.  
Сам объект `LinkedList` знает о существовании только первого и последнего элементов списка.

![17.png](/pictures/17.png)

В момент добавления элемента в `LinkedList` происходит следующее:

- создает объект `Node`;
- в него укладывается нужный элемент;
- объект `Node` встраивается в цепочку из объектов списка, заполняя поля `Node` внутри ссылками на прошлый элемент и
  следующий (двусвязный список).

Удаление элементов `Node` производится путём копирования ссылок двух соседних элементов друг на друга и обнулением этих
ссылок у текущего `Node`, в результате чего текущий элемент оказывается отрезанным от соседей и удаляется сборщиком
мусора при следующем прохождении.

Поиск элемента в `LinkedList` производится последовательным перебором всех элементов.

#### 2.6.3.3 Разница между ArrayList и LinkedList

> [[_оглавление_]](../README.md/#26-java-collections-framework)

|     **_Параметр_**      |      **_ArrayList_**      |       **_LinkedList_**        |
|:-----------------------:|:-------------------------:|:-----------------------------:|
|      _Манипуляции_      |         Медленнее         |            Быстрее            |
|        _Доступ_         |          Быстрее          |           Медленнее           |
|      _Реализация_       |       Только список       |      И список, и очередь      |
| _Внутренняя реализация_ |    Динамический массив    |       Двусвязный список       |
|      _Применение_       | При частом поиске/ чтении | При частых вставках/удалениях |

| **_Операция_**          | **_ArrayList_** | **_LinkedList_** |
|:------------------------|:---------------:|:----------------:|
| _add (в начало)_        |      O(n)       |       O(1)       |
| _add (в середину)_      |      O(n)       |       O(n)       |
| _add (в конец)_         |      O(n)       |       O(1)       |
| ----------------------- |  -------------  |  --------------  |
| _get (начало)_          |      O(1)       |       O(1)       |
| _get (середина)_        |      O(1)       |       O(n)       |
| _get (конец)_           |      O(1)       |       O(1)       |
| ----------------------- |  -------------  |  --------------  |
| _remove (из начала)_    |      O(n)       |       O(1)       |
| _remove (из середины)_  |      O(n)       |       O(n)       |
| _remove (из конца)_     |      O(1)       |       O(1)       |

### 2.6.4 Iterator

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Iterator**](/conspect/definitions.md/#i) - это механизм доступа к элементам коллекции без необходимости раскрытия ее
внутренней структуры; универсальный способ перебора элементов независимо от типа коллекции и способа ее реализации.

Итераторы позволяют перебирать элементы коллекции без знания о ее внутренней структуре или реализации. Они обеспечивают
абстракцию над коллекцией и предоставляют удобный способ последовательного доступа к ее элементам и применяются для
операций изменения коллекции в момент прохода по ней.

Пример:

```java
private static void iteratorExample() {
    List<Integer> arrayList = new ArrayList<>(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
    Iterator<Integer> iterator = arrayList.iterator();
    while (iterator.hasNext()) {
        if (iterator.next() % 2 == 0) {
            iterator.remove();
        }
    }
    System.out.println(arrayList);
}
```

### 2.6.5 Множество (Set)

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Множество (Set)**](/conspect/definitions.md/#s) - это последовательность уникальных однотипных элементов в
определенном порядке.

Интерфейс `Set` является абстрактным и не может быть создан напрямую с помощью оператора `new`. Для создания
экземпляра `Set` нужно создать одну из его реализаций: `HashSet`, `TreeSet` или `LinkedHashSet`.  
Различаются реализации порядком хранения элементов.

[**HashSet**](/conspect/definitions.md/#h) - это класс в Java, который представляет собой реализацию интерфейса `Set` и
использует хеш-таблицу для хранения элементов.  
_HashSet_ отличается высокой скоростью поиска элементов во множестве.  
Элементы `HashSet` хранятся в специально созданной `HashMap`, так как алгоритмы работы с ключами в ней соответствуют
требованиям реализации _HashSet_ и позволяют эффективно добавлять, удалять и искать уникальные элементы.  
Коллекция _HashSet_ не гарантирует фиксированный порядок хранения и выведения элементов и имеет все те же методы,
которые присутствуют в [_ArrayList_](/conspect/02_06.md/#2631-arraylist), кроме методов `get()` и `set()` (так как элементы
не имеют индексов).

> Если в классе не реализованы методы `equals()` и `hashCode()`, то _HashSet_ не сможет выбрать корректную ячейку для
> элемента и найти его дубликаты, и в результате `Set` будет представлять из себя просто список элементов, не содержащих
> индексы.

_TreeSet_ или _LinkedHashSet_ построены аналогичным образом на базе _TreeMap_ и _LinkedHashMap_, соответственно.  
_TreeSet_ хранит данные в естественном порядке (по мере увеличения значений), а _LinkedHashMap_ - в порядке добавления
элементов.

### 2.6.6 Comparator

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Comparator**](/conspect/definitions.md/#c) - это специальный интерфейс в Java, который устанавливает отношение
порядка между объектами.

Многие методы и классы в коллекциях принимают _Comparator_ в качестве дополнительного аргумента, чтобы выстраивать
объекты в нужном порядке.  
_Comparator_ имеет ряд статических методов, наиболее часто используемые из которых: `naturalOrder()` (располагает
элементы в естественном порядке) и `reverseOrder()` (располагает элементы в обратном порядке).

В случае необходимости можно создать свой компаратор, упорядочивающий элементы в том порядке, который требуется.

Например:

- создадим свой компаратор для сортировки значений типа `String`:

```java
public class ReverseStringComparator implements Comparator<String> {

    // Метод compare работает так же, как compareTo в интерфейсе Comparable
    // Различие в том, что он сравнивает 2 объекта из аргументов,
    // а не this и other
    // Контракт у этого метода такой же, как у метода compareTo
    @Override
    public int compare(String s1, String s2) {
        // Чтобы обратить порядок, можно сравнить в обратном порядке
        // То есть, если s1 больше s2, то возвращаем не 1, а -1
        return s2.compareToIgnoreCase(s1);
    }
}
```

- применим созданный компаратор:

```java
private static void comparatorExample() {
    Set<String> tree = new TreeSet<>(new ReverseStringComparator());
    tree.add("b");
    tree.add("a");
    tree.add("c");
    tree.add("d");
    tree.add("B");
    tree.add("A");
    tree.add("C");
    tree.add("D");
    System.out.println(tree);
}
```

В результате в терминале будет выведено `[d, c, b, a]`. Это связано с тем, что _TreeSet_ сравнивает элементы без учета
регистра и не добавляет элементы в верхнем регистре (поскольку они добавляются позже).

> Интерфейс _Comparator_ и реализующие его классы применяются, когда нужно сравнить объекты по какому-то другому
> правилу, отличному от естественного порядка.

> И `Comparable`, и `Comparator` обычно используются в коллекциях Java для реализации функций сортировки. `Comparable`
> необходимо реализовать в классе, который требует сортировки, тогда как `Comparator` может быть реализован в другом
> классе или также может быть реализован с помощью лямбда-функции.

### 2.6.7 Очередь (Queue)

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Очередь (Queue)**](/conspect/definitions.md/#q) - это структура данных, представляющая из себя упорядоченный набор
элементов, в которой добавление новых элементов производится в конец, называемый **хвостом очереди**, а удаление
существующих производится с другого конца, называемого **головой очереди**.  
Очереди в Java работают по двум принципам: _FIFO_ и _LIFO_.

[**LIFO (last-in, first-out)**](/conspect/definitions.md/#l) - это принцип, при котором первым удаляется элемент,
который был помещен туда последним («последним вошел — первым вышел»).

![1.jpeg](/pictures/1.jpeg)

В очереди реализован принцип _FIFO_.  
[**FIFO (first-in, first-out)**](/conspect/definitions.md/#f) - это принцип, при котором первым удаляется элемент,
который был помещен туда первым («первым вошел — первым вышел»).

![2.png](/pictures/2.png)

В Java структура данных очередь представлена не классом, а интерфейсом - `Queue`.  
Но вместе с тем, очередь в Java - это интерфейс, у которого есть очень много реализаций. Самым распространённым из
используемых субинтерфейсов, реализующих интерфейс `Queue`, является интерфейс `Deque` (двусторонняя очередь).  
Двусторонняя очередь `Deque` расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и
конец очереди) и забирать элементы с обоих краев очереди.

![3.png](/pictures/3.png)

У _Queue_ есть три класса реализации: _LinkedList_, _ArrayDeque_ (наследуемые от _Deque_) и _PriorityQueue_ (наследуемая
напрямую).

> Очередь (_Queue_) как и множество (_Set_) не имеет методов `get()` и `set()`.

Класс _ArrayDeque_ поддерживает двустороннюю структуру данных очереди, что дает возможность вставлять и удалять элементы
с обеих сторон. Также он - динамический массив, который может автоматически увеличивать свой размер.

Класс _PriorityQueue_ - это очередь с приоритетом, которая по умолчанию размещает элементы согласно естественному
порядку сортировки. Для сортировки здесь используется _Comparable_ и _Comparator_.

Например:

```java
private static void dequeExample() {
    PriorityQueue<String> priorityQueue = new PriorityQueue<>(Comparator.comparingInt(String::length));
    priorityQueue.add("John");
    priorityQueue.add("Andrew");
    priorityQueue.add("Rob");
    while (!priorityQueue.isEmpty()) {
        System.out.println(priorityQueue.remove());
    }
}
```

После запуска в консоли будет выведено:

```text
Rob
John
Andrew
```

#### 2.6.7.1 add()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `add()` интерфейса `Queue` применяется для добавления элемента в очередь.  
Синтаксис метода выглядит следующим образом:

```java
queue.add([элемент]);
```

Данный метод осуществляет добавление элемента в конец очереди.

#### 2.6.7.2 remove()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `remove()` интерфейса `Queue` применяется для удаления элемента из очереди.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.remove();
`

Данный метод удаляет элемент из головы очереди и возвращает его значение.  
В случае если очередь пуста, метод выбросит исключение _NoSuchElementException_.

#### 2.6.7.3 poll()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `poll()` интерфейса `Queue` применяется для удаления элемента из очереди.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.poll();
`

Данный метод удаляет элемент из головы очереди и возвращает его значение.  
В случае если очередь пуста, метод вернёт `null`.

#### 2.6.7.4 peek()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `peek()` интерфейса `Queue` применяется для получения элемента из очереди без его удаления.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.peek();
`

Данный метод возвращает значение элемента из головы очереди.  
В случае если очередь пуста, метод вернёт `null`.

#### 2.6.7.5 element()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `element()` интерфейса `Queue` применяется для получения элемента из очереди без его удаления.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.element();
`

Данный метод возвращает значение элемента из головы очереди.  
В случае если очередь пуста, метод выбросит исключение _NoSuchElementException_.

#### 2.6.7.6 Двусторонняя очередь (Deque)

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Deque**](/conspect/definitions.md/#d) - это интерфейс, позволяющий [очереди (Queue)](/conspect/definitions.md/#q),
функционировать как двунаправленная очередь.

##### 2.6.7.6.1 addFirst()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `addFirst()` интерфейса `Deque` применяется для добавления элемента в голову очереди.  
Синтаксис метода выглядит следующим образом:

```java
queue.addFirst([элемент]);
```

Данный метод добавляет значение элемента в голову очереди.  
В случае если в очереди нет места, метод выбросит исключение _IllegalStateException_.

##### 2.6.7.6.2 addLast()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `addLast()` интерфейса `Deque` применяется для добавления элемента в конец очереди.  
Синтаксис метода выглядит следующим образом:

```java
queue.addLast([элемент]);
```

Данный метод добавляет значение элемента в конец очереди.  
В случае если в очереди нет места, метод выбросит исключение _IllegalStateException_.

##### 2.6.7.6.3 getFirst()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `getFirst()` интерфейса `Deque` применяется для получения значения элемента из головы очереди без его удаления.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.getFirst();
`

Данный метод возвращает значение элемента из головы очереди без его удаления.  
В случае если очередь пуста, метод выбросит исключение _NoSuchElementException_.

##### 2.6.7.6.4 getLast()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `getLast()` интерфейса `Deque` применяется для получения значения элемента из конца очереди без его удаления.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.getLast();
`

Данный метод возвращает значение элемента из конца очереди без его удаления.  
В случае если очередь пуста, метод выбросит исключение _NoSuchElementException_.

##### 2.6.7.6.5 offerFirst()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `offerFirst()` интерфейса `Deque` применяется для добавления элемента в голову очереди.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = queue.offerFirst([элемент]);
```

Данный метод возвращает `true`, если добавление элемента прошло успешно, иначе - `false`.

##### 2.6.7.6.6 offerLast()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `offerLast()` интерфейса `Deque` применяется для добавления элемента в конец очереди.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = queue.offerLast([элемент]);
```

Данный метод возвращает `true`, если добавление элемента прошло успешно, иначе - `false`.

##### 2.6.7.6.7 рор()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `рор()` интерфейса `Deque` применяется для удаления элемента из очереди.  
Синтаксис метода выглядит следующим образом:

`
[тип_элемента] variable = queue.рор();
`

Данный метод удаляет элемент из головы очереди и возвращает его значение.  
В случае если очередь пуста, метод выбросит исключение _NoSuchElementException_.

##### 2.6.7.6.8 push()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `push()` интерфейса `Deque` применяется для добавления элемента в очередь.  
Синтаксис метода выглядит следующим образом:

```java
queue.push([элемент]);
```

Данный метод добавляет значение элемента в голову очереди.  
В случае если в очереди нет места, метод выбросит исключение _IllegalStateException_.

##### 2.6.7.6.9 removeFirstOccurrence()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `removeFirstOccurrence()` интерфейса `Deque` применяется для удаления первого вхождения элемента, начиная с головы
очереди.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = queue.removeFirstOccurrence([элемент]);
```

Данный метод возвращает `true`, если удаление элемента прошло успешно, иначе - `false`.

##### 2.6.7.6.10 removeLastOccurrence()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `removeLastOccurrence()` интерфейса `Deque` применяется для удаления первого вхождения элемента, начиная с конца
очереди.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = queue.removeLastOccurrence([элемент]);
```

Данный метод возвращает `true`, если удаление элемента прошло успешно, иначе - `false`.

> Также интерфейс `Deque` предоставляет методы `peekFirst()`, `peekLast()`, `pollFirst()`, `pollLast()`, `removeFirst()`
> и `removeLast()` аналогичные по своему принципу работы методам из интерфейса `Queue`.

### 2.6.8 Мап (Map)

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**Map (Мап)**](/conspect/definitions.md/#m) - это структура хранения данных в формате «ключ-значение».  
Мапы являются [ассоциативными массивами](/conspect/definitions.md/#а).

_Map_ не реализует интерфейсы `Iterable` и `Collection`, поэтому у него нет общих для коллекций методов, только свои.  
У интерфейса _Map_ есть ряд реализаций: `TreeMap`, `HashMap`, `LinkedHashMap` и др.

Значения в _Map_ могут повторяться, а ключи - нет.

`HashMap` и `LinkedHashMap` позволяют использовать `null` в качестве одного из ключей, а `SortedMap` (и его
потомок `TreeMap`, соответственно) - нет.

> Итерироваться по мапам с помощью циклов нельзя!

#### 2.6.8.1 HashMap

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**HashMap**](/conspect/definitions.md/#h) - это Map, в которой пара «ключ-значение» добавляется в хранилище по
уникальному числовому коду объекта - хеш-коду ключа.

Ключами в _HashMap_ должны быть неизменяемые объекты. Если изменить объект, то изменится и _hashCode_, а значит, быстро
найти этот элемент в коллекции по первоначальному хеш-коду станет невозможно. Поэтому обычно в качестве ключей
используются строки или числа.

Данные в _HashMap_ хранятся в корзинах (_buckets_), в каждой из которых находятся от 1 до 8 узлов (_Node_), собранных в
связный список, или (при количестве _Node_ большем 8) самобалансирующееся бинарное дерево, помогающее ускорить поиск
внутри корзины. Каждый узел содержит ключ, значение, хеш-код (высчитываемый сложением хеш-кода ключа и хеш-кода
значения) и ссылку на соседний узел.

```java
static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;
    final K key;
    V value;
    Node<K, V> next;
    // ...
}
```

[**Бинарное дерево**](/conspect/definitions.md/#б) - это дерево, в котором для любого узла выполняется правило: потомки
слева этого узла всегда меньше него, потомки справа - всегда больше.

У _HashMap_ есть метрика `loadFactor`, определяющая процент загрузки пространства корзин, после которого происходит
автоматическое расширение пространства в памяти (по умолчанию равна `0.75f`).  
Расширение происходит путём увеличения количества корзин в 2 раза, пересчёта хешей для всех узлов и их перераспределения
по корзинам с учётом нового их количества.

> В _HashMap_ порядок хранения пар «ключ-значение» не гарантируется: пары хранятся в соответствии с хеш-кодами, а не
> ключами или значениями.

##### 2.6.8.1.1 put()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `put()` класса `HashMap` применяется для добавления элементов в мапу.  
Синтаксис метода выглядит следующим образом:

```java
map.put([ключ], [значение]);
```

Данный метод добавляет в мапу элемент по указанному ключу с указанным значением.

##### 2.6.8.1.2 get()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `get()` класса `HashMap` применяется для получения значения из мапы по текущему ключу.  
Синтаксис метода выглядит следующим образом:

```text
[тип значения] variable = map.get([ключ]);
```

Данный метод возвращает из мапы значение, хранящееся по указанному ключу.  
В случае, если указанного ключа в мапе нет, метод возвращает `null` или выбрасывает исключение _NullPointerException_ (
если `null` не удаётся сконвертировать в нужный тип данных).

##### 2.6.8.1.3 containsValue()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `containsValue()` класса `HashMap` применяется для определения наличия в мапе указанного значения.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = map.containsValue([значение]);
```

Данный метод возвращает `true`, если в мапе имеется элемент с искомым значением, иначе - `false`.

##### 2.6.8.1.4 containsKey()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `containsKey()` класса `HashMap` применяется для определения наличия в мапе указанного ключа.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = map.containsKey([ключ]);
```

Данный метод возвращает `true`, если в мапе имеется элемент с искомым ключом, иначе - `false`.

##### 2.6.8.1.5 remove()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `remove()` класса `HashMap` применяется для удаления из мапы элемента с указанным ключом или с указанным
сочетанием "ключ-значение".  
Синтаксис метода выглядит следующим образом:

```java
boolean b = map.remove([ключ], [значение]);
```

```text
[тип значения] variable = map.remove([ключ]);
```

Данный метод для сочетания "ключ-значение" возвращает из мапы `true`, если удаление прошло успешно, иначе - `false`.

Данный метод для указанного ключа возвращает из мапы значение, с которым ранее связывал удаляемый ключ.  
В случае, если указанного ключа в мапе нет, метод выбрасывает исключение _NullPointerException_.

##### 2.6.8.1.6 isEmpty()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `isEmpty()` класса `HashMap` применяется для определения наличия в мапе значений.  
Синтаксис метода выглядит следующим образом:

```java
boolean b = map.isEmpty();
```

Данный метод возвращает `true`, если в мапе нет элементов "ключ-значение" (она пустая), иначе - `false`.

##### 2.6.8.1.7 size()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `size()` класса `HashMap` применяется для определения размера мапы.  
Синтаксис метода выглядит следующим образом:

```java
int variable = map.size();
```

Данный метод возвращает количество элементов в мапе.

##### 2.6.8.1.8 clear()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `clear()` класса `HashMap` применяется для очистки мапы от всех элементов.  
Синтаксис метода выглядит следующим образом:

```java
map.clear();
```

Данный метод удаляет из мапы все элементы.

##### 2.6.8.1.9 keySet()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `keySet()` класса `HashMap` применяется для создания из всех ключей мапы множества (_Set_).  
Синтаксис метода выглядит следующим образом:

```text
Set<[тип ключа]> keySet = map.keySet();
```

Данный метод возвращает множество (_Set_), состоящее из содержащихся в мапе ключей.

##### 2.6.8.1.10 values()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `values()` класса `HashMap` применяется для создания из всех значений мапы коллекции.  
Синтаксис метода выглядит следующим образом:

```text
Collection<[тип значения]> keySet = map.values();
```

Данный метод возвращает коллекцию, состоящую из содержащихся в мапе значений.

##### 2.6.8.1.11 entrySet()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `entrySet()` класса `HashMap` применяется для создания множества (_Set_) из содержащихся в мапе пар
"ключ-значение".  
Синтаксис метода выглядит следующим образом:

```text
Set<Entry<[тип ключа], [тип значения]>> entrySet = map.values();
```

Данный метод возвращает множество (_Set_), состоящее из содержащихся в мапе пар "ключ-значение".  
Получаемое таким образом множество позволяет итерироваться по мапе, а также сохраняет взаимосвязь с содержащимися в мапе
элементами, за счёт чего в случае внесения изменений в элементы получаемого множества (_Set_) эти изменения также будут
внесены в мапу, на основании которой это множество создано.

#### 2.6.8.2 LinkedHashMap

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**LinkedHashMap**](/conspect/definitions.md/#l) - это реализация интерфейса `Map`, содержащая пары "ключ-значение" в
порядке их добавления.

Класс `LinkedHashMap` поддерживает двусвязный список, проходящий через все его записи.  
Если `HashMap` - это, по сути, массив с 16 ячейками, то `LinkedHashMap` еще и связывает все эти ячейки. Чтобы сохранить
порядок элементов, `LinkedHashMap` изменяет класс `Map.Entry`, добавляя указатели на следующую и предыдущую записи.

#### 2.6.8.3 TreeMap

> [[_оглавление_]](../README.md/#26-java-collections-framework)

[**TreeMap**](/conspect/definitions.md/#t) - это реализация интерфейса `Map`, которая сортирует пары "ключ-значение" в
соответствии с естественным порядком ключей или по компаратору, если он предоставляется разработчиком во время создания
реализации.

По умолчанию _TreeMap_ сортирует все свои записи в соответствии с их естественным порядком. Для целых чисел естественный
порядок - это возрастающий (от меньшего к большему), для строк - алфавитный.

_TreeMap_ не использует хеширование, так как вместо массива в нём - структура дерева для хранения и сортировки
элементов.  
В _TreeMap_ можно использовать свои классы в качестве ключей, но для этого нужно реализовать в них
интерфейс `Comparable` или при создании указать компаратор.

#### 2.6.8.4 Сравнительная таблица реализаций интерфейса Map

> [[_оглавление_]](../README.md/#26-java-collections-framework)

| **Особенности**                                                                                               |                                                     ***HashMap***                                                      |                                                    ***LinkedHashMap***                                                    |                                                                                         ***TreeMap***                                                                                         |
|:--------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Алгоритмическая сложность получения по ключу, вставки, поиска ключа и удаления по ключу без коллизий hashCode |                                                          O(1)                                                          |                                                           O(1)                                                            |                                                                                           O(log n)                                                                                            |
| Порядок прохода                                                                                               |                                                       Случайный                                                        | Проходится в порядке вставки элементов или в соответствии с _AccessOrder_, указанном при создании объекта `LinkedHashMap` |                                        Сортируется в естественном порядке или в соответствии с компаратором, указанном при создании объекта `TreeMap`                                         |
| Ключи со значением `null`                                                                                     |                                                       Разрешены                                                        |                                                         Разрешены                                                         |                                     Не допускаются, если ключи используют естественный порядок или компаратор не поддерживает сравнение по нулевым ключам                                     |
| Интерфейс                                                                                                     |                                                          Map                                                           |                                                            Map                                                            |                                                                                 Map, SortedMap, NavigableMap                                                                                  |
| Структура данных внутри реализации                                                                            | Список сегментов. Если в сегменте больше 8 записей, то Java переключится на сбалансированное дерево из связного списка |                                                Двусвязный список сегментов                                                |            Red-Black (самобалансирующееся двоичное дерево поиска), реализация двоичного дерева. Эта структура данных обеспечивает O(log n) для операций вставки, удаления и поиска            |
| Применение                                                                                                    |                                            Общего назначения, быстрый поиск                                            |                   Может использоваться для алгоритмов, где важен порядок вставки и доступа к элементам                    |                  Используется там, где требуется изначальная отсортированность ключей, или в случаях, когда нужно найти часть ключей, соответствующих условию больше/меньше                   |
| Требования к ключам                                                                                           |                                  `equals()` и `hashCode()` должны быть переопределены                                  |                                   `equals()` и `hashCode()` должны быть переопределены                                    | Для ключей нужно установить естественный порядок с помощью реализации интерфейса _Comparable_ для ключа, в противном случае нужно передать _Comparator_, который сравнивает ключи между собой |

#### 2.6.8.5 Интерфейс Map.Entry

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Интерфейс _Map.Entry_ в Java позволяет работать с записями _Map_.

> Интерфейс _Map_ не реализует интерфейс _Iterable_, по этой причине итерироваться по элементам `Map` напрямую нельзя.

Метод `entrySet()`, объявленный интерфейсом _Map_, возвращает `Set`, содержащий записи `Map`. Каждый из этих элементов
является объектом `Map.Entry`.  
Каждый из объектов `Map.Entry` сохраняет связь со своей базовой `Map`, поэтому изменения в нём будут также внесены в
аналогичный элемент базовой `Map`.

Пример:

- создадим `Map`, внесём в неё значения, а затем преобразуем при помощи `Map.Entry` так, чтобы она содержала только
  нечётные числа:

```java
private static void mapEntryExample() {
    Map<String, Integer> map = new HashMap<>();
    map.put("key 1", 1);
    map.put("key 2", 2);
    map.put("key 3", 3);
    Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
    System.out.println(entrySet);
    System.out.println(map);
    for (Map.Entry<String, Integer> entry : entrySet) {
        if (entry.getValue() % 2 == 0) {
            entry.setValue(entry.getValue() + 1);
        }
    }
    System.out.println();
    System.out.println(entrySet);
    System.out.println(map);
}
```

- в терминале получим:

```text
[key 3=3, key 2=2, key 1=1]
{key 3=3, key 2=2, key 1=1}

[key 3=3, key 2=3, key 1=1]
{key 3=3, key 2=3, key 1=1}
```

##### 2.6.8.5.1 equals()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `equals()` интерфейса `Map.Entry` применяется для сравнения содержащихся в мапе пар "ключ-значение".  
Синтаксис метода выглядит следующим образом:

```java
boolean b = entryFirst.equals(entrySecond);
```

Данный метод возвращает `true`, если объект - это `Map.Entry`, чей ключ и значение равны значению вызывающего объекта,
иначе - `false`.

##### 2.6.8.5.2 hashCode()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `hashCode()` интерфейса `Map.Entry` применяется для получения хеш-кода для текущей записи "ключ-значение".  
Синтаксис метода выглядит следующим образом:

```java
int hashCode = entry.hashCode();
```

Данный метод возвращает хэш-код для этой записи в `Map`.

##### 2.6.8.5.3 getKey()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `getKey()` интерфейса `Map.Entry` применяется для получения значения ключа для текущей записи "ключ-значение".  
Синтаксис метода выглядит следующим образом:

```text
[тип ключа] variable = entry.getKey();
```

Данный метод возвращает значения ключа для этой записи в `Map`.

##### 2.6.8.5.4 getValue()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `getValue()` интерфейса `Map.Entry` применяется для получения значения для текущей записи "ключ-значение".  
Синтаксис метода выглядит следующим образом:

```text
[тип значения] variable = entry.getValue();
```

Данный метод возвращает значения для этой записи в `Map`.

##### 2.6.8.5.5 setValue()

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Метод `setValue()` интерфейса `Map.Entry` применяется для изменения значения для текущей записи "ключ-значение".  
Синтаксис метода выглядит следующим образом:

```java
entry.setValue([значение]);
```

Данный метод устанавливает новое значение для этой записи в `Map`.

### 2.6.9 Comparable

> [[_оглавление_]](../README.md/#26-java-collections-framework)

Интерфейс _Comparable_ (как и [_Comparator_](/conspect/02_06.md/#266-comparator)) позволяет установить в объектах отношения
порядка, то есть указать, какой из объектов нужно считать большим, а какой - меньшим, что позволяет сортировать объекты.

Метод `compareTo()` интерфейса _Comparable_ может возвращать три вида целых чисел:

- _отрицательное целое число_ - если объект `this` < `other`;
- _ноль_ - если объект `this` = `other`;
- _положительное целое число_ - если объект `this` > `other`.

Также должны выполняться следующие правила:

- если `x.compareTo(y) == 0`, то `x.equals(y) == true`;
- если `x.compareTo(y) > 0`, то `y.compareTo(x) < 0`.

Метод `compareTo()` может выбрасывать исключения:

- _NullPointerException_ - если объект `other == null`;
- _ClassCastException_ - если объект `other` нельзя привести к требуемому классу.

Пример:

- реализуем интерфейс _Comparable_ у класса _Person_, определив сортировку объектов по полю `name`:

```java
public class Person implements Comparable<Person> {
    private String name;
    private String surname;
    private int age;
    // конструктор, геттеры, сеттеры, equals(), hashCode(), toString()

    @Override
    public int compareTo(Person o) {
        return name.compareTo(o.name);
    }
}
```

- создадим `TreeMap` из объектов _Person_:

```java
private static void treeMapExample() {
    Person ivan = new Person("Ivan", "Ivanov", 25);
    Person petr = new Person("Petr", "Petrov", 25);
    Person sidor = new Person("Sidor", "Sidorov", 31);
    Map<Person, Integer> persons = new TreeMap<>();
    persons.put(sidor, sidor.getAge());
    persons.put(ivan, ivan.getAge());
    persons.put(petr, petr.getAge());
    System.out.println(persons);
}
```

- в терминале получим список персон, отсортированный по имени:

```text
{Person[name='Ivan', surname='Ivanov', age=25]=25, Person[name='Petr', surname='Petrov', age=25]=25, Person[name='Sidor', surname='Sidorov', age=31]=31}
```

> И `Comparable`, и `Comparator` обычно используются в коллекциях Java для реализации функций сортировки. `Comparable`
> необходимо реализовать в классе, который требует сортировки, тогда как `Comparator` может быть реализован в другом
> классе или также может быть реализован с помощью лямбда-функции.