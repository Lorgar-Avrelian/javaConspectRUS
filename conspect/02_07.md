## 2.7 Алгоритмы

> [[_оглавление_]](../README.md/#27-алгоритмы)

### 2.7.1 Алгоритмическая сложность

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Алгоритмическая сложность**](/conspect/definitions.md/#а) - это оценка ресурсов (времени выполнения), необходимых для
выполнения алгоритма в зависимости от размера входных данных.

Алгоритмическая сложность позволяет предварительно оценить производительность операций над структурой данных.  
Алгоритмическая сложность обозначается символом `О` (Big-O) и выражается в виде функции, которая показывает рост времени
выполнения алгоритма относительно количества элементов в структуре данных.

![18.png](/pictures/18.png)

[**Константная алгоритмическая сложность O(1)**](/conspect/definitions.md/#к) - это алгоритмическая сложность, при
которой время выполнения алгоритма не зависит от количества элементов.  
Например, доступ к элементу массива по индексу.

[**Логарифмическая алгоритмическая сложность O(log n)**](/conspect/definitions.md/#л) - это алгоритмическая сложность,
при которой время выполнения алгоритма прямо пропорционально логарифму количества элементов.  
Например, бинарный поиск в отсортированном массиве.

[**Линейная алгоритмическая сложность O(n)**](/conspect/definitions.md/#л) - это алгоритмическая сложность, при которой
время выполнения алгоритма прямо пропорционально количеству элементов.  
Например, просмотр всех элементов в массиве.

[**Квадратичная алгоритмическая сложность O(n<sup>2</sup>)**](/conspect/definitions.md/#к) - это алгоритмическая
сложность, при которой время выполнения алгоритма прямо пропорционально квадрату количества элементов.  
Например, сортировка пузырьком (bubble sort - сортировка путём сравнения значений двух соседних элементов).

[**Кубическая алгоритмическая сложность O(n<sup>3</sup>)**](/conspect/definitions.md/#к) - это алгоритмическая
сложность, при которой время выполнения алгоритма прямо пропорционально кубу количества элементов.  
Например, алгоритмы, которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.

Алгоритмическая сложность работы с данными напрямую взаимосвязана со структурой данных.

### 2.7.2 Структура данных

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Структура данных**](/conspect/definitions.md/#с) - это набор данных, связанных определённым образом.  
Структура данных определяет то, как значения объектов хранятся в памяти компьютера.

Виды структур данных:

- [массив (Array)](/conspect/01_04.md/#14-массивы) - данные массива хранятся в виде непрерывного единого куска памяти
  компьютера;
  ![19.png](/pictures/19.png)
- [динамический массив (ArrayList)](/conspect/02_06.md/#2631-arraylist) - данные хранятся в виде непрерывного единого
  куска
  памяти, при этом при увеличении или уменьшении размера массива происходит выделение нового куска памяти, в который
  переносятся все значения из памяти до преобразования;
- [связный список (LinkedList)](/conspect/02_06.md/#2632-linkedlist) - каждый элемент хранится в своей области памяти
  компьютера и содержит ссылки на области памяти, в которых хранятся предыдущий и следующий элементы;
  ![22.png](/pictures/22.png)
- [стек (Stack)](/conspect/02_01.md/#211-стек-stack) - данные хранятся в динамическом массиве: добавление и извлечение
  происходят с его хвоста (принцип _LIFO_);  
  ![1.jpeg](/pictures/1.jpeg)
- [очередь (Queue)](/conspect/02_06.md/#267-очередь-queue) - данные хранятся в динамическом массиве: добавление
  происходит в
  его голову, а извлечение - с его хвоста (принцип _FIFO_);  
  ![2.png](/pictures/2.png)
- [дерево (TreeMap)](/conspect/02_06.md/#2683-treemap) - каждый элемент хранится в своей области памяти компьютера и
  содержит ссылки на области памяти, в которых хранятся ссылки на родительский узел, добавленный ранее и больший либо
  меньший по значению, и два дочерних узла, добавленные позже, один из которых больше по значению, а второй - меньше по
  значению (при этом первый добавленный элемент становится корневым и называется _root_);  
  ![23.png](/pictures/23.png)
- граф (Graph) - каждый элемент (_узел_ или _node_) хранится в своей области памяти компьютера и содержит ссылки
  (_рёбра_) на смежные узлы согласно матрицы смежности.  
  ![24.png](/pictures/24.png)

[**Граф**](/conspect/definitions.md/#г) - это структура данных, состоящая из вершин (нодов) и соединяющих их рёбер.  
Деревья являются частным случаем графов.

Типы графов:

- по наличию направления:
    * ориентированные (направленные) - наличие ребра `(v,u)` означает, что по этому ребру можно пройти из вершины `v` в
      вершину `u`, при этом существование обратного ребра не гарантируется;
    * неориентированные (ненаправленные) - наличие ребра `(v,u)` означает, что по этому ребру можно пройти из вершины
      `v` в вершину `u`, и наоборот;
- по наличию весов рёбер:
    * взвешенные - имеющие вес (цену прохождения) рёбер;
    * не взвешенные - не имеющие весов рёбер;
- по наличию циклов в графе:
    * циклические - если можно стартовать в некоторой вершине и вернуться в неё после перемещения по рёбрам, не проходя
      дважды по одному ребру;
    * ациклические - если нельзя стартовать в некоторой вершине и вернуться в неё после перемещения по рёбрам, не
      проходя дважды по одному ребру.

> К ориентированным графам неприменимо понятие «дерево». Если в ориентированном графе нет цикла, то он так и
> называется - ациклический ориентированный граф. Иногда можно встретить аббревиатуру _DAG (Directed Acyclic Graph)_.

Представления графов:

- список рёбер (сэт);
- список вершин (сэт);
- матрица смежности (двумерный массив);
- список смежности (ассоциативный массив: ключ на список значений).

### 2.7.3 Примеры базовых алгоритмов

> [[_оглавление_]](../README.md/#27-алгоритмы)

Существует ряд типизированных алгоритмов для осуществления сортировки и поиска элементов в массивах и коллекциях.

Самые популярные базовые алгоритмы сортировки в порядке уменьшения времени выполнения:

- [пузырьковая сортировка](/conspect/02_07.md/#2731-пузырьковая-сортировка);
- [сортировка выбором](/conspect/02_07.md/#2732-сортировка-выбором);
- [сортировка вставкой](/conspect/02_07.md/#2733-сортировка-вставкой).

Самые популярные алгоритмы поиска по значению элемента:

- [линейный поиск](/conspect/02_07.md/#2734-линейный-поиск);
- [бинарный поиск](/conspect/02_07.md/#2735-бинарный-поиск);
- [метод двух указателей](/conspect/02_07.md/#2736-два-указателя).

#### 2.7.3.1 Пузырьковая сортировка

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Пузырьковая сортировка**](/conspect/definitions.md/#п) - это сортировка квадратической алгоритмической сложности с
использованием двух циклов: основного и вложенного, - где количество итераций в последнем из них с каждой новой
итерацией уменьшается на 1 (от числа, равного количеству итераций основного цикла, до 1).

При пузырьковой сортировке на каждом шаге вложенный цикл сравнивает текущий элемент со следующим и, если текущий больше
следующего, элементы меняются местами.

Пример:

```java
public static void sortBubble(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swapElements(arr, j, j + 1);
            }
        }
    }
}

private static void swapElements(int[] arr, int indexA, int indexB) {
    int tmp = arr[indexA];
    arr[indexA] = arr[indexB];
    arr[indexB] = tmp;
}
```

Отличительная особенность пузырьковой сортировки в том, что при её использовании основной цикл будет пройден полностью в
любом случае, даже если сортировку можно будет заканчивать уже после первой итерации.

#### 2.7.3.2 Сортировка выбором

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Сортировка выбором**](/conspect/definitions.md/#с) - это сортировка квадратической алгоритмической сложности с
использованием двух циклов: основного и вложенного, - в которой на каждой итерации вложенного цикла находится
минимальный элемент и перемещается в самую левую ячейку текущей итерации, а элемент из самой левой ячейки перемещается
туда, где был минимальный элемент до перемещения.

Пример:

```java
public static void sortSelection(int[] arr) {
    for (int i = 0; i < arr.length - 1; i++) {
        int minElementIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minElementIndex]) {
                minElementIndex = j;
            }
        }
        swapElements(arr, i, minElementIndex);
    }
}

private static void swapElements(int[] arr, int indexA, int indexB) {
    int tmp = arr[indexA];
    arr[indexA] = arr[indexB];
    arr[indexB] = tmp;
}
```

При сортировке выбором основной цикл также, как и при пузырьковой сортировке, будет пройден полностью, даже если
сортировка будет выполнена уже после первой итерации, однако показывает большую скорость выполнения.

#### 2.7.3.3 Сортировка вставкой

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Сортировка вставкой**](/conspect/definitions.md/#с) - это сортировка квадратической алгоритмической сложности с
использованием двух циклов: основного и вложенного, - в которой на каждом шаге цикла вычисляется определённая позиция, а
все элементы слева сдвигаются на один вправо до тех пор, пока не будет найдена корректная позиция для найденного
элемента, а затем этот элемент устанавливается в найденную позицию.

Пример:

```java
public static void sortInsertion(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int temp = arr[i];
        int j = i;
        while (j > 0 && arr[j - 1] >= temp) {
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = temp;
    }
}
```

#### 2.7.3.4 Линейный поиск

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Линейный поиск**](/conspect/definitions.md/#л) - это поиск по значению линейной алгоритмической сложности,
реализующийся простым проходом через все элементы массива, который сравнивает каждый элемент с необходимым.

Пример:

```java
public static boolean contains(int[] arr, int element) {
    for (int i : arr) {
        if (i == element) {
            return true;
        }
    }
    return false;
}
```

#### 2.7.3.5 Бинарный поиск

> [[_оглавление_]](../README.md/#27-алгоритмы)

###### Применимость: Для отсортированных данных.

[**Бинарный поиск**](/conspect/definitions.md/#б) - это поиск по значению логарифмической алгоритмической сложности в
отсортированных данных, реализующийся «отсечением» половины всех данных, которые точно не соответствуют разыскиваемому
значению.

Пример:

```java
public static boolean contains(int[] arr, int element) {
    int min = 0;
    int max = arr.length - 1;
    while (min <= max) {
        int mid = (min + max) / 2;
        if (element == arr[mid]) {
            return true;
        }
        if (element < arr[mid]) {
            max = mid - 1;
        } else {
            min = mid + 1;
        }
    }
    return false;
}
```

На использование бинарного поиска накладывает ограничение необходимость сортировать данные перед его использованием.

В коллекциях бинарный поиск может быть запущен при помощи
статического [метода `binarySearch()`](/conspect/02_06.md/#2615-binarysearch) класса `Collections`.

#### 2.7.3.6 Два указателя

> [[_оглавление_]](../README.md/#27-алгоритмы)

###### Применимость: Для монотонных функций и строк.

[**Монотонно возрастающая функция**](/conspect/definitions.md/#м) - это функция, каждое последующее значение которой
строго больше предыдущего.  
[**Монотонно неубывающая функция**](/conspect/definitions.md/#м) - это функция, каждое последующее значение которой не
меньше предыдущего.  
[**Монотонно невозрастающая функция**](/conspect/definitions.md/#м) - это функция, каждое последующее значение которой
строго меньше предыдущего.  
[**Монотонно убывающая функция**](/conspect/definitions.md/#м) - это функция, каждое последующее значение которой не
больше предыдущего.  
[**Монотонная функция**](/conspect/definitions.md/#м) - это функция, обладающая одним из свойств монотонности.

Во многих задачах, связанных с массивами, списками или строками, приходится анализировать каждый элемент по сравнению с
другими элементами.  
Чтобы решить подобные проблемы, обычно начинают с первого индекса и перебирают массив один или несколько раз в
зависимости от реализации (вложенный цикл - квадратичная алгоритмическая сложность _O(n<sup>2</sup>)_). Иногда также
приходится создавать временный массив в зависимости от требований задачи.  
Описанный выше подход может дать правильный результат, но, скорее всего, не даст наиболее эффективного по времени и
расходуемой памяти решения.

_В технике с двумя указателями указатели ссылаются на индексы массива, списка или символа строки. Используя указатели,
можно обрабатывать два элемента за итерацию цикла вместо одного._

Общие шаблоны в подходе с двумя указателями включают:

- два указателя, каждый из которых начинается с начала и конца, пока они оба не встретятся;

Задача 1

> Задача: Дан отсортированный массив целых чисел. Нужно посмотреть, есть ли в нём два числа, сумма которых равна
> определённому значению.

Вместо:

```java
public boolean twoSumSlow(int[] input, int targetValue) {
    for (int i = 0; i < input.length; i++) {
        for (int j = i; j < input.length; j++) {
            if (input[i] + input[j] == targetValue) {
                return true;
            }
        }
    }
    return false;
}
```

Использовать:

```java
public boolean twoSum(int[] input, int targetValue) {
    int pointerOne = 0;
    int pointerTwo = input.length - 1;
    while (pointerOne < pointerTwo) {
        int sum = input[pointerOne] + input[pointerTwo];
        if (sum == targetValue) {
            return true;
        } else if (sum < targetValue) {
            pointerOne++;
        } else {
            pointerTwo--;
        }
    }
    return false;
}
```

> Временная сложность этого решения составляет _O(n)_, а пространственная сложность - _O(1)_.

Задача 2

> Задача: Дан массив. Нужно повернуть массив вправо на _k_ шагов, где _k_ - неотрицательно.

Вместо:

```java
public int[] rotate(int[] input, int step) {
    int[] result = new int[input.length];
    for (int i = 0; i < input.length; i++) {
        if ((i + step) < input.length) {
            result[i] = input[i + step];
        } else {
            result[i] = input[i - step];
        }
    }
    return result;
}
```

Использовать:

```java
public int[] rotate(int[] input, int step) {
    step %= input.length;
    reverse(input, 0, input.length - 1);
    reverse(input, 0, step - 1);
    reverse(input, step, input.length - 1);
    return input;
}

private void reverse(int[] input, int start, int end) {
    while (start < end) {
        int temp = input[start];
        input[start] = input[end];
        input[end] = temp;
        start++;
        end--;
    }
}
```

> В приведённых выше методах входной массив целиком и его отдельные части переворачиваются на месте несколько раз, чтобы
> получить требуемый результат. Для обращения секций используется подход с двумя указателями, при котором замена
> элементов производится на обоих концах секции массива.

> Временная сложность этого решения составляет _O(n)_, а пространственная сложность - _O(1)_.

- один указатель движется медленнее, а другой - быстрее.

> Задача: Учитывая одиночный _LinkedList_, найдите его средний элемент. Например, если Ваш входной _LinkedList_ равен
> '1->2->3->4->5', то выход должен быть `3`.

Решение

```java
public <T> T findMiddle(MyNode<T> head) {
    MyNode<T> slowPointer = head;
    MyNode<T> fastPointer = head;

    while (fastPointer.next != null && fastPointer.next.next != null) {
        fastPointer = fastPointer.next.next;
        slowPointer = slowPointer.next;
    }
    return slowPointer.data;
}
```

> В этом подходе просматривается связанный список, используя два указателя. Один указатель увеличивается на единицу, а
> другой увеличивается на два. Когда быстрый указатель достигнет конца, медленный указатель окажется в середине
> связанного списка.

> Временная сложность этого решения составляет _O(n)_, а пространственная сложность - _O(1)_.

Оба вышеприведённых шаблона могут помочь сократить время и пространство алгоритмической сложности задач, поскольку дают
возможность получать ожидаемый результат за меньшее количество итераций и без использования слишком большого
дополнительного пространства.

### 2.7.4 Рекурсия

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Рекурсия**](/conspect/definitions.md/#р) - это задание алгоритма вычисления функции с использованием вызова ее самой.

Плюсы рекурсии:

- код получается короче и читабельнее;
- рекурсивный код проще отлаживать.

Минусы рекурсии:

- затраты памяти (в стеке формируется множество фреймов, содержащих в себе ссылку на рекурсивный метод);
- затраты времени (на создание фреймов стека уходит определённое время);
- есть вероятность переполнить стек и вызвать ошибку _StackOverflowError_;
- не самое лёгкое восприятие алгоритма.

Пример:

- исходный метод:

```java
public static void printNumsWithCycle() {
    for (int i = 0; i <= 10; i++) {
        System.out.println(i);
    }
}
```

- рекурсивный аналог:

```java
public static void printNumsWithRecursion() {
    printNumsWithRecursion(0);
}

public static void printNumsWithRecursion(int currentNum) {
    System.out.println(currentNum);
    if (currentNum < 10) {
        printNumsWithRecursion(currentNum++);
    }
}
```

Чтобы избежать переполнения стека при использовании рекурсивных методов, необходимо:

- обязательно указать условие прерывания рекурсии;
- учитывать объём данных, для которых применяется рекурсивная обработка.

На базе применения рекурсивных методов построен ряд алгоритмов:

- [алгоритм Фибоначчи](/conspect/02_07.md/#2741-алгоритм-фибоначчи);
- [быстрая сортировка](/conspect/02_07.md/#2742-быстрая-сортировка);
- [сортировка слиянием](/conspect/02_07.md/#2743-сортировка-слиянием).

### 2.7.4.1 Алгоритм Фибоначчи

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Числа Фибоначчи**](/conspect/definitions.md/#ч) - это последовательность натуральных чисел, которая начинается с
чисел ноль и один, а каждое последующее число равно сумме двух предыдущих.  
[**Алгоритм Фибоначчи**](/conspect/definitions.md/#ф) - это базовый алгоритм для получения
последовательности [чисел Фибоначчи](/conspect/definitions.md/#ч).

Алгоритм получения последовательности чисел Фибоначчи может быть решён несколькими способами:

- с использованием цикла:

```java
public static void printFibonacci(int count) {
    int a = 0;
    int b = 1;
    for (int i = 0; i < count; i++) {
        System.out.print(a + " " + b + " ");
        a += b;
        b += a;
    }
    System.out.println();
}
```

- с использованием рекурсии:

```java
public static void printFibonacci(int count) {
    int firstNumber = 0;
    int secondNumber = 1;
    int currentStep = 0;
    printFibonacci(firstNumber, secondNumber, currentStep, count);
    System.out.println();
}

public static void printFibonacci(int num1, int num2, int currentStep, int count) {
    if (currentStep < count) {
        System.out.print(num1 + " ");
        printFibonacci(num2, num1 + num2, currentStep + 1, count);
    }
}
```

В обоих приведённых примерах будет выведено то количество чисел Фибоначчи, которое будет указано при запуске
метода `printFibonacci()`. Однако, с использованием рекурсии метод стал более универсальным, поскольку позволяет
получить последовательность чисел, начинающуюся не с первого элемента, без какой-либо особой модернизации метода.
Алгоритм, приведённый в первом примере, для выполнения этой же функции требует значительных доработок.

### 2.7.4.2 Быстрая сортировка

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Быстрая сортировка**](/conspect/definitions.md/#б) - это рекурсивная сортировка, имеющая линейно-логарифмическую или
квадратичную алгоритмическую сложность и основанная на нахождении некоторого элемента (первого или последнего) и
использовании его в качестве разделителя.

Логика данной сортировки подразумевает нахождение некоторого элемента (например, последнего) и использование его в
качестве некого разделителя. Далее происходит поиск пары элементов: первого элемента, что меньше разделителя, и первого
элемента, что больше разделителя. Затем элементы меняются местами. И так до тех пор, пока все элементы не будут
пройдены.

После череды взаимных свапов в левой части массива оказываются те элементы, что меньше разделителя, а в правой — те, что
больше. Затем разделитель устанавливается между двумя этими частями, и на каждой из половин рекурсивно запускается этот
же алгоритм.

Пример:

```java
public static void quickSort(int[] arr, int begin, int end) {
    if (begin < end) {
        int partitionIndex = partition(arr, begin, end);
        quickSort(arr, begin, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, end);
    }
}

private static int partition(int[] arr, int begin, int end) {
    int pivot = arr[end];
    int i = (begin - 1);
    for (int j = begin; j < end; j++) {
        if (arr[j] <= pivot) {
            i++;
            swapElements(arr, i, j);
        }
    }
    swapElements(arr, i + 1, end);
    return i + 1;
}

private static void swapElements(int[] arr, int left, int right) {
    int temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
}
```

![25.png](/pictures/25.png)

### 2.7.4.3 Сортировка слиянием

> [[_оглавление_]](../README.md/#27-алгоритмы)

[**Сортировка слиянием**](/conspect/definitions.md/#с) - это рекурсивная сортировка, имеющая линейно-логарифмическую
алгоритмическую сложность и основанная на разбиении массива пополам до тех пор, пока в его половинах не останется по
одному элементу, и последующем сборе на основе двух половин одного отсортированного массива.

На первой стадии массив разбивается пополам до тех пор, пока в его половинах не останется по одному элементу.

После этого происходит вторая стадия, которая на основе двух половин собирает один общий отсортированный массив. В
качестве параметров на вторую стадию приходит изначальный массив, а также его левая и правая половинки. И на основе
данных из двух половинок изначальный массив заполняется элементами. Это происходит с помощью трех бегунков, которые
независимо друг от друга двигаются по трем массивам.  
Начальные элементы из левого и правого массива сравниваются между собой. Меньший из них укладывается в основной массив,
а по массиву, в котором находился этот меньший элемент, происходит итерация по индексу на единицу, в результате чего
следующий элемент этого массива становится его начальным элементом. Затем цикл сравнения повторяется. Сравнения
происходят до тех пор, пока все элементы из левого или правого массивов не закончатся (первый блок `while`).  
После этого происходит дальнейшая итерация по элементам левого (второй блок `while`) или правого (третий блок `while`)
массивов (элементы которого ещё не внесены в исходный массив) и его элементы последовательно добавляются в исходный
массив (поскольку они уже были отсортированы ранее). То есть при каждом выполнении метода `merge()` выполняются
блоки `while` в комбинациях либо первый и второй, либо первый и третий.

Пример:

```java
public static void mergeSort(int[] arr) {
    if (arr.length < 2) {
        return;
    }
    int mid = arr.length / 2;
    int[] left = new int[mid];
    int[] right = new int[arr.length - mid];
    for (int i = 0; i < left.length; i++) {
        left[i] = arr[i];
    }
    for (int i = 0; i < right.length; i++) {
        right[i] = arr[mid + i];
    }
    mergeSort(left);
    mergeSort(right);
    merge(arr, left, right);
}

public static void merge(int[] arr, int[] left, int[] right) {
    int mainP = 0;
    int leftP = 0;
    int rightP = 0;
    while (leftP < left.length && rightP < right.length) {
        if (left[leftP] <= right[rightP]) {
            arr[mainP++] = left[leftP++];
        } else {
            arr[mainP++] = right[rightP++];
        }
    }
    while (leftP < left.length) {
        arr[mainP++] = left[leftP++];
    }
    while (rightP < right.length) {
        arr[mainP++] = right[rightP++];
    }
}
```

![26.png](/pictures/26.png)

### 2.7.5 Алгоритмы на графах

> [[_оглавление_]](../README.md/#27-алгоритмы)

Задачи с [графами](/conspect/02_07.md/#272-структура-данных) в реальной жизни встречаются часто, поэтому для их решения
существует ряд типовых алгоритмов.

Основные алгоритмы на графах:

- [**поиск в глубину**](/conspect/02_07.md/#2751-поиск-в-глубину) - для решения задач проверки существования пути из
  одной вершины в другую или определения, является ли неориентированный граф связным;
- [**поиск в ширину**](/conspect/02_07.md/#2752-поиск-в-ширину) - для решения задач проверки существования пути из одной
  вершины в другую или определения, является ли неориентированный граф связным, а также нахождения кратчайшего пути в
  невзвешенном графе;
- [**алгоритм Дейкстры**](/conspect/02_07.md/#2753-алгоритм-дейкстры) - для решения задач нахождения кратчайшего пути во
  взвешенном графе.

#### 2.7.5.1 Поиск в глубину

> [[_оглавление_]](../README.md/#27-алгоритмы)

###### Применимость: для обхода вершин графа и проверки их достижимости.

Это один из наиболее распространенных методов обхода графа. Данная стратегия поиска в глубину состоит в том, чтобы идти
«вглубь» графа насколько это возможно, а достигнув тупика, возвращаться к ближайшей вершине, у которой есть смежные
ранее не посещенные вершины.

Этот алгоритм хранит в стеке информацию о том, куда следует вернуться при достижении “тупика”.

Правила обхода в глубину:

1. посетить смежную, ранее не посещенную вершину, пометить её и занести в стек;
2. перейти на данную вершину;
3. повторить этап 1;
4. если выполнение пункта 1 невозможно, вернуться к предыдущей вершине и попытаться повторить правило 1: если это
   невозможно - вернуться к вершине до неё, и так далее, пока не найдём вершину, с которой можно продолжить обход;
5. продолжать до тех пор, пока все вершины не окажутся в стеке.

Пример:

> Задача: Составить цепочку слов из имеющегося массива, где последняя буква одного слова является первой буквой
> последующего (игра в "Города")

```java
public class EulerPath {
    // 1. Моделирование задачи:
    // Начальные и конечные буквы слов являются вершинами (нодами), а сами слова являются рёбрами этих вершин (нод)
    private Map<String, List<String>> graph = new TreeMap<>();  // граф в виде списка смежности, где
    //                                                          // ключ - буква (нода), значение - список слов (рёбер)
    private Set<String> nodes = new TreeSet<>();                // отдельный список нод (букв-ключей, для удобства)
    private String startNode;                                   // стартовая нода (буква)
    private List<String> result = new ArrayList<>();            // список для результата
    private Stack<String> vertexStack = new Stack<>();          // стек нод (вершин, букв-ключей)
    private Stack<String> edgeStack = new Stack<>();            // стек рёбер (самих слов)

    // 2. Инициализация модели:
    public EulerPath(String[] inputSequence) {                  //конструктор
        // 2.1 Создание списка нод: 
        // firstLetterOf() и lastLetterOf() - вспомогательные методы для получения букв (нод, вершин)
        for (String word : inputSequence) {
            nodes.add(firstLetterOf(word));
            nodes.add(lastLetterOf(word));
        }
        // 2.2 Инициализация графа (списка смежности) на основании полученного списка нод
        for (String node : nodes) {
            graph.put(node, new ArrayList<>());
        }
        // 2.3 Заполнение графа списка смежности:
        // поскольку рёбра (слова) исходящие, то первая буква слова является ключом, поэтому
        // необходимо распределить рёбра (слова) по соответствующим нодам (буквам)
        for (String word : inputSequence) {
            String node = firstLetterOf(word);
            List<String> tmp = graph.get(node);
            tmp.add(word);
        }
        // 2.4 Вычисляем стартовую ноду (букву):
        // в методе getStartNode() определяем разницу между количеством входящих и исходящих рёбер - 
        // стартовая нода (буква) та, у которой количество исходящих соединений больше количества входящих, а если
        // таковой нет, то задаём значение по умолчанию
        startNode = getStartNode(inputSequence);
        // 2.5 Производим поиск в глубину в методе findEulerPath()
        findEulerPath(startNode);
    }

    // вспомогательный метод для получения последней ноды (буквы)
    private String firstLetterOf(String word) {
        return word.substring(0, 1).toLowerCase();
    }

    // вспомогательный метод для получения первой ноды (буквы)
    private String lastLetterOf(String word) {
        return word.substring(word.length() - 1).toLowerCase();
    }

    // вспомогательный метод для поиска начальной ноды (буквы) последовательности слов (рёбер)
    private String getStartNode(String[] inputSequence) {
        Map<String, Integer[]> counter = new HashMap<>();       // заводим ассоциативный массив:
        //                                                      // ключ - буква (нода), значение - массив, где 
        //                                                      // [0] - количество исходящих рёбер,
        //                                                      // [1] - количество входящих рёбер
        for (String node : nodes) {
            Integer[] tuplet = {0, 0};                          // инициализируем ассоциативный массив начальными
            counter.put(node, tuplet);                          // значениями [0, 0]
        }
        for (String word : inputSequence) {                     // пробегаем по входящей последовательности
            String fl = firstLetterOf(word);                    // берём первую букву
            String ll = lastLetterOf(word);                     // и последнюю букву
            Integer[] tmp = counter.get(fl);                    // берём текущее значение счётчика для первой буквы
            tmp[0]++;                                           // и инкрементируем его
            tmp = counter.get(ll);                              // берём текущее значение счётчика для последней буквы
            tmp[1]++;                                           // и инкрементируем его
        }
        for (String node : counter.keySet()) {
            if (counter.get(node)[0] > counter.get(node)[1]) {  // проверяем, есть ли нода (буква), для которой
                //                                              // количество исходящих соединений больше количества 
                //                                              // входящих,
                return node;                                    // и если есть, то возвращаем её
            }
        }
        return "any";                                           // если подходящей ноды (буквы) нет, возвращаем слово “any”
    }

    // алгоритм поиска в глубину
    private void findEulerPath(String startNode) {
        // 0. Проверка начального значения ноды (буквы)
        // в случае, если она равна значению по умолчанию, то берём первую из сета нод
        if (startNode.equals("any")) startNode = nodes.toArray(new String[0])[0];
        // 1. Заносим стартовую ноду (букву) в стек нод
        vertexStack.push(startNode);
        // 2. Запускаем поиск, пока стек нод (букв) не будет пуст
        while (!vertexStack.isEmpty()) {
            // 2.1 Получаем список рёбер для верхней ноды в стеке
            List<String> currentEdgeList = graph.get(vertexStack.peek());
            // 2.2 Проверяем наличие в списке рёбер значений
            if (!currentEdgeList.isEmpty()) {
                // 2.2.1 Если рёбра в списке есть:
                // - заносим первое ребро (слово) в стек рёбер
                edgeStack.push(currentEdgeList.get(0));
                // - удаляем это ребро (слово) из списка рёбер для данной ноды
                currentEdgeList.remove(0);
                graph.put(vertexStack.peek(), currentEdgeList);
                // - получаем значение следующей ноды, соответствующей удалённому ребру
                String currentNode = lastLetterOf(edgeStack.peek());
                // - вносим полученное значение в стек нод
                vertexStack.push(currentNode);
            } else {
                // 2.2.2 Если рёбер в списке нет
                // - удаляем верхнюю ноду (букву) из стека нод
                vertexStack.pop();
                // - проверяем наличие рёбер (слов) в стеке рёбер
                if (!edgeStack.isEmpty()) {
                    // - если стек рёбер (слов) не пуст, то достаём верхнее значение из стека
                    //   и вносим его в результирующий список
                    result.add(edgeStack.pop());
                }
            }
        }
        // 3. Разворачиваем результрующий список
        Collections.reverse(result);
    }
    // Getters, setters, equals(), hashCode(), toString()
}
```

#### 2.7.5.2 Поиск в ширину

> [[_оглавление_]](../README.md/#27-алгоритмы)

###### Применимость: для обхода вершин графа и проверки их достижимости, а также нахождения кратчайшего пути в невзвешенном графе.

Данный алгоритм, как и поиск в глубину, является одним наиболее простых и базовых методов обхода графа.  
Его суть в том, что у есть некоторая текущая вершина, с которой заносят в очередь все смежные, непройденные вершины и
выбирают следующий элемент (который хранится первым в очереди), чтобы его сделать текущим.

Правила обхода в ширину:

1. посетить следующую, ранее не посещённую вершину, смежную с текущей вершиной, пометить её заранее и занести в очередь;
2. если выполнение правила № 1 невозможно - извлечь вершину из очереди и сделать её текущей вершиной;
3. если правила № 1 и № 2 невозможны, обход закончен, а все вершины пройдены (если граф связный).

Пример:

> Задача: Составить цепочку слов из имеющегося массива, где последняя буква одного слова является первой буквой
> последующего (игра в "Города")

```java
public class EulerPath {
    // 1. Моделирование задачи:
    // Начальные и конечные буквы слов являются вершинами (нодами), а сами слова являются рёбрами этих вершин (нод)
    private Map<String, List<String>> graph = new TreeMap<>();  // граф в виде списка смежности, где
    //                                                          // ключ - буква (нода), значение - список слов (рёбер)
    private Set<String> nodes = new TreeSet<>();                // отдельный список нод (букв-ключей, для удобства)
    private String startNode;                                   // стартовая нода (буква)
    private List<String> result = new ArrayList<>();            // список для результата
    private Queue<String> vertexQueue = new ArrayDeque<>();     // очередь нод (вершин, букв-ключей)
    private Queue<String> edgeQueue = new ArrayDeque<>();       // очередь рёбер (самих слов)

    // 2. Инициализация модели:
    public EulerPath(String[] inputSequence) {                  //конструктор
        // 2.1 Создание списка нод: 
        // firstLetterOf() и lastLetterOf() - вспомогательные методы для получения букв (нод, вершин)
        for (String word : inputSequence) {
            nodes.add(firstLetterOf(word));
            nodes.add(lastLetterOf(word));
        }
        // 2.2 Инициализация графа (списка смежности) на основании полученного списка нод
        for (String node : nodes) {
            graph.put(node, new ArrayList<>());
        }
        // 2.3 Заполнение графа списка смежности:
        // поскольку рёбра (слова) исходящие, то первая буква слова является ключом, поэтому
        // необходимо распределить рёбра (слова) по соответствующим нодам (буквам)
        for (String word : inputSequence) {
            String node = firstLetterOf(word);
            List<String> tmp = graph.get(node);
            tmp.add(word);
        }
        // 2.4 Вычисляем стартовую ноду (букву):
        // в методе getStartNode() определяем разницу между количеством входящих и исходящих рёбер - 
        // стартовая нода (буква) та, у которой количество исходящих соединений больше количества входящих, а если
        // таковой нет, то задаём значение по умолчанию
        startNode = getStartNode(inputSequence);
        // 2.5 Производим поиск в ширину в методе findEulerPath()
        findEulerPath(startNode);
    }

    // вспомогательный метод для получения последней ноды (буквы)
    private String firstLetterOf(String word) {
        return word.substring(0, 1).toLowerCase();
    }

    // вспомогательный метод для получения первой ноды (буквы)
    private String lastLetterOf(String word) {
        return word.substring(word.length() - 1).toLowerCase();
    }

    // вспомогательный метод для поиска начальной ноды (буквы) последовательности слов (рёбер)
    private String getStartNode(String[] inputSequence) {
        Map<String, Integer[]> counter = new HashMap<>();       // заводим ассоциативный массив:
        //                                                      // ключ - буква (нода), значение - массив, где 
        //                                                      // [0] - количество исходящих рёбер,
        //                                                      // [1] - количество входящих рёбер
        for (String node : nodes) {
            Integer[] tuplet = {0, 0};                          // инициализируем ассоциативный массив начальными
            counter.put(node, tuplet);                          // значениями [0, 0]
        }
        for (String word : inputSequence) {                     // пробегаем по входящей последовательности
            String fl = firstLetterOf(word);                    // берём первую букву
            String ll = lastLetterOf(word);                     // и последнюю букву
            Integer[] tmp = counter.get(fl);                    // берём текущее значение счётчика для первой буквы
            tmp[0]++;                                           // и инкрементируем его
            tmp = counter.get(ll);                              // берём текущее значение счётчика для последней буквы
            tmp[1]++;                                           // и инкрементируем его
        }
        for (String node : counter.keySet()) {
            if (counter.get(node)[0] > counter.get(node)[1]) {  // проверяем, есть ли нода (буква), для которой
                //                                              // количество исходящих соединений больше количества 
                //                                              // входящих,
                return node;                                    // и если есть, то возвращаем её
            }
        }
        return "any";                                           // если подходящей ноды (буквы) нет, возвращаем слово “any”
    }

    // алгоритм поиска в ширину
    private void findEulerPath(String startNode) {
        // 0. Проверка начального значения ноды (буквы)
        // в случае, если она равна значению по умолчанию, то берём первую из сета нод
        if (startNode.equals("any")) startNode = nodes.toArray(new String[0])[0];
        // 1. Заносим стартовую ноду (букву) в очередь нод
        vertexQueue.add(startNode);
        // 2. Запускаем поиск, пока очередь нод (букв) не будет пуста
        while (!vertexQueue.isEmpty()) {
            // 2.1 Достаём первую ноду (букву) из очереди нод
            String currentNode = vertexQueue.poll();
            // 2.2 Получаем список рёбер для выбранной ноды
            List<String> currentEdgeList = graph.get(currentNode);
            // 2.3 Проверяем наличие в списке рёбер значений и в случае их наличия последовательно добавляем все 
            //     достижимые ноды (буквы) в очередь нод, рёбра в очередь рёбер, а их значение в списке смежности 
            //     (графе) обнуляем
            if (!currentEdgeList.isEmpty()) {
                for (String edge : currentEdgeList) {
                    String nextNode = lastLetterOf(edge);
                    edgeQueue.add(edge);
                    vertexQueue.add(nextNode);
                }
                graph.put(currentNode, new ArrayList<>());
            }
        }
        // 3. Достаём первое ребро из очереди рёбер и заносим его в результат
        result.add(edgeQueue.poll());
        // 4. Запускаем цикл расчёта результата
        while (!edgeQueue.isEmpty()) {
            // 4.1 Проверяем, что в оставшейся очереди рёбер имеется ребро, начинающееся с последней буквы (ноды) 
            //     результата, и если такового нет, то выходим из цикла
            String s = edgeQueue.stream()
                    .filter(e -> e.startsWith(lastLetterOf(result.getLast())))
                    .findFirst()
                    .orElse(null);
            if (s == null) break;
            // 4.2 Получаем первое ребро из очереди рёбер
            String currentEdge = edgeQueue.poll();
            // 4.3 Проверяем, начинается ли оно с ноды (буквы), которой заканчивается последнее ребро (слово) результата
            if (firstLetterOf(currentEdge).equals(lastLetterOf(result.getLast()))) {
                // - если да, то добавляем его в результат
                result.add(currentEdge);
            } else {
                // - если нет, то добавляем это ребро (слово) в конец очереди рёбер
                edgeQueue.add(currentEdge);
            }
        }
    }
    // Getters, setters, equals(), hashCode(), toString()
}
```

> Необходимо отметить, что алгоритм поиска в ширину позволяет найти кратчайший путь от начала до конца, используя
> минимальное количество вершин.

#### 2.7.5.3 Алгоритм Дейкстры

> [[_оглавление_]](../README.md/#27-алгоритмы)

###### Применимость: поиск кратчайшего пути во взвешенном графе.

Алгоритм Дейкстры работает на ориентированных (с некоторыми дополнениями и на неориентированных) графах, и призван
искать кратчайшие пути между заданной вершиной и всеми остальными вершинами в графе.

Алгоритм Дейкстры может найти кратчайший путь между вершинами `A` и `B` в графе, только если существует хотя бы один
путь между этими вершинами. Если это условие не выполняется, то алгоритм отработает корректно, вернув значение
"бесконечность" для пары несвязанных вершин.

Шаги алгоритма Дейкстры:

- устанавливает расстояние до начального узла равным нулю;
- устанавливает расстояние до всех остальных вершин на бесконечное значение;
- выбирает неотмеченную вершину графа, которая находится на наименьшем расстоянии от начального узла, и отмечает ее;
- рассчитывает расстояние до смежных вершин, выбирая наименьшее расстояние при каждой оценке;
- отмечает следующий узел;
- алгоритм действует по этому сценарию до тех пор, пока все вершины не будут отмечены.

Пример:

> Задача: Составить цепочку слов из имеющегося массива от заданного начального слова до конечного, где последняя буква
> одного слова является первой буквой последующего (игра в "Города"), при этом составленная цепочка слов должна
> содержать минимальное количество букв.

```java
public class EulerPath {
    // 1. Моделирование задачи:
    // Начальные и конечные буквы слов являются вершинами (нодами), а сами слова являются рёбрами этих вершин (нод)
    private Map<String, List<String>> graph = new TreeMap<>();  // граф в виде списка смежности, где
    //                                                          // ключ - буква (нода), значение - список слов (рёбер)
    private Set<String> nodes = new TreeSet<>();                // отдельный список нод (букв-ключей, для удобства)
    private String startEdge;                                   // начальное ребро (первое слово)
    private String endEdge;                                     // конечное ребро (последнее слово)
    private List<String> result = new ArrayList<>();            // список для результата
    private Map<String, Integer> distance = new HashMap<>();    // ассоциативный массив для кратчайших расстояний до
    //                                                          // нод (букв) из стартовой ноды (буквы)
    private Map<String, List<String>> ways = new HashMap<>();   // ассоциативный массив для кратчайших путей
    private Set<String> unvisited = new HashSet<>();            // сэт для не пройденных рёбер
    private Queue<String> nodeQueue = new ArrayDeque<>();       // очередь для посещения нод (букв)

    // 2. Инициализация модели:
    public EulerPath(String[] inputSequence, String startEdge, String endEdge) {
        // 2.1 Вносим начальное и конечное рёбра (слова) в модель
        this.startEdge = startEdge;
        this.endEdge = endEdge;
        // 2.2 Составляем сэт нод (букв) и заполняем сэт не посещённых рёбер
        for (String word : inputSequence) {
            nodes.add(firstLetterOf(word));
            nodes.add(lastLetterOf(word));
            unvisited.add(word);
        }
        // 2.3 Инициализация графа (списка смежности), ассоциативных массивов кратчайших расстояний и путей
        //     на основании полученного списка нод
        for (String node : nodes) {
            // - граф инициализируется пустым списком
            graph.put(node, new ArrayList<>());
            // - ассоциативный массив кратчайших расстояний инициализируется значениями бесконечности 
            //   (в роли которого выступает максимальное значение класса Integer)
            distance.put(node, Integer.MAX_VALUE);
            // - ассоциативный массив кратчайших путей инициализируется пустым списком
            ways.put(node, new ArrayList<>());
        }
        // 2.4 Заполнение графа списка смежности:
        // поскольку рёбра (слова) исходящие, то первая буква слова является ключом, поэтому
        // необходимо распределить рёбра (слова) по соответствующим нодам (буквам)
        for (String word : inputSequence) {
            String node = firstLetterOf(word);
            List<String> tmp = graph.get(node);
            tmp.add(word);
        }
        // 2.5 Определение стартовой и конечной ноды (буквы)
        // поскольку начальное и конечное рёбра (слова) известны, то начальной нодой (буквой)
        // является последняя нода (буква) начального ребра (слова), а конечной нодой (буквой) - первая
        // нода (буква) конечного ребра (слова)
        String startNode = lastLetterOf(startEdge);
        String endNode = firstLetterOf(endEdge);
        // 2.6 Производим поиск алгоритмом Дейкстры в методе findEulerPath()
        findEulerPath(startNode, endNode);
    }

    // вспомогательный метод для получения последней ноды (буквы)
    private String firstLetterOf(String word) {
        return word.substring(0, 1).toLowerCase();
    }

    // вспомогательный метод для получения первой ноды (буквы)
    private String lastLetterOf(String word) {
        return word.substring(word.length() - 1).toLowerCase();
    }

    // алгоритм Дейкстры
    private void findEulerPath(String startNode, String endNode) {
        // 1. Удаляем из сета не посещённых рёбер начальное и конечное рёбра (слова)
        unvisited.remove(startEdge);
        unvisited.remove(endEdge);
        // 2. Добавляем в очередь нод стартовую ноду (букву)
        nodeQueue.add(startNode);
        // 3. Добавляем в ассоциативный массив кратчайших путей значение для стартовой ноды, равное "0"
        distance.put(startNode, 0);
        // 4. Запускаем цикл поиска до тех пор, пока:
        // - не будут пройдены все рёбра
        // - И! не останется нод в очереди на посещение
        while (!unvisited.isEmpty() && !nodeQueue.isEmpty()) {
            // 4.1 Достаём первую ноду из очереди на посещение
            String currentNode = nodeQueue.poll();
            // 4.2 Получаем из графа список всех исходящих рёбер
            List<String> edges = graph.get(currentNode);
            // 4.3 В случае, если список рёбер не пуст
            if (!edges.isEmpty()) {
                // - проходим по всем исходящим рёбрам
                for (String edge : edges) {
                    // - если ребро циклическое (то есть возвращает нас в ту же ноду)
                    //   удаляем его из списка не посещённых
                    if (lastLetterOf(edge).equals(currentNode)) unvisited.remove(edge);
                    // - если ребро присутствует в списке не посещённых
                    if (unvisited.contains(edge)) {
                        // * получаем конечную ноду ребра (последняя буква слова)
                        String node = lastLetterOf(edge);
                        // * получаем длину ребра
                        int length = edge.length();
                        // * если расстояние до ребра в ассоциативном массиве кратчайших расстояний больше 
                        //   суммы длины ребра и расстояния до текущей ноды
                        if (distance.get(node) > length + distance.get(currentNode)) {
                            // + меняем в ассоциативном массиве кратчайших расстояний значение на
                            //   сумму длины ребра и расстояния до текущей ноды
                            distance.put(node, length + distance.get(currentNode));
                            // + получаем кратчайший путь до текущей ноды из ассоциативного массива путей 
                            List<String> currentWay = ways.get(currentNode);
                            // + обнуляем значение кратчайшего маршрута для данной конечной ноды, добавляем в него 
                            //   маршрут текущей конечной ноды и значение ребра 
                            ways.put(node, new ArrayList<>());
                            ways.get(node).addAll(currentWay);
                            ways.get(node).add(edge);
                        }
                        // * удаляем ребро из сета не посещённых
                        unvisited.remove(edge);
                        // * добавляем конечную ноду в очередь на посещение
                        nodeQueue.add(node);
                    }
                }
            }
        }
        // 5. По завершению цикла добавляем в список результата:
        // - начальное ребро (слово)
        result.add(startEdge);
        // - рассчитанное значение кратчайшего пути для конечной ноды из ассоциативного массива кратчайших путей
        result.addAll(ways.get(endNode));
        // - конечное ребро (слово)
        result.add(endEdge);
    }
    // Getters, setters, equals(), hashCode(), toString()
}
```