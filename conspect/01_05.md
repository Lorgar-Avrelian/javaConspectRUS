## 1.5 Строки (Класс String)

> [[_оглавление_]](../README.md/#15-строки-класс-string)

[**Строка** (тип данных **String**)](/conspect/definitions.md/#с) – это последовательность символов типа 
$\textrm{\color{orange}char}$.  
Значения строк пишутся в двойных кавычках (`" "`).  
Строки, как и массивы, являются объектами. Если им не присвоить значение (не инициализировать), они будут содержать в
себе `null`.  
Строка имеет внутренние свойства. Главное из них – массив типа `byte`, где и хранятся все символы конкретной строки.  
Строка – неизменяемый объект, после создания изменить её невозможно. Все создаваемые в коде строки попадают в пул
строк.  
Неизменяемость строк обусловлена способом их хранения в памяти, а также соображениями безопасности.

### 1.5.1 Пул строк (String pool)

> [[_оглавление_]](../README.md/#15-строки-класс-string)

[**Пул строк**](/conspect/definitions.md/#п) – это набор строк, который хранится в памяти Java _heap_; это один из
внутренних механизмов Java, благодаря которому в памяти сохраняется только один экземпляр строки идентичного
содержания.  
Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если
находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка.  
Когда же строка создаётся с помощью ключевого слова `new`, мы принуждаем класс `String` создать новую строку в пуле.

### 1.5.2 Конкатенация (сложение) строк

> [[_оглавление_]](../README.md/#15-строки-класс-string)

[**Конкатенация**](/conspect/definitions.md/#к) – это операция склеивания объектов линейной структуры, обычно строк.

### 1.5.3 Методы для работы со строками

> [[_оглавление_]](../README.md/#15-строки-класс-string)

#### 1.5.3.1 equals()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Для сравнения строк используют метод `equals()`. Этот метод в качестве параметра принимает другую строку и возвращает
`true`/`false`.  
Синтаксис метода выглядит следующим образом:

```java 
s2.equals(s1);
```

#### 1.5.3.2 equalsIgnoreCase()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Для сравнения строк без учёта регистра используют метод `equalsIgnoreCase()`.  
Синтаксис метода выглядит следующим образом:

```java 
s2.equalsIgnoreCase(s1);
```

#### 1.5.3.3 length()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Для определения длины строки используют метод `length()`, аналогичный по своему назначению со свойством `length`
массивов. Не смотря на то, что строки являются массивами символов, строки свойства `length` не имеют.  
Синтаксис метода выглядит следующим образом:

```java 
int stringLength = s.length();
```

#### 1.5.3.4 isEmpty()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Для определения является ли строка пустой, то есть не содержащей ни одного символа, используют метод `isEmpty()`.  
Синтаксис метода выглядит следующим образом:

```java 
boolean sIsEmpty = s.isEmpty();
```

#### 1.5.3.5 isBlank()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Для определения является ли строка пустой, то есть не содержащей ни одного символа, или содержащей только пробелы
используют метод `isBlank()`.  
Синтаксис метода выглядит следующим образом:

```java 
boolean sIsBlank = s.isBlank();
``` 

Если в строке будет только пробел (`" "`), то метод `isEmpty()` вернет `false`, метод `isBlank()` – `true`.

#### 1.5.3.6 contains()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `contains()` проверяет наличие в строке последовательности символов.  
Синтаксис метода выглядит следующим образом:

```java
boolean sContains = s.contains("последовательность символов");
```

#### 1.5.3.7 endsWith()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `endsWith()` проверяет наличие в окончании строки последовательности символов.  
Синтаксис метода выглядит следующим образом:

```java
boolean sEndsWith = s.endsWith("последовательность символов");
```

#### 1.5.3.8 startsWith()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `startsWith()` проверяет наличие в начале строки последовательности символов.  
Синтаксис метода выглядит следующим образом:

```java 
boolean sStartsWith = s.startsWith("последовательность символов");
```

#### 1.5.3.9 charAt()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `charAt()` возвращает символ строки с указанным индексом (позицией).  
Синтаксис метода выглядит следующим образом:

```java 
char c = s.charAt(2);
```

#### 1.5.3.10 substring()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `substring()` извлекает символы, начиная с первого параметра в ячейке включительно, заканчивая вторым параметром
не включительно.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.substring(2, 4);
```

#### 1.5.3.11 toUpperCase()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `toUpperCase()` возвращает значение строки, преобразованное в верхний регистр.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.toUpperCase();
```

#### 1.5.3.12 toLowerCase()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `toLowerCase()` возвращает значение строки, преобразованное в нижний регистр.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.toLowerCase();
```

#### 1.5.3.13 trim()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `trim()` удаляет все символы пробелов (`" "`) с начала и конца строки.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.trim();
```

#### 1.5.3.14 split()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `split()` создает из строки массив, разбив ее на части. Разделитель, по которому будет произведена разбивка,
указывается в скобках.  
Синтаксис метода выглядит следующим образом:

```java 
String[] strings = s1.split(" ");
```

#### 1.5.3.15 toCharArray()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `toCharArray()` преобразует строку в массив символов.  
Синтаксис метода выглядит следующим образом:

```java 
char[] c = s.toCharArray();
```

#### 1.5.3.16 replace()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `replace()` возвращает новую строку с символами, замененными на указанные.  
Синтаксис метода выглядит следующим образом:

```java 
String s2 = s1.replace(" ", "");
```

#### 1.5.3.17 repeat()

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Метод `repeat()` возвращает новую строку, которая содержит указанное количество соединённых вместе копий строки, на
которой был вызван метод.  
Синтаксис метода выглядит следующим образом:

```java
String s1 = "#";
String s2 = s1.repeat(10);
```

Метод `repeat()` не изменяет строку, на которую был вызван, а возвращает новую: `s2` получит строку `s1`, которая будет
повторена 10 раз (значение из скобок).

### 1.5.4 Формирование строк из массивов

> [[_оглавление_]](../README.md/#15-строки-класс-string)

#### 1.5.4.1 Символьный массив

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Бывают ситуации, когда у нас есть символьный массив, а мы хотим превратить его в строку.  
В такой ситуации нам поможет другой способ создания строки:

```java
char[] symbols = {'a', 'b', 'c'};
String string = new String(symbols);
```

Этот способ позволит нам получить строку на основе тех символов, что лежат в массиве.

#### 1.5.4.2 Массив байтов

> [[_оглавление_]](../README.md/#15-строки-класс-string)

Из массива байтов тоже можно собрать строку.  
Веб-приложения, помимо текста, могут передавать данные еще и в байтах.
Это быстрее, безопаснее и зачастую выигрывает в производительности.  
Предположим, что мы получили от соседнего приложения текстовые данные в байтовом формате и собрали их в массив.

```java
private static void textFromBytes() {
    byte[] textInBytes = {33, 33, 33};
    String stringFromBytes = new String(textInBytes);
    System.out.println(stringFromBytes);
}
```

В консоль выведется строка `!!!`, так как значение `33` соответствует символу восклицательного знака в таблице символов
_ASCII_.